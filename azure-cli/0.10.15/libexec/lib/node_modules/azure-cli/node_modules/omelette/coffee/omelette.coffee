###
# Omelette Simple Auto Completion for Node
###
{EventEmitter} = require "events"
path           = require "path"
fs             = require "fs"
os             = require "os"

class Omelette extends EventEmitter

  {log} = console

  constructor: ->
    @compgen  = process.argv.indexOf "--compgen"
    @install  = process.argv.indexOf("--completion") > -1
    @installFish  = process.argv.indexOf("--completion-fish") > -1
    isZsh     = process.argv.indexOf("--compzsh") > -1
    @isDebug  = process.argv.indexOf("--debug") > -1

    @fragment = parseInt(process.argv[@compgen+1])-(if isZsh then 1 else 0)
    @word     = process.argv[@compgen+2]
    @line     = process.argv[@compgen+3]

    {@HOME, @SHELL} = process.env

  setProgram: (programs)->
    programs = programs.split '|'
    [@program] = programs
    @programs = programs.map (program)-> program.replace ///
      [
       ^     # Do not allow except:
        A-Z  # .. uppercase
        a-z  # .. lowercase
        0-9  # .. numbers
        \.   # .. dots
        \_   # .. underscores
        \-   # .. dashes
      ]
    ///g, ''

  setFragments: (@fragments...)->

  generate: ->
    @emit "complete", @fragments[@fragment-1], @word, @line
    @emit @fragments[@fragment-1], @word, @line
    @emit "$#{@fragment}", @word, @line
    process.exit()

  reply: (words=[])->
    console.log words.join "\n"
    process.exit()

  generateCompletionCode: ->
    completions = @programs.map (program)=>
      completion = "_#{program}_complette"
      """
      ### #{program} completion - begin. generated by omelette.js ###
      if type compdef &>/dev/null; then
        #{completion}() {
          compadd -- `#{@program} --compzsh --compgen "${CURRENT}" "${words[CURRENT-1]}" "${BUFFER}"`
        }
        compdef #{completion} #{program}
      elif type complete &>/dev/null; then
        #{completion}() {
          COMPREPLY=( $(compgen -W '$(#{@program} --compbash --compgen "${COMP_CWORD}" "${COMP_WORDS[COMP_CWORD-1]}" "${COMP_LINE}")' -- "${COMP_WORDS[COMP_CWORD]}") )
        }
        complete -F #{completion} #{program}
      fi
      ### #{program} completion - end ###
      """

    # Adding aliases for testing purposes
    completions.push @generateTestAliases() if @isDebug
    completions.join os.EOL

  generateCompletionCodeFish: ->
    completions = @programs.map (program)=>
      completion = "_#{program}_complette"
      """
      ### #{program} completion - begin. generated by omelette.js ###
      function #{completion}
        #{@program} --compfish --compgen (count (commandline -poc)) (commandline -pt) (commandline -pb)
      end
      complete -f -c #{program} -a '(#{completion})'
      ### #{program} completion - end ###
      """

    # Adding aliases for testing purposes
    completions.push @generateTestAliases() if @isDebug
    completions.join os.EOL

  generateTestAliases: ->
    fullPath = path.join process.cwd(), @program
    debugAliases   = @programs.map((program)-> "  alias #{program}=#{fullPath}").join os.EOL
    debugUnaliases = @programs.map((program)-> "  unalias #{program}").join os.EOL

    """
    ### test method ###
    omelette-debug-#{@program}() {
    #{debugAliases}
    }
    omelette-nodebug-#{@program}() {
    #{debugUnaliases}
    }
    ### tests ###
    """

  checkInstall: ->
    if @install
      log @generateCompletionCode()
      process.exit()
    if @installFish
      log @generateCompletionCodeFish()
      process.exit()

  getActiveShell: ->
    {SHELL} = process.env
    if SHELL.match /bash/     then 'bash'
    else if SHELL.match /zsh/ then 'zsh'
    else if SHELL.match /fish/ then 'fish'

  getDefaultShellInitFile: ->

    fileAt = (root)->
      (file)-> path.join root, file

    fileAtHome = fileAt @HOME

    switch @shell = @getActiveShell()
      when 'bash' then fileAtHome '.bash_profile'
      when 'zsh'  then fileAtHome '.zshrc'
      when 'fish'  then fileAtHome '.config/fish/config.fish'

  setupShellInitFile: (initFile=@getDefaultShellInitFile())->

    template = (command)=>
      """

      # begin #{@program} completion
      #{command}
      # end #{@program} completion

      """

    switch @shell
      when 'bash'
        programFolder = path.join @HOME, ".#{@program}"
        completionPath = path.join programFolder, 'completion.sh'

        fs.mkdirSync programFolder unless fs.existsSync programFolder
        fs.writeFileSync completionPath, @generateCompletionCode()
        fs.appendFileSync initFile, template "source #{completionPath}"

      when 'zsh'
        fs.appendFileSync initFile, template ". <(#{@program} --completion)"

      when 'fish'
        fs.appendFileSync initFile, template "#{@program} --completion-fish | source"

    process.exit();

  init: ->
    do @generate if @compgen > -1

module.exports = (template)->
  [program, fragments...] = template.split /\s+/
  fragments = fragments.map (fragment)-> fragment.replace /^\<+|\>+$/g, ''
  _omelette = new Omelette
  _omelette.setProgram program
  _omelette.setFragments fragments...
  _omelette.checkInstall()
  _omelette
