<html lang="en">
<head>
<title>PowerPC Built-in Functions - Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Builtins.html#Target-Builtins" title="Target Builtins">
<link rel="prev" href="picoChip-Built_002din-Functions.html#picoChip-Built_002din-Functions" title="picoChip Built-in Functions">
<link rel="next" href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions" title="PowerPC AltiVec/VSX Built-in Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988-2016 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="PowerPC-Built-in-Functions"></a>
<a name="PowerPC-Built_002din-Functions"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions">PowerPC AltiVec/VSX Built-in Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="picoChip-Built_002din-Functions.html#picoChip-Built_002din-Functions">picoChip Built-in Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Builtins.html#Target-Builtins">Target Builtins</a>
<hr>
</div>

<h4 class="subsection">6.59.20 PowerPC Built-in Functions</h4>

<p>The following built-in functions are always available and can be used to
check the PowerPC target platform type:

<div class="defun">
&mdash; Built-in Function: void <b>__builtin_cpu_init</b> (<var>void</var>)<var><a name="index-g_t_005f_005fbuiltin_005fcpu_005finit-4294"></a></var><br>
<blockquote><p>This function is a <code>nop</code> on the PowerPC platform and is included solely
to maintain API compatibility with the x86 builtins. 
</p></blockquote></div>

<div class="defun">
&mdash; Built-in Function: int <b>__builtin_cpu_is</b> (<var>const char *cpuname</var>)<var><a name="index-g_t_005f_005fbuiltin_005fcpu_005fis-4295"></a></var><br>
<blockquote><p>This function returns a value of <code>1</code> if the run-time CPU is of type
<var>cpuname</var> and returns <code>0</code> otherwise. The following CPU names can be
detected:

          <dl>
<dt>`<samp><span class="samp">power9</span></samp>'<dd>IBM POWER9 Server CPU. 
<br><dt>`<samp><span class="samp">power8</span></samp>'<dd>IBM POWER8 Server CPU. 
<br><dt>`<samp><span class="samp">power7</span></samp>'<dd>IBM POWER7 Server CPU. 
<br><dt>`<samp><span class="samp">power6x</span></samp>'<dd>IBM POWER6 Server CPU (RAW mode). 
<br><dt>`<samp><span class="samp">power6</span></samp>'<dd>IBM POWER6 Server CPU (Architected mode). 
<br><dt>`<samp><span class="samp">power5+</span></samp>'<dd>IBM POWER5+ Server CPU. 
<br><dt>`<samp><span class="samp">power5</span></samp>'<dd>IBM POWER5 Server CPU. 
<br><dt>`<samp><span class="samp">ppc970</span></samp>'<dd>IBM 970 Server CPU (ie, Apple G5). 
<br><dt>`<samp><span class="samp">power4</span></samp>'<dd>IBM POWER4 Server CPU. 
<br><dt>`<samp><span class="samp">ppca2</span></samp>'<dd>IBM A2 64-bit Embedded CPU
<br><dt>`<samp><span class="samp">ppc476</span></samp>'<dd>IBM PowerPC 476FP 32-bit Embedded CPU. 
<br><dt>`<samp><span class="samp">ppc464</span></samp>'<dd>IBM PowerPC 464 32-bit Embedded CPU. 
<br><dt>`<samp><span class="samp">ppc440</span></samp>'<dd>PowerPC 440 32-bit Embedded CPU. 
<br><dt>`<samp><span class="samp">ppc405</span></samp>'<dd>PowerPC 405 32-bit Embedded CPU. 
<br><dt>`<samp><span class="samp">ppc-cell-be</span></samp>'<dd>IBM PowerPC Cell Broadband Engine Architecture CPU. 
</dl>

      <p>Here is an example:
     <pre class="smallexample">          if (__builtin_cpu_is ("power8"))
            {
               do_power8 (); // POWER8 specific implementation.
            }
          else
            {
               do_generic (); // Generic implementation.
            }
     </pre>
      </blockquote></div>

<div class="defun">
&mdash; Built-in Function: int <b>__builtin_cpu_supports</b> (<var>const char *feature</var>)<var><a name="index-g_t_005f_005fbuiltin_005fcpu_005fsupports-4296"></a></var><br>
<blockquote><p>This function returns a value of <code>1</code> if the run-time CPU supports the HWCAP
feature <var>feature</var> and returns <code>0</code> otherwise. The following features can be
detected:

          <dl>
<dt>`<samp><span class="samp">4xxmac</span></samp>'<dd>4xx CPU has a Multiply Accumulator. 
<br><dt>`<samp><span class="samp">altivec</span></samp>'<dd>CPU has a SIMD/Vector Unit. 
<br><dt>`<samp><span class="samp">arch_2_05</span></samp>'<dd>CPU supports ISA 2.05 (eg, POWER6)
<br><dt>`<samp><span class="samp">arch_2_06</span></samp>'<dd>CPU supports ISA 2.06 (eg, POWER7)
<br><dt>`<samp><span class="samp">arch_2_07</span></samp>'<dd>CPU supports ISA 2.07 (eg, POWER8)
<br><dt>`<samp><span class="samp">arch_3_00</span></samp>'<dd>CPU supports ISA 3.00 (eg, POWER9)
<br><dt>`<samp><span class="samp">archpmu</span></samp>'<dd>CPU supports the set of compatible performance monitoring events. 
<br><dt>`<samp><span class="samp">booke</span></samp>'<dd>CPU supports the Embedded ISA category. 
<br><dt>`<samp><span class="samp">cellbe</span></samp>'<dd>CPU has a CELL broadband engine. 
<br><dt>`<samp><span class="samp">dfp</span></samp>'<dd>CPU has a decimal floating point unit. 
<br><dt>`<samp><span class="samp">dscr</span></samp>'<dd>CPU supports the data stream control register. 
<br><dt>`<samp><span class="samp">ebb</span></samp>'<dd>CPU supports event base branching. 
<br><dt>`<samp><span class="samp">efpdouble</span></samp>'<dd>CPU has a SPE double precision floating point unit. 
<br><dt>`<samp><span class="samp">efpsingle</span></samp>'<dd>CPU has a SPE single precision floating point unit. 
<br><dt>`<samp><span class="samp">fpu</span></samp>'<dd>CPU has a floating point unit. 
<br><dt>`<samp><span class="samp">htm</span></samp>'<dd>CPU has hardware transaction memory instructions. 
<br><dt>`<samp><span class="samp">htm-nosc</span></samp>'<dd>Kernel aborts hardware transactions when a syscall is made. 
<br><dt>`<samp><span class="samp">ic_snoop</span></samp>'<dd>CPU supports icache snooping capabilities. 
<br><dt>`<samp><span class="samp">ieee128</span></samp>'<dd>CPU supports 128-bit IEEE binary floating point instructions. 
<br><dt>`<samp><span class="samp">isel</span></samp>'<dd>CPU supports the integer select instruction. 
<br><dt>`<samp><span class="samp">mmu</span></samp>'<dd>CPU has a memory management unit. 
<br><dt>`<samp><span class="samp">notb</span></samp>'<dd>CPU does not have a timebase (eg, 601 and 403gx). 
<br><dt>`<samp><span class="samp">pa6t</span></samp>'<dd>CPU supports the PA Semi 6T CORE ISA. 
<br><dt>`<samp><span class="samp">power4</span></samp>'<dd>CPU supports ISA 2.00 (eg, POWER4)
<br><dt>`<samp><span class="samp">power5</span></samp>'<dd>CPU supports ISA 2.02 (eg, POWER5)
<br><dt>`<samp><span class="samp">power5+</span></samp>'<dd>CPU supports ISA 2.03 (eg, POWER5+)
<br><dt>`<samp><span class="samp">power6x</span></samp>'<dd>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr. 
<br><dt>`<samp><span class="samp">ppc32</span></samp>'<dd>CPU supports 32-bit mode execution. 
<br><dt>`<samp><span class="samp">ppc601</span></samp>'<dd>CPU supports the old POWER ISA (eg, 601)
<br><dt>`<samp><span class="samp">ppc64</span></samp>'<dd>CPU supports 64-bit mode execution. 
<br><dt>`<samp><span class="samp">ppcle</span></samp>'<dd>CPU supports a little-endian mode that uses address swizzling. 
<br><dt>`<samp><span class="samp">smt</span></samp>'<dd>CPU support simultaneous multi-threading. 
<br><dt>`<samp><span class="samp">spe</span></samp>'<dd>CPU has a signal processing extension unit. 
<br><dt>`<samp><span class="samp">tar</span></samp>'<dd>CPU supports the target address register. 
<br><dt>`<samp><span class="samp">true_le</span></samp>'<dd>CPU supports true little-endian mode. 
<br><dt>`<samp><span class="samp">ucache</span></samp>'<dd>CPU has unified I/D cache. 
<br><dt>`<samp><span class="samp">vcrypto</span></samp>'<dd>CPU supports the vector cryptography instructions. 
<br><dt>`<samp><span class="samp">vsx</span></samp>'<dd>CPU supports the vector-scalar extension. 
</dl>

      <p>Here is an example:
     <pre class="smallexample">          if (__builtin_cpu_supports ("fpu"))
            {
               asm("fadd %0,%1,%2" : "=d"(dst) : "d"(src1), "d"(src2));
            }
          else
            {
               dst = __fadd (src1, src2); // Software FP addition function.
            }
     </pre>
      </blockquote></div>

 <p>These built-in functions are available for the PowerPC family of
processors:
<pre class="smallexample">     float __builtin_recipdivf (float, float);
     float __builtin_rsqrtf (float);
     double __builtin_recipdiv (double, double);
     double __builtin_rsqrt (double);
     uint64_t __builtin_ppc_get_timebase ();
     unsigned long __builtin_ppc_mftb ();
     double __builtin_unpack_longdouble (long double, int);
     long double __builtin_pack_longdouble (double, double);
</pre>
 <p>The <code>vec_rsqrt</code>, <code>__builtin_rsqrt</code>, and
<code>__builtin_rsqrtf</code> functions generate multiple instructions to
implement the reciprocal sqrt functionality using reciprocal sqrt
estimate instructions.

 <p>The <code>__builtin_recipdiv</code>, and <code>__builtin_recipdivf</code>
functions generate multiple instructions to implement division using
the reciprocal estimate instructions.

 <p>The <code>__builtin_ppc_get_timebase</code> and <code>__builtin_ppc_mftb</code>
functions generate instructions to read the Time Base Register.  The
<code>__builtin_ppc_get_timebase</code> function may generate multiple
instructions and always returns the 64 bits of the Time Base Register. 
The <code>__builtin_ppc_mftb</code> function always generates one instruction and
returns the Time Base Register value as an unsigned long, throwing away
the most significant word on 32-bit environments.

 <p>Additional built-in functions are available for the 64-bit PowerPC
family of processors, for efficient use of 128-bit floating point
(<code>__float128</code>) values.

 <p>The following floating-point built-in functions are available with
<code>-mfloat128</code> and Altivec support.  All of them implement the
function that is part of the name.

<pre class="smallexample">     __float128 __builtin_fabsq (__float128)
     __float128 __builtin_copysignq (__float128, __float128)
</pre>
 <p>The following built-in functions are available with <code>-mfloat128</code>
and Altivec support.

     <dl>
<dt><code>__float128 __builtin_infq (void)</code><dd>Similar to <code>__builtin_inf</code>, except the return type is <code>__float128</code>. 
<a name="index-g_t_005f_005fbuiltin_005finfq-4297"></a>
<br><dt><code>__float128 __builtin_huge_valq (void)</code><dd>Similar to <code>__builtin_huge_val</code>, except the return type is <code>__float128</code>. 
<a name="index-g_t_005f_005fbuiltin_005fhuge_005fvalq-4298"></a>
<br><dt><code>__float128 __builtin_nanq (void)</code><dd>Similar to <code>__builtin_nan</code>, except the return type is <code>__float128</code>. 
<a name="index-g_t_005f_005fbuiltin_005fnanq-4299"></a>
<br><dt><code>__float128 __builtin_nansq (void)</code><dd>Similar to <code>__builtin_nans</code>, except the return type is <code>__float128</code>. 
<a name="index-g_t_005f_005fbuiltin_005fnansq-4300"></a></dl>

 <p>The following built-in functions are available for the PowerPC family
of processors, starting with ISA 2.06 or later (<samp><span class="option">-mcpu=power7</span></samp>
or <samp><span class="option">-mpopcntd</span></samp>):
<pre class="smallexample">     long __builtin_bpermd (long, long);
     int __builtin_divwe (int, int);
     int __builtin_divweo (int, int);
     unsigned int __builtin_divweu (unsigned int, unsigned int);
     unsigned int __builtin_divweuo (unsigned int, unsigned int);
     long __builtin_divde (long, long);
     long __builtin_divdeo (long, long);
     unsigned long __builtin_divdeu (unsigned long, unsigned long);
     unsigned long __builtin_divdeuo (unsigned long, unsigned long);
     unsigned int cdtbcd (unsigned int);
     unsigned int cbcdtd (unsigned int);
     unsigned int addg6s (unsigned int, unsigned int);
</pre>
 <p>The <code>__builtin_divde</code>, <code>__builtin_divdeo</code>,
<code>__builtin_divdeu</code>, <code>__builtin_divdeou</code> functions require a
64-bit environment support ISA 2.06 or later.

 <p>The following built-in functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (<samp><span class="option">-mcpu=power9</span></samp>):
<pre class="smallexample">     long long __builtin_darn (void);
     long long __builtin_darn_raw (void);
     int __builtin_darn_32 (void);
     
     int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_lt_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_lt_td (unsigned int comparison, _Decimal128 value);
     
     int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_gt_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_gt_td (unsigned int comparison, _Decimal128 value);
     
     int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_eq_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_eq_td (unsigned int comparison, _Decimal128 value);
     
     int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);
</pre>
 <p>The <code>__builtin_darn</code> and <code>__builtin_darn_raw</code>
functions require a
64-bit environment supporting ISA 3.0 or later. 
The <code>__builtin_darn</code> function provides a 64-bit conditioned
random number.  The <code>__builtin_darn_raw</code> function provides a
64-bit raw random number.  The <code>__builtin_darn_32</code> function
provides a 32-bit random number.

 <p>The <code>__builtin_dfp_dtstsfi_lt</code> function returns a non-zero value
if and only if the number of signficant digits of its <code>value</code> argument
is less than its <code>comparison</code> argument.  The
<code>__builtin_dfp_dtstsfi_lt_dd</code> and
<code>__builtin_dfp_dtstsfi_lt_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The <code>__builtin_dfp_dtstsfi_gt</code> function returns a non-zero value
if and only if the number of signficant digits of its <code>value</code> argument
is greater than its <code>comparison</code> argument.  The
<code>__builtin_dfp_dtstsfi_gt_dd</code> and
<code>__builtin_dfp_dtstsfi_gt_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The <code>__builtin_dfp_dtstsfi_eq</code> function returns a non-zero value
if and only if the number of signficant digits of its <code>value</code> argument
equals its <code>comparison</code> argument.  The
<code>__builtin_dfp_dtstsfi_eq_dd</code> and
<code>__builtin_dfp_dtstsfi_eq_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The <code>__builtin_dfp_dtstsfi_ov</code> function returns a non-zero value
if and only if its <code>value</code> argument has an undefined number of
significant digits, such as when <code>value</code> is an encoding of <code>NaN</code>. 
The <code>__builtin_dfp_dtstsfi_ov_dd</code> and
<code>__builtin_dfp_dtstsfi_ov_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The following built-in functions are available for the PowerPC family
of processors when hardware decimal floating point
(<samp><span class="option">-mhard-dfp</span></samp>) is available:
<pre class="smallexample">     _Decimal64 __builtin_dxex (_Decimal64);
     _Decimal128 __builtin_dxexq (_Decimal128);
     _Decimal64 __builtin_ddedpd (int, _Decimal64);
     _Decimal128 __builtin_ddedpdq (int, _Decimal128);
     _Decimal64 __builtin_denbcd (int, _Decimal64);
     _Decimal128 __builtin_denbcdq (int, _Decimal128);
     _Decimal64 __builtin_diex (_Decimal64, _Decimal64);
     _Decimal128 _builtin_diexq (_Decimal128, _Decimal128);
     _Decimal64 __builtin_dscli (_Decimal64, int);
     _Decimal128 __builtin_dscliq (_Decimal128, int);
     _Decimal64 __builtin_dscri (_Decimal64, int);
     _Decimal128 __builtin_dscriq (_Decimal128, int);
     unsigned long long __builtin_unpack_dec128 (_Decimal128, int);
     _Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);
</pre>
 <p>The following built-in functions are available for the PowerPC family
of processors when the Vector Scalar (vsx) instruction set is
available:
<pre class="smallexample">     unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);
     vector __int128_t __builtin_pack_vector_int128 (unsigned long long,
                                                     unsigned long long);
</pre>
 </body></html>

