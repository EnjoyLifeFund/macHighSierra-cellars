#!/bin/bash
# gnome-doc-html - Convert documentation to HTML
# gnome-doc-html.  Generated from gnome-doc-html.in by configure.
# Copyright (C) 2006 Shaun McCance <shaunm@gnome.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

progname=`echo "$0" | sed 's%^.*/%%'`

PROGRAM=gnome-doc-html
PACKAGE=gnome-doc-utils
VERSION=0.20.10
prefix=/usr/local/Cellar/gnome-doc-utils/0.20.10
datarootdir=${prefix}/share
datadir=${datarootdir}
pkgdatadir=${datarootdir}/gnome-doc-utils
xsltdir=${datarootdir}/xml/gnome/xslt

# This is important to make sure string manipulation is handled
# byte-by-byte.
export LANG=C

XSL_ICONS='
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:mal="http://projectmallard.org/1.0/"
  version="1.0">
<xsl:import href="'$xsltdir'/gettext/gettext.xsl"/>
<xsl:output method="text" encoding="utf-8"/>
<xsl:template match="*">
  <xsl:apply-templates/>
</xsl:template>
<xsl:template match="text()"/>
<xsl:template match="caution">
  <xsl:text>admon-caution&#x000A;</xsl:text>
</xsl:template>
<xsl:template match="important">
  <xsl:text>admon-important&#x000A;</xsl:text>
</xsl:template>
<xsl:template match="note">
  <xsl:choose>
    <xsl:when test="@role='\''bug'\''">
      <xsl:text>admon-bug&#x000A;</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>admon-note&#x000A;</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template match="tip">
  <xsl:text>admon-tip&#x000A;</xsl:text>
</xsl:template>
<xsl:template match="warning">
  <xsl:text>admon-warning&#x000A;</xsl:text>
</xsl:template>
<xsl:template match="mal:note">
  <xsl:choose>
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''advanced'\'')">
      <xsl:text>admon-important&#x000A;</xsl:text>
    </xsl:when>
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''bug'\'')">
      <xsl:text>admon-bug&#x000A;</xsl:text>
    </xsl:when>
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''important'\'')">
      <xsl:text>admon-important&#x000A;</xsl:text>
    </xsl:when>
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''tip'\'')">
      <xsl:text>admon-tip&#x000A;</xsl:text>
    </xsl:when>
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''warning'\'')">
      <xsl:text>admon-warning&#x000A;</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>admon-note&#x000A;</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template match="/FALSE">
  <xsl:if test="//blockquote[1]">
    <xsl:call-template name="l10n.gettext">
      <xsl:with-param name="msgid" select="'\''blockquote-watermark-201C'\''"/>
    </xsl:call-template>
    <xsl:text>&#x000A;</xsl:text>
  </xsl:if>
  <xsl:if test="//classsynopsis[@language = '"'"'cpp'"'"'][1] or //programlisting[@language = '"'"'cpp'"'"']">
    <xsl:text>watermark-code-cpp&#x000A;</xsl:text>
  </xsl:if>
  <xsl:if test="//classsynopsis[@language = '"'"'python'"'"'][1] or //programlisting[@language = '"'"'python'"'"']">
    <xsl:text>watermark-code-python&#x000A;</xsl:text>
  </xsl:if>
</xsl:template>
</xsl:stylesheet>'

XSL_CACHE_LS='
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:cache="http://projectmallard.org/cache/1.0/"
  xmlns:mal="http://projectmallard.org/1.0/"
  version="1.0">
<xsl:output method="text"/>
<xsl:template match="/">
  <xsl:for-each select="cache:cache/mal:page">
    <xsl:value-of select="@cache:href"/>
    <xsl:text>&#x000A;</xsl:text>
  </xsl:for-each>
</xsl:template>
</xsl:stylesheet>'

XSL_DOCBOOK_MEDIA='
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0">
<xsl:output method="text" encoding="utf-8"/>
<xsl:template match="/">
  <xsl:for-each select="//audiodata|//imagedata|//videodata">
    <xsl:choose>
      <xsl:when test="@fileref">
        <xsl:value-of select="@fileref"/>
      </xsl:when>
      <xsl:when test="@entityref">
        <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
      </xsl:when>
    </xsl:choose>
    <xsl:text>&#x000A;</xsl:text>
  </xsl:for-each>
</xsl:template>
</xsl:stylesheet>'

XSL_MALLARD_CSS='
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:mal="http://projectmallard.org/1.0/"
  version="1.0">
<xsl:import href="'$xsltdir'/gettext/gettext.xsl"/>
<xsl:import href="'$xsltdir'/common/theme.xsl"/>
<xsl:import href="'$xsltdir'/mallard/html/mal2html-css.xsl"/>
<xsl:output method="text"/>
<xsl:template match="/">
<xsl:call-template name="mal2html.css.content"/>
</xsl:template>
</xsl:stylesheet>'

XSL_MALLARD_MEDIA='
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:mal="http://projectmallard.org/1.0/"
  version="1.0">
<xsl:output method="text" encoding="utf-8"/>
<xsl:template match="/">
  <xsl:for-each select="//mal:media">
    <xsl:value-of select="@src"/>
    <xsl:text>&#x000A;</xsl:text>
  </xsl:for-each>
</xsl:template>
</xsl:stylesheet>'

error() {
    echo "$progname: $1" 1>&2;
    exit 1;
}

print_help() {
    cat <<EOF
Usage: $progname <COMMAND> [OPTIONS] FILES...
Process a documentation file.

COMMAND is one of:
  list-icons   list automatic icons and watermarks
  list-media   list all referenced media files
  html         convert the documents to HTML
  xhtml        convert the documents to XHTML
  css          create a CSS file for a Mallard document
  help         display this help and exit
EOF
}

print_help_css() {
cat <<EOF
Usage $progname css [OPTIONS] [FILE]
Create a CSS file for a Mallard document.
If FILE is not supplied, uses index.page as input.

CSS Options:
  -o, --output=PATH               the file to output to

Miscellaneous:
  -v, --verbose                   print all the commands executed
  -V, --version                   print version information and exit
  -h, --help                      display this help and exit
EOF
}

print_help_html() {
    format="$1"
    upformat=`echo $format | tr a-z A-Z`
    cat <<EOF
Usage: $progname $format [OPTIONS] FILE
Convert FILE into $upformat.

Basic Output Control:
  -c, --css-file=FILE             file to output CSS to
  -e, --extension=EXT             the extension to append to output files
  -n, --no-figures                do not copy figures into the output directory
  -o, --output=PATH               the file or directory to output to
  -x, --custom-xslt=PATH          custom XSLT to include in the transform
                                  (currently only for Mallard)

Automatic Graphics:
  --copy-graphics                 copy graphics into the output directory
  --admon-graphics-path=PATH      the path to the admonition graphics
  --admon-graphics-size=INT       the size of the admonition graphics

Docbook Chunking:
  -d, --chunk-depth=INT           how deep sections should be chunked

DocBook Styling:
  --classsynopsis-language=LANG   the default programming language to be used
                                  for classsynopsis elements
  --funcsynopsis-style=STYLE      the style to be used to render funcsynopsis
                                  elements, either 'KR' or 'ANSI'

Miscellaneous:
  -v, --verbose                   print all the commands executed
  -V, --version                   print version information and exit
  -h, --help                      display this help and exit
EOF
}

echo_verbose() {
    if [ "x$doc_verbose" = "x1" ]; then echo $1; fi
}

mkdir_p() {
    __dir__='';
    echo $1 | sed -e 's/\//\n/g' | while read d; do
	__dir__="$__dir__$d/"
	if [ ! -d "$__dir__" ]; then
	    echo_verbose "mkdir \"$__dir__\""
	    mkdir "$__dir__" || error "Could not create directory"
	fi
    done || exit 1;
}

urlencode() {
    arg="$1"
    i="0"
    while [ "$i" -lt ${#arg} ]; do
	c=${arg:$i:1}
	if echo "$c" | grep -q '[a-zA-Z/:_\.\-]'; then
	    echo -n "$c"
	else
	    echo -n "%"
	    printf "%X" "'$c'"
	fi
	i=$((i+1))
    done
}

urldecode() {
    arg="$1"
    i="0"
    while [ "$i" -lt ${#arg} ]; do
	c0=${arg:$i:1}
	if [ "x$c0" = "x%" ]; then
	    c1=${arg:$((i+1)):1}
	    c2=${arg:$((i+2)):1}
	    printf "\x$c1$c2"
	    i=$((i+3))
	else
	    echo -n "$c0"
	    i=$((i+1))
	fi
    done
}

copy_icons() {
    if [ "x$doc_copy_icons" = "x1" ]; then
	if [ "x$doc_icons_admon_path" = "x" ]; then
	    p="$pkgdatadir/icons/hicolor/"
	    if [ "x$doc_icons_admon_size" != "x" ]; then
		doc_icons_admon_path="${p}${doc_icons_admon_size}x${doc_icons_admon_size}/status"
	    else
		doc_icons_admon_path="${p}48x48/status"
	    fi
	    unset p
	fi
	for doc_icon in $(echo $doc_icons_to_copy | tr ' ' '\n' | grep '^admon-' | sort | uniq); do
	    doc_icon_file="${doc_icon}.png"
	    cmd="cp \"$doc_icons_admon_path/$doc_icon_file\" \"$doc_outdir/$doc_icon_file\""
	    echo_verbose "$cmd"
	    eval "$cmd"
	done
    fi
}

list_icons() {
    while [ "$#" != "0" ]; do
	if [ -d "$1" ]; then
	    list_icons "$1/"*.page
	else
	    echo "$XSL_ICONS" | xsltproc --nonet --xinclude - "$1"
	fi
	shift
    done | sort | uniq
}

list_media() {
    if [ "x$(echo "$1" | sed -e 's/.*\.//')" = "xpage" -o -d "$1" ]; then
	XSL_MEDIA="$XSL_MALLARD_MEDIA"
    else
	XSL_MEDIA="$XSL_DOCBOOK_MEDIA"
    fi
    while [ "$#" != "0" ]; do
	if [ -d "$1" ]; then
	    list_media "$1/"*.page
	else
	    doc_indir=$(dirname "$1")
	    if [ "$doc_indir" = "." ]; then
		doc_indir=""
	    else
		doc_indir="$doc_indir/"
	    fi
	    echo "$XSL_MEDIA" | xsltproc --nonet --xinclude - "$1" \
		| while read doc_media; do
		echo "$doc_indir$doc_media"
	    done
	fi
	shift
    done | sort | uniq
}

convert_docbook2html() {
    if [ "x$doc_extension" = "x" ]; then doc_extension=".$doc_format"; fi
    if [ "x$doc_output" = "x" ]; then
	doc_outdir=`pwd`
    elif [ -d "$doc_output" -o $(echo "$doc_output" | sed -e 's/.*\/$/\//') = "/" ]; then
	mkdir_p "$doc_output"
	doc_outdir=`(cd "$doc_output" && pwd)`
    else
	if [ "$#" != "1" ]; then
	    error "With multiple input files, output must be a directory"
	fi
	dir=`dirname "$doc_output"`
	mkdir_p "$dir"
	doc_outdir=`(cd "$dir" && pwd)`
	doc_outfile=`basename "$doc_output"`
	doc_outfile_q="1"
	if [ "x$doc_extension" = "x" ]; then
	    doc_extension=`echo "$doc_outfile" | grep -o '\..*'`
	fi;
    fi;
    while [ "$#" != "0" ]; do
	doc_input="$1"
	shift

	if [ ! -f "$doc_input" ]; then error "$doc_input: No such file"; fi
	doc_indir=$( (cd $(dirname "$doc_input") && pwd) )
	doc_infile=$(basename "$doc_input")
	doc_inbase=$(basename "$doc_infile" ".xml")
	if [ "$doc_inbase" = "$doc_infile" ]; then
	    doc_inbase=$(basename "$doc_infile" ".docbook")
	fi;

	if [ "x$doc_outfile_q" != "x1" ]; then
	    doc_outfile="${doc_inbase}${doc_extension}"
	fi
	doc_outbase=$(basename "$doc_outfile" "$doc_extension")

	params='--param db.chunk.chunk_top 0'
	params="$params --stringparam db.chunk.basename \"$doc_outbase\""
	params="$params --stringparam db.chunk.extension \"$doc_extension\""
	if [ "x$doc_chunk_depth" != "x" ]; then
	    params="$params --param db.chunk.max_depth $doc_chunk_depth"
	fi
	if [ "x$doc_css_file" != "x" ]; then
	    params="$params --stringparam db2html.css.file \"$doc_css_file\""
	fi

	if [ "x$doc_copy_icons" = "x1" ]; then
	    doc_icons=$(list_icons "$doc_indir/$doc_infile")
	    doc_icons_to_copy="$doc_icons $doc_icons_to_copy"
	    for doc_icon in $(echo $doc_icons | tr ' ' '\n' | grep '^admon-' | sort | uniq); do
		param="theme.icon."$(echo $doc_icon | sed -e 's/-/./');
		params="$params --stringparam $param \"$doc_icon\""
	    done
	fi
	if [ "x$doc_copy_icons" != "x1" -a "x$doc_icons_path" != "x" ]; then
	    params="$params --stringparam theme.icon.admon.path \"$doc_icons_admon_path\""
	fi
	if [ "x$doc_admon_graphics_size" != "x" ]; then
	    params="$params --stringparam theme.icon.admon.size \"$doc_icons_admon_size\""
	fi
	if [ "x$doc_classsynopsis_language" != "x" ]; then
	    params="$params --stringparam db2html.classsynopsis.language"
	    params="$params \"$doc_classsynopsis_language\""
	fi
	if [ "x$doc_funcsynopsis_style" != "x" ]; then
	    params="$params --stringparam db2html.funcsynopsis.style"
	    params="$params \"$doc_funcsynopsis_style\""
	fi

	cmd="xmllint --nonet --xinclude \"$doc_indir/$doc_infile\" |\
          xsltproc $params -o \"$doc_outdir/$doc_outfile\" \"$xsltdir/docbook/html/db2$doc_format.xsl\" -"
	echo_verbose "$cmd"
	eval "$cmd"
	exit 0

	if [ "x$doc_no_figures" != "x1" -a "$doc_indir" != "$doc_outdir" ]; then
	    echo "$XSL_DOCBOOK_MEDIA" \
		| xsltproc --nonet --xinclude - "$doc_indir/$doc_infile" \
		| while read doc_media; do
		mkdir_p "$doc_outdir/"`dirname "$fig"`
		cmd="cp \"$doc_indir/$fig\" \"$doc_outdir/$fig\""
		echo_verbose "$cmd"
		eval "$cmd"
	    done
	fi
    done
    copy_icons
}

convert_mallard2html() {
    if [ "x$doc_extension" = "x" ]; then doc_extension=".$doc_format"; fi
    if [ "x$doc_output" = "x" ]; then
	doc_outdir=`pwd`
    elif [ -d "$doc_output" -o $(echo "$doc_output" | sed -e 's/.*\/$/\//') = "/" ]; then
	mkdir_p "$doc_output"
	doc_outdir=`(cd "$doc_output" && pwd)`
    else
	if [ "$#" != "1" -o -d "$1" ]; then
	    error "With multiple input files, output must be a directory"
	fi
	dir=`dirname "$doc_output"`
	mkdir_p "$dir"
	doc_outdir=`(cd "$dir" && pwd)`
	doc_outfile=`basename "$doc_output"`
	doc_outfile_q="1"
	if [ "x$doc_extension" = "x" ]; then
	    doc_extension=`echo "$doc_outfile" | grep -o '\..*'`
	fi;
    fi;
    doc_cache_in="$doc_outdir/index.cache.in"
    doc_cache="$doc_outdir/index.cache"
    doc_tmpfiles="$doc_tmpfiles doc_cache_in doc_cache_out"
    (
	echo '<cache:cache xmlns:cache="http://projectmallard.org/cache/1.0/"'
	echo '             xmlns="http://projectmallard.org/1.0/">'
	while [ "$#" != "0" ]; do
	    doc_input="$1"
	    shift
	    if [ -d "$doc_input" ]; then
		doc_input_full=$(cd "$doc_input" && pwd)
		for doc_input_file in "$doc_input_full/"*.page; do
		    echo "$doc_input_file"
		done
		unset doc_input_full
	    else
		echo "$(pwd)/$doc_input"
	    fi
	done | while read doc_input; do
	    doc_input_esc=$(urlencode "$doc_input" | sed -e 's/\&/\&amp;/g' -e 's/</\&lt;/g' -e "s/'/\&apos;/g")
	    echo "<page cache:href='file://$doc_input_esc'/>"
	done
	echo '</cache:cache>'
    ) > "$doc_cache_in"
    xsltproc -o "$doc_cache" "$xsltdir/mallard/cache/mal-cache.xsl" "$doc_cache_in"
    rm "$doc_cache_in"
    echo "$XSL_CACHE_LS" | xsltproc - "$doc_cache" | while read doc_input; do
	doc_input=$(urldecode $(echo "$doc_input" | sed -e 's/^file:\/\///'))
	doc_indir=$( (cd $(dirname "$doc_input") && pwd) )
	doc_infile=$(basename "$doc_input")
	doc_inbase=$(basename "$doc_infile" ".page")

	if [ "x$doc_outfile_q" != "x1" ]; then
	    doc_outfile="${doc_inbase}${doc_extension}"
	fi

	params='--param mal.chunk.chunk_top 0'
	params="$params --stringparam mal.cache.file \"$doc_cache\""

	if [ "x$doc_css_file" != "x" ]; then
	    params="$params --stringparam mal2html.css.file \"$doc_css_file\""
	fi

	if [ "x$doc_copy_icons" = "x1" ]; then
	    doc_icons=$(list_icons "$doc_indir/$doc_infile")
	    doc_icons_to_copy="$doc_icons $doc_icons_to_copy"
	    for doc_icon in $(echo $doc_icons | tr ' ' '\n' | grep '^admon-' | sort | uniq); do
		param="theme.icon."$(echo $doc_icon | sed -e 's/-/./');
		params="$params --stringparam $param \"$doc_icon\""
	    done
	fi
	if [ "x$doc_copy_icons" != "x1" -a "x$doc_icons_path" != "x" ]; then
	    params="$params --stringparam theme.icon.admon.path \"$doc_icons_admon_path\""
	fi
	if [ "x$doc_admon_graphics_size" != "x" ]; then
	    params="$params --stringparam theme.icon.admon.size \"$doc_icons_admon_size\""
	fi

	if [ "x$doc_custom_xslt" != "x" ]; then
	    cmd="echo '<stylesheet xmlns=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\
                       <import href=\"$xsltdir/mallard/html/mal2$doc_format.xsl\"/>\
                       <include href=\"$doc_custom_xslt\"/></stylesheet>' |\
                 xsltproc --nonet --xinclude $params -o \"$doc_outdir/$doc_outfile\"\
                 - \"$doc_indir/$doc_infile\""
	else
	    cmd="xsltproc --nonet --xinclude $params -o \"$doc_outdir/$doc_outfile\"\
                 \"$xsltdir/mallard/html/mal2$doc_format.xsl\" \"$doc_indir/$doc_infile\""
	fi
	echo_verbose "$cmd"
	eval "$cmd"

	if [ "x$doc_no_figures" != "x1" -a "$doc_indir" != "$doc_outdir" ]; then
	    echo "$XSL_MALLARD_MEDIA" \
		| xsltproc --nonet --xinclude - "$doc_indir/$doc_infile" \
		| while read doc_media; do
		mkdir_p "$doc_outdir/"`dirname "$doc_media"`
		cmd="cp \"$doc_indir/$doc_media\" \"$doc_outdir/$doc_media\""
		echo_verbose "$cmd"
		eval "$cmd"
	    done
	fi
    done
    copy_icons
}

create_css() {
    longopts='
      -loutput:
      -lverbose
      -lversion
      -lhelp
    ';
    options=`getopt -qn$progname $longopts -- o:vVh "$@"`
    if [ "$?" != "0" ]; then print_help_css 1>&2; exit 1; fi
    eval set -- "$options";
    while [ "$1" != "--" ]; do
	case "$1" in
	    -o | --output)
		doc_output="$2";;

	    -v | --verbose)
		doc_verbose=1;;

	    -V | --version)
		echo "$PROGRAM ($PACKAGE) $VERSION"
		exit 0;;
	    -h | --help)
		print_help_css
		exit 0;;
	    --)
		print_help_css 1>&2
		exit 1;;
	esac
	shift
    done
    shift

    doc_input_page="$1"
    if [ "x$doc_input_page" = "x" ]; then
	doc_input_page="index.page"
    fi
    if [ "x$doc_output" = "x" ]; then
	doc_output="index.css"
    fi

    echo_verbose "Creating $doc_output using $doc_input_page"
    echo "$XSL_MALLARD_CSS" | xsltproc -o "$doc_output" - "$doc_input_page";
}

convert_2html() {
    doc_format="$1"
    shift
    longopts='
      -lcss-file:
      -lchunk-depth:
      -lextension:
      -lno-figures
      -loutput:
      -lcustom-xslt:
      -lcopy-graphics
      -ladmon-graphics-path:
      -ladmon-graphics-size:
      -lclasssynopsis-language:
      -lfuncsynopsis-style:
      -lverbose
      -lversion
      -lhelp
    ';
    options=`getopt -qn$progname $longopts -- c:d:e:o:x:nvVh "$@"`
    if [ "$?" != "0" ]; then print_help_html $doc_format 1>&2; exit 1; fi
    eval set -- "$options";
    while [ "$1" != "--" ]; do
	case "$1" in
	    -c | --css-file)
		doc_css_file="$2";;
	    -d | --chunk-depth)
		doc_chunk_depth="$2";;
	    -e | --extension)
		doc_extension="$2";;
	    -n | --no-figures)
		doc_no_figures="1";;
	    -o | --output)
		doc_output="$2";;
	    -x | --custom-xslt)
		doc_custom_xslt="$2";;

	    --copy-graphics)
		doc_copy_icons="1";;
	    --admon-graphics-path)
		doc_icons_admon_path="$2";;
	    --admon-graphics-size)
		doc_icons_admon_size="$2";;
	    --classsynopsis-language)
		doc_classsynopsis_language="$2";;
	    --funcsynopsis-style)
		doc_funcsynopsis_style="$2";;

	    -v | --verbose)
		doc_verbose=1;;

	    -V | --version)
		echo "$PROGRAM ($PACKAGE) $VERSION"
		exit 0;;
	    -h | --help)
		print_help_html $doc_format
		exit 0;;
	    --)
		print_help_html $doc_format 1>&2
		exit 1;;
	esac
	shift
    done
    shift

    if [ "$#" = "0" ]; then print_help_html $doc_format 1>&2; exit 1; fi
    if [ "x$(echo "$1" | sed -e 's/.*\.//')" = "xpage" -o -d "$1" ]; then
	convert_mallard2html $@;
    else
	convert_docbook2html $@;
    fi
    exit 0
}


command="$1";
if [ "x$command" = "x" ]; then
    print_help 1>&2;
    exit 1;
fi;
shift;
if [ "$command" = "html" -o "$command" = "xhtml" ]; then
    convert_2html "$command" $@;
elif [ "$command" = "css" ]; then
    create_css $@;
elif [ "$command" = "list-icons" ]; then
    list_icons $@;
elif [ "$command" = "list-media" ]; then
    list_media $@;
elif [ "$command" = "-V" -o "$command" = "--version" ]; then
    echo "$PROGRAM ($PACKAGE) $VERSION";
    exit 0;
elif [ "$command" = "help" ]; then
    print_help;
    exit 0;
else
    print_help 1>&2;
    exit 1;
fi;

