'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _httpCall = require('http-call');

var _httpCall2 = _interopRequireDefault(_httpCall);

var _cliEngineConfig = require('cli-engine-config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mergeRequestOptions(...options) {
  let output = { method: 'GET', headers: {} };
  for (let o of options) {
    let headers = Object.assign(output.headers, o.headers);
    Object.assign(output, o);
    output.headers = headers;
  }
  return output;
}

function renderHeaders(headers) {
  return Object.keys(headers).map(key => {
    let value = key.toUpperCase() === 'AUTHORIZATION' ? 'REDACTED' : headers[key];
    return '    ' + key + '=' + value;
  }).join('\n');
}

class HTTP {

  constructor(output, config) {
    let self = this;
    this.out = output;
    this.config = (0, _cliEngineConfig.buildConfig)(config || this.out.config);
    this.requestOptions = mergeRequestOptions({
      headers: {
        'user-agent': `${this.config.name}/${this.config.version} (${this.config.platform}-${this.config.arch}) node-${process.version}`
      }
    });
    this.http = class extends _httpCall2.default {
      async _request(...args) {
        self._logRequest(this);
        await super._request(...args);
        self._logResponse(this);
      }
    };
  }

  get(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.get(url, options);
  }

  post(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.post(url, options);
  }

  put(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.put(url, options);
  }

  patch(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.patch(url, options);
  }

  delete(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.delete(url, options);
  }

  stream(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.stream(url, options);
  }

  request(url, options = {}) {
    options = mergeRequestOptions(this.requestOptions, options);
    return this.http.request(url, options);
  }

  get _debugHeaders() {
    if (this.out.config.debug > 1) return true;
    const HEROKU_DEBUG_HEADERS = process.env.HEROKU_DEBUG_HEADERS;
    return HEROKU_DEBUG_HEADERS === 'true' || HEROKU_DEBUG_HEADERS === '1';
  }

  _logRequest(http) {
    if (!this.out.config.debug) return;
    this.out.stderr.log(`--> ${http.method} ${http.url}`);
    if (this._debugHeaders) {
      this.out.stderr.log(renderHeaders(http.headers));
    }
    // TODO: conditionally add displaying of POST body
    // if (body) this.error(`--- BODY\n${util.inspect(body)}\n---`)
  }

  _logResponse(http) {
    if (!this.out.config.debug) return;
    this.out.stderr.log(`<-- ${http.method} ${http.url} ${http.response.statusCode}`);
    if (this.out.config.debug > 1) {
      this.out.stderr.log(renderHeaders(http.response.headers));
      if (http.body) this.out.stderr.log(`--- BODY\n${_util2.default.inspect(http.body)}\n---`);
    }
  }
}
exports.default = HTTP;