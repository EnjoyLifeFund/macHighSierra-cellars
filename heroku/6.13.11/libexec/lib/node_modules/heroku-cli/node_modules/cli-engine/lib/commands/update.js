'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _updater = require('../updater');

var _updater2 = _interopRequireDefault(_updater);

var _update = require('./plugins/update');

var _update2 = _interopRequireDefault(_update);

var _plugins = require('../plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _analytics = require('../analytics');

var _analytics2 = _interopRequireDefault(_analytics);

var _autocomplete = require('../autocomplete');

var _autocomplete2 = _interopRequireDefault(_autocomplete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli-engine:update');

class Update extends _cliEngineCommand2.default {

  async run() {
    // on manual run, also log to file
    if (!this.flags.autoupdate) {
      this.out.stdout.logfile = this.out.autoupdatelog;
      this.out.stderr.logfile = this.out.autoupdatelog;
    }
    this.updater = new _updater2.default(this.out);
    if (this.config.updateDisabled) this.out.warn(this.config.updateDisabled);else {
      this.out.action.start(`${this.config.name}: Updating CLI`);
      let channel = this.argv[0] || this.config.channel;
      let manifest = await this.updater.fetchManifest(channel);
      if (this.config.version === manifest.version && channel === this.config.channel) {
        this.out.action.stop(`already on latest version: ${this.config.version}`);
      } else {
        let { yellow, green } = this.out.color;
        this.out.action.start(`${this.config.name}: Updating CLI from ${green(this.config.version)} to ${green(manifest.version)}${channel === 'stable' ? '' : ' (' + yellow(channel) + ')'}`);
        await this.updater.update(manifest);
        this.out.action.stop();
        try {
          await this.updater.autoupdate(true);
          this.out.exit(0);
        } catch (err) {
          this.out.warn(err, 'post-install autoupdate failed');
        }
      }
    }
    debug('fetch version');
    await this.updater.fetchVersion(this.config.channel, true);
    debug('analytics');
    let analytics = new _analytics2.default({ out: this.out, config: this.config });
    await analytics.submit();
    debug('plugins update');
    await _update2.default.run({ config: this.config, output: this.out });
    debug('log chop');
    await this.logChop();
    debug('autocomplete');
    if (this.config.windows) {
      debug('skipping autocomplete on windows');
    } else {
      const plugins = await new _plugins2.default(this.out).list();
      const acPlugin = plugins.find(p => p.name === 'heroku-cli-autocomplete');
      if (acPlugin) {
        let ac = new _autocomplete2.default(this);
        await ac.createCaches();
      } else {
        debug('skipping autocomplete, not installed');
      }
    }
    debug('done');
  }

  async logChop() {
    try {
      const logChopper = require('log-chopper').default;
      await logChopper.chop(this.out.errlog);
    } catch (e) {
      this.out.debug(e.message);
    }
  }
}
exports.default = Update;
Update.topic = 'update';
Update.description = 'update the Heroku CLI';
Update.args = [{ name: 'channel', optional: true }];
Update.flags = {
  autoupdate: _cliEngineCommand.flags.boolean({ hidden: true })
};