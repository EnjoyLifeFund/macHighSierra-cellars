'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTTPError = undefined;

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _package = require('../package.json');

var _package2 = _interopRequireDefault(_package);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _proxy = require('./proxy');

var _proxy2 = _interopRequireDefault(_proxy);

var _isStream = require('is-stream');

var _isStream2 = _interopRequireDefault(_isStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('http-call');

function concat(stream) {
  return new Promise(resolve => {
    let strings = [];
    stream.on('data', data => strings.push(data));
    stream.on('end', () => resolve(strings.join('')));
  });
}

/**
 * @typedef {Object} HTTPRequestOptions
 * @property {Object.<string, string>} headers - request headers
 * @property {string} method - request method (GET/POST/etc)
 * @property {(string)} body - request body. Sets content-type to application/json and stringifies when object
 * @property {(boolean)} partial - do not make continuous requests while receiving a Next-Range header for GET requests
 * @property {(number)} port - port to use
 */


/**
 * Utility for simple HTTP calls
 * @class
 */
class HTTP {
  /**
   * make an http GET request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.get('https://google.com')
   * ```
   */
  static async get(url, options = {}) {
    options.method = 'GET';
    let http = await this.request(url, options);
    return this._getNextBody(http);
  }

  /**
   * make an http POST request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.post('https://google.com')
   * ```
   */
  static async post(url, options = {}) {
    options.method = 'POST';
    let http = await this.request(url, options);
    return http.body;
  }

  /**
   * make an http PUT request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.put('https://google.com')
   * ```
   */
  static async put(url, options = {}) {
    options.method = 'PUT';
    let http = await this.request(url, options);
    return http.body;
  }

  /**
   * make an http PATCH request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.patch('https://google.com')
   * ```
   */
  static async patch(url, options = {}) {
    options.method = 'PATCH';
    let http = await this.request(url, options);
    return http.body;
  }

  /**
   * make an http DELETE request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * await http.delete('https://google.com')
   * ```
   */
  static async delete(url, options = {}) {
    options.method = 'DELETE';
    let http = await this.request(url, options);
    return http.body;
  }

  /**
   * make a streaming request
   * @param {string} url - url or path to call
   * @param {HTTPRequestOptions} options
   * @returns {Promise}
   * @example
   * ```js
   * const http = require('http-call')
   * let rsp = await http.get('https://google.com')
   * rsp.on('data', console.log)
   * ```
   */
  static async stream(url, options = {}) {
    options.method = options.method || 'GET';
    options.raw = true;
    let http = await this.request(url, options);
    return http.response;
  }

  static async request(url, options = {}) {
    let http = new this(url, options);
    await http._request();
    return http;
  }

  constructor(url, options = {}) {
    this.method = 'GET';
    this.host = 'localhost';
    this.port = 0;
    this.protocol = 'https:';
    this.path = '/';
    this.raw = false;
    this.partial = false;
    this.headers = {
      'user-agent': `${_package2.default.name}/${_package2.default.version} node-${process.version}`
    };

    if (!url) throw new Error('no url provided');
    this.options = options;
    let headers = Object.assign(this.headers, options.headers);
    Object.assign(this, options);
    this.headers = headers;
    let u = _url2.default.parse(url);
    this.protocol = u.protocol || this.protocol;
    this.host = u.hostname || this.host;
    this.port = u.port || this.port || (this.protocol === 'https:' ? 443 : 80);
    this.path = u.path || this.path;
    if (options.body) this.parseBody(options.body);
    this.body = undefined;
    if (_proxy2.default.usingProxy) this.agent = _proxy2.default.agent(u);
  }

  async _request(retries = 0) {
    try {
      debug(`--> ${this.method} ${this.url}`);
      this.response = await this.performRequest();
      debug(`<-- ${this.method} ${this.url} ${this.response.statusCode}`);
    } catch (err) {
      return this.maybeRetry(err, retries);
    }
    if (this.response.statusCode >= 200 && this.response.statusCode < 300) {
      if (!this.raw) this.body = await this.parse(this.response);
    } else throw new HTTPError(this, (await this.parse(this.response)));
  }

  async maybeRetry(err, retries) {
    const allowed = err => {
      if (retries >= 5) return false;
      if (!err.code) return false;
      if (err.code === 'ENOTFOUND') return true;
      return require('is-retry-allowed')(err);
    };
    if (allowed(err)) {
      let noise = Math.random() * 100;
      await this._wait((1 << retries) * 1000 + noise);
      await this._request(retries + 1);
      return;
    }
    throw err;
  }

  get http() {
    return this.protocol === 'https:' ? _https2.default : _http2.default;
  }

  get url() {
    return `${this.protocol}//${this.host}${this.path}`;
  }

  performRequest() {
    return new Promise((resolve, reject) => {
      this.request = this.http.request(this, resolve);
      this.request.on('error', reject);
      if (_isStream2.default.readable(this.requestBody)) {
        this.requestBody.pipe(this.request);
      } else {
        this.request.end(this.requestBody);
      }
    });
  }

  async parse(response) {
    let body = await concat(response);
    return response.headers['content-type'] === 'application/json' ? JSON.parse(body) : body;
  }

  parseBody(body) {
    if (_isStream2.default.readable(body)) {
      this.requestBody = body;
      return;
    }
    if (!this.headers['Content-Type']) {
      this.headers['Content-Type'] = 'application/json';
    }

    if (this.headers['Content-Type'] === 'application/json') {
      this.requestBody = JSON.stringify(body);
    } else {
      this.requestBody = body;
    }
    this.headers['Content-Length'] = Buffer.byteLength(this.requestBody).toString();
  }

  static async _getNextBody(http) {
    if (http.partial || !http.response.headers['next-range'] || !(http.body instanceof Array)) return http.body;
    let opts = { headers: {} };
    opts = Object.assign(opts, http.options);
    opts.headers['range'] = http.response.headers['next-range'];
    let next = await this.get(http.url, opts);
    return http.body.concat(next);
  }

  _wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

exports.default = HTTP;
class HTTPError extends Error {

  constructor(http, body) {
    let message;
    if (typeof body === 'string' || typeof body.message === 'string') message = body.message || body;else message = _util2.default.inspect(body);
    super(`HTTP Error ${http.response.statusCode} for ${http.method} ${http.url}\n${message}`);
    this.__httpcall = true;
    this.statusCode = http.response.statusCode;
    this.http = http;
    this.body = body;
  }
}
exports.HTTPError = HTTPError;