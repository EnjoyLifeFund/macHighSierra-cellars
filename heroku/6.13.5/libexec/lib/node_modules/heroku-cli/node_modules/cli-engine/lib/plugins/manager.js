'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = exports.PluginPath = undefined;

require('cli-engine-config');

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _legacy = require('./legacy');

var _namespaces = require('../namespaces');

var _namespaces2 = _interopRequireDefault(_namespaces);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli-engine:plugins:manager');

class PluginPath {
  constructor(options) {
    this.out = options.output;
    this.path = options.path;
    this.type = options.type;
    this.tag = options.tag;

    this.config = this.out.config;
  }

  async convertToCached() {
    let plugin = await this.require();

    const getAliases = c => {
      let aliases = c.aliases || [];
      if (c.default) {
        this.out.warn(`default setting on ${c.topic} is deprecated`);
        aliases.push(c.topic);
      }
      return aliases;
    };

    if (!plugin.commands) throw new Error('no commands found');

    const commands = plugin.commands.map(c => ({
      id: c.command ? `${c.topic}:${c.command}` : c.topic,
      topic: c.topic,
      command: c.command,
      description: c.description,
      args: c.args,
      variableArgs: c.variableArgs,
      help: c.help,
      usage: c.usage,
      hidden: !!c.hidden,
      aliases: getAliases(c),
      flags: (0, _legacy.convertFlagsFromV5)(c.flags)
    }));
    const topics = (plugin.topics || (plugin.topic ? [plugin.topic] : [])).map(t => ({
      topic: t.topic || t.name || '',
      description: t.description,
      hidden: !!t.hidden
    }));

    for (let command of commands) {
      if (topics.find(t => t.topic === command.topic)) continue;
      topics.push({
        topic: command.topic,
        hidden: true
      });
    }

    const { name, version } = this.pjson();
    return { name, path: this.path, version, namespace: plugin.namespace, commands, topics };
  }

  undefaultTopic(t) {
    if (t.default) return t.default;
    return t;
  }

  undefaultCommand(c) {
    if (c.default && typeof c.default !== 'boolean') return c.default;
    return c;
  }

  async require() {
    let required;
    try {
      required = require(this.path);
    } catch (err) {
      if (await this.repair(err)) return this.require();else throw err;
    }
    let plugin = {
      topic: required.topic && this.undefaultTopic(required.topic),
      topics: required.topics && required.topics.map(this.undefaultTopic),
      commands: required.commands && required.commands.map(this.undefaultCommand),
      namespace: undefined
    };
    if (required.type === 'builtin' || /(\\|\/)(src|lib)(\\|\/)commands$/.test(this.path)) return plugin;
    let { namespace } = _namespaces2.default.metaData(this.path, this.config);
    if (namespace) plugin.namespace = namespace;
    return plugin;
  }

  pjson() {
    if (this.type === 'builtin') {
      return { name: 'builtin', version: this.config.version };
    }

    return require(_path2.default.join(this.path, 'package.json'));
  }

  async repair(err) {
    debug(err);
    return false;
  }
}

exports.PluginPath = PluginPath;
class Manager {

  constructor({ out, config, cache }) {
    this.out = out;
    this.config = config;
    this.cache = cache;
  }

  async list() {
    throw new Error('abstract method Manager.list');
  }

  async handleNodeVersionChange() {
    // user and linked will override
  }
}
exports.Manager = Manager;