'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _http = require('cli-engine-command/lib/http');

var _http2 = _interopRequireDefault(_http);

var _netrcParser = require('netrc-parser');

var _netrcParser2 = _interopRequireDefault(_netrcParser);

var _output = require('cli-engine-command/lib/output');

var _output2 = _interopRequireDefault(_output);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _plugins = require('./plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _vars = require('cli-engine-heroku/lib/vars');

var _vars2 = _interopRequireDefault(_vars);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class AnalyticsCommand {

  constructor(options) {
    this.out = options.out;
    this.plugins = options.plugins || new _plugins2.default(this.out);
    this.http = new _http2.default(this.out);
    this.config = options.config;
  }

  _initialAnalyticsJSON() {
    return {
      schema: 1,
      commands: []
    };
  }

  async record(id) {
    try {
      let plugin = await this.plugins.findPluginWithCommand(id);
      if (!plugin) {
        this.out.debug('no plugin found for analytics');
        return;
      }

      if (!this.user) return;

      let analyticsJSON = await this._readJSON();

      analyticsJSON.commands.push({
        command: id,
        version: this.config.version,
        plugin: plugin.name,
        plugin_version: plugin.version,
        os: this.config.platform,
        shell: this.config.shell,
        valid: true,
        language: 'node'
      });

      await this._writeJSON(analyticsJSON);
    } catch (err) {
      this.out.debug(err);
    }
  }

  async submit() {
    try {
      let user = this.user;
      if (!user) return;

      const local = await this._readJSON();
      if (local.commands.length === 0) return;

      const body = {
        schema: local.schema,
        commands: local.commands,
        user: user,
        install: this.config.install,
        cli: this.config.name
      };

      await this.http.post(this.url, { body });

      local.commands = [];
      await this._writeJSON(local);
    } catch (err) {
      this.out.debug(err);
      await this._writeJSON(this._initialAnalyticsJSON());
    }
  }

  get url() {
    return process.env['CLI_ENGINE_ANALYTICS_URL'] || 'https://cli-analytics.heroku.com/record';
  }

  get analyticsPath() {
    return _path2.default.join(this.config.cacheDir, 'analytics.json');
  }

  get usingHerokuAPIKey() {
    return !!(process.env['HEROKU_API_KEY'] && process.env['HEROKU_API_KEY'].length > 0);
  }

  get netrcLogin() {
    let netrc = new _netrcParser2.default();
    return netrc.machines[_vars2.default.apiHost].login;
  }

  get user() {
    if (this.config.skipAnalytics || this.usingHerokuAPIKey) return;
    return this.netrcLogin;
  }

  async _readJSON() {
    try {
      let analytics = await _fsExtra2.default.readJson(this.analyticsPath);
      analytics.commands = analytics.commands || [];
      return analytics;
    } catch (err) {
      if (err.code !== 'ENOENT') throw err;
      return this._initialAnalyticsJSON();
    }
  }

  async _writeJSON(analyticsJSON) {
    return _fsExtra2.default.outputJson(this.analyticsPath, analyticsJSON);
  }
}
exports.default = AnalyticsCommand;