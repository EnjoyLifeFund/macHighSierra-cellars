'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _util = require('../util');

var _screen = require('cli-engine-command/lib/output/screen');

var _plugins = require('../plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _lodash = require('lodash.uniqby');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trimToMaxLeft(n) {
  let max = parseInt(_screen.stdtermwidth * 0.6);
  return n > max ? max : n;
}

function trimCmd(s, max) {
  if (s.length <= max) return s;
  return `${s.slice(0, max - 1)}\u2026`;
}

function renderList(items) {
  const S = require('string');
  const max = require('lodash.maxby');

  let maxLeftLength = trimToMaxLeft(max(items, '[0].length')[0].length + 1);
  return items.map(i => {
    let left = ` ${i[0]}`;
    let right = i[1];
    if (!right) return left;
    left = `${S(trimCmd(left, maxLeftLength)).padRight(maxLeftLength)}`;
    right = linewrap(maxLeftLength + 2, right);
    return `${left}  ${right}`;
  }).join('\n');
}

function linewrap(length, s) {
  const linewrap = require('../linewrap');
  return linewrap(length, _screen.stdtermwidth, {
    skipScheme: 'ansi-color'
  })(s).trim();
}

class Help extends _cliEngineCommand2.default {

  async run() {
    this.plugins = new _plugins2.default(this.out);
    await this.plugins.load();
    let cmd = this.argv.find(arg => !['-h', '--help'].includes(arg));
    if (!cmd) {
      return this.topics();
    }

    const topic = await this.plugins.findTopic(cmd);
    const matchedCommand = await this.plugins.findCommand(cmd);
    const pluginsInNamespace = this.plugins.findNamespaced(cmd);

    if (!topic && !matchedCommand && !pluginsInNamespace.length) {
      throw new Error(`command ${cmd} not found`);
    }

    if (matchedCommand) {
      this.out.log(matchedCommand.buildHelp(this.config));
    }

    if (topic) {
      const cmds = await this.plugins.commandsForTopic(topic.topic);
      if (!(cmds.length === 1 && matchedCommand)) this.listCommandsHelp(cmd, cmds);
    }

    if (pluginsInNamespace.length) {
      this.listNamespaceHelp(cmd, pluginsInNamespace);
    }
  }

  topics() {
    let color = this.out.color;
    this.out.log(`${color.bold('Usage:')} ${this.config.bin} COMMAND

Help topics, type ${this.out.color.cmd(this.config.bin + ' help TOPIC')} for more details:\n`);
    let topics = this.plugins.topics.filter(t => !t.hidden).filter(t => !t.namespace);
    let ns = (0, _lodash2.default)(this.plugins.topics.map(t => t.namespace)).filter(t => t);
    topics = topics.map(t => [t.id, t.description ? this.out.color.dim(t.description) : null]).concat(ns.map(t => [t, this.out.color.dim(`topics for ${t}`)]));
    topics.sort();
    this.out.log(renderList(topics));
    this.out.log();
  }

  listNamespaceHelp(namespace, plugins) {
    this.out.log(`Usage: ${this.config.bin} ${namespace}:TOPIC\n`);
    for (var i = 0; i < plugins.length; i++) {
      let plugin = plugins[i];
      if (plugin.topics) {
        this.out.log(renderList(plugin.topics.filter(t => !t.hidden).map(t => [t.id, t.description ? this.out.color.dim(t.description) : null])));
      }
    }
    this.out.log();
  }

  listCommandsHelp(topic, commands) {
    commands = commands.filter(c => !c.hidden);
    if (commands.length === 0) return;
    commands.sort((0, _util.compare)('command'));
    let helpCmd = this.out.color.cmd(`${this.config.bin} help ${topic}:COMMAND`);
    this.out.log(`${this.config.bin} ${this.out.color.bold(topic)} commands: (get help with ${helpCmd})`);
    this.out.log(renderList(commands.map(c => c.buildHelpLine(this.config))));
    this.out.log();
  }
}
exports.default = Help;
Help.topic = 'help';
Help.description = 'display help';
Help.variableArgs = true;