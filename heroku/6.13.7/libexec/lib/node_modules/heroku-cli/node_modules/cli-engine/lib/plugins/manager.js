'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = exports.PluginPath = undefined;

require('cli-engine-config');

var _legacy = require('./legacy');

var _namespaces = require('../namespaces');

var _namespaces2 = _interopRequireDefault(_namespaces);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli-engine:plugins:manager');

function makeID(o) {
  return [o.namespace, o.topic || o.name, o.command].filter(s => s).join(':');
}

class PluginPath {
  constructor(options) {
    this.out = options.output;
    this.path = options.path;
    this.type = options.type;
    this.tag = options.tag;

    this.config = this.out.config;
  }

  async convertToCached() {
    let plugin = await this.require();

    const getAliases = c => {
      let aliases = c.aliases || [];
      if (c.default) {
        this.out.warn(`default setting on ${c.topic} is deprecated`);
        aliases.push(c.topic);
      }
      return aliases;
    };

    if (!plugin.commands) throw new Error('no commands found');

    const commands = plugin.commands.map(c => ({
      id: c.id,
      namespace: c.namespace,
      topic: c.topic,
      command: c.command,
      description: c.description,
      args: c.args,
      variableArgs: c.variableArgs,
      help: c.help,
      usage: c.usage,
      hidden: !!c.hidden,
      aliases: getAliases(c),
      flags: (0, _legacy.convertFlagsFromV5)(c.flags)
    }));
    const topics = (plugin.topics || (plugin.topic ? [plugin.topic] : [])).map(t => ({
      id: t.id,
      namespace: t.namespace,
      topic: t.topic || t.name || '',
      description: t.description,
      hidden: !!t.hidden
    }));

    for (let command of commands) {
      if (topics.find(t => t.topic === command.topic)) continue;
      let topic = {
        id: command.id,
        namespace: command.namespace,
        topic: command.topic,
        hidden: true
      };
      topics.push(topic);
    }

    const { name, version } = this.pjson();
    return { name, path: this.path, version, namespace: plugin.namespace, commands, topics };
  }

  undefaultTopic(t) {
    if (t.default) return t.default;
    return t;
  }

  undefaultCommand(c) {
    if (c.default && typeof c.default !== 'boolean') return c.default;
    return c;
  }

  addNamespace(p, namespace) {
    p.namespace = namespace;
    if (!p.id) p.id = makeID(p);
    return p;
  }

  addNamespaceToTopic(t, namespace) {
    t.namespace = namespace;
    if (!t.id) t.id = makeID(t);
    return t;
  }

  async require() {
    let required;
    try {
      required = require(this.path);
    } catch (err) {
      if (await this.repair(err)) return this.require();else throw err;
    }

    let namespace;
    if (required.type !== 'builtin' || !/(\\|\/)(src|lib)(\\|\/)commands$/.test(this.path)) {
      const nsMeta = _namespaces2.default.metaData(this.path, this.config);
      namespace = nsMeta.namespace;
    }

    let topic = required.topic && this.addNamespaceToTopic(this.undefaultTopic(required.topic), namespace);
    const topics = required.topics && required.topics.map(t => this.addNamespace(this.undefaultTopic(t), namespace));
    const commands = required.commands && required.commands.map(t => this.addNamespace(this.undefaultCommand(t), namespace));
    return { topic, topics, commands, namespace };
  }

  pjson() {
    if (this.type === 'builtin') {
      return { name: 'builtin', version: this.config.version };
    }

    return require(_path2.default.join(this.path, 'package.json'));
  }

  async repair(err) {
    debug(err);
    return false;
  }
}

exports.PluginPath = PluginPath;
class Manager {

  constructor({ out, config, cache }) {
    this.out = out;
    this.config = config;
    this.cache = cache;
  }

  async list() {
    throw new Error('abstract method Manager.list');
  }

  async handleNodeVersionChange() {
    // user and linked will override
  }
}
exports.Manager = Manager;