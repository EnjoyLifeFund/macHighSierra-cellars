'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('cli-engine-config');

var _rwlockfile = require('rwlockfile');

var _rwlockfile2 = _interopRequireDefault(_rwlockfile);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('cli-engine:lock');

class Lock {

  constructor(output) {
    this.out = output;
    this.config = output.config;
  }

  get updatelockfile() {
    return _path2.default.join(this.config.cacheDir, 'update.lock');
  }

  // get read lock
  async read() {
    debug('read()');
    return _rwlockfile2.default.read(this.updatelockfile);
  }

  async unread() {
    await _rwlockfile2.default.unread(this.updatelockfile);
  }

  async canRead() {
    debug('canRead()');
    let hasWriter = await _rwlockfile2.default.hasWriter(this.updatelockfile);
    return !hasWriter;
  }

  // upgrade to writer
  async upgrade() {
    debug('upgrading to writer lock');
    // take off reader
    await this.unread();

    // check for other readers
    if (await _rwlockfile2.default.hasReaders(this.updatelockfile)) {
      this.out.action.status = `Waiting for all commands to finish`;
    }

    // grab writer lock
    let unlock = await _rwlockfile2.default.write(this.updatelockfile);
    debug('upgraded to writer lock');

    // return downgrade function
    return async () => {
      debug('downgrading to reader lock');
      // turn back into reader when unlocking
      await unlock();
      return _rwlockfile2.default.read(this.updatelockfile);
    };
  }
}
exports.default = Lock;