'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('cli-engine-config');

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _plugin = require('./plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _linked = require('./linked');

var _linked2 = _interopRequireDefault(_linked);

var _user = require('./user');

var _user2 = _interopRequireDefault(_user);

var _builtin = require('./builtin');

var _builtin2 = _interopRequireDefault(_builtin);

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _lodash = require('lodash.uniqby');

var _lodash2 = _interopRequireDefault(_lodash);

var _cache = require('./cache');

var _cache2 = _interopRequireDefault(_cache);

var _namespaces = require('../namespaces');

var _namespaces2 = _interopRequireDefault(_namespaces);

var _lock = require('../lock');

var _lock2 = _interopRequireDefault(_lock);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Plugins {

  constructor(output) {
    this.out = output;
    this.config = output.config;
    this.cache = new _cache2.default(output);

    this.builtin = new _builtin2.default(this);
    this.linked = new _linked2.default(this);
    this.user = new _user2.default(this);
    this.core = new _core2.default(this);
    this.lock = new _lock2.default(this.out);
  }

  async load() {
    if (this.loaded) return;
    this.plugins = await this.cache.fetchManagers(this.linked, this.user, this.core, this.builtin);
    this.loaded = true;
  }

  get commands() {
    let commands = [];
    for (let plugin of this.plugins) {
      try {
        commands = commands.concat(plugin.commands);
      } catch (err) {
        this.out.warn(err, `error reading plugin ${plugin.name}`);
      }
    }
    return commands;
  }

  async list() {
    await this.load();
    return this.plugins;
  }

  isPluginInstalled(name) {
    return !!this.plugins.find(p => p.name === name);
  }

  async findPluginWithCommand(id) {
    for (let plugin of await this.list()) {
      if (await plugin.findCommand(id)) return plugin;
    }
  }

  async findCommand(id) {
    for (let plugin of this.plugins) {
      let c = await plugin.findCommand(id);
      if (c) return c;
    }
  }

  async commandsForTopic(topic) {
    let commands = this.plugins.reduce((t, p) => {
      try {
        return t.concat(p.commands.filter(c => c.topic === topic).map(c => p.findCommand(c.id)));
      } catch (err) {
        this.out.warn(err, `error reading plugin ${p.name}`);
        return t;
      }
    }, []);
    commands = await Promise.all(commands);
    return (0, _lodash2.default)(commands, 'id');
  }

  async findTopic(id) {
    if (!id) return;
    for (let plugin of this.plugins) {
      let t = await plugin.findTopic(id);
      if (t) return t;
    }
  }

  findNamespaced(namespace) {
    return this.plugins.filter(p => p.namespace === namespace);
  }

  async install(name, tag = 'latest') {
    let downgrade = await this.lock.upgrade();

    await this.load();
    if (this.plugins.find(p => p.name === name && p.tag === tag)) throw new Error(`Plugin ${name} is already installed`);

    let path = await this.user.install(name, tag);
    this.clearCache(path);
    await downgrade();
  }

  async update() {
    if (this.user.list().length === 0) return;
    this.out.action.start(`${this.config.name}: Updating plugins`);
    let downgrade = await this.lock.upgrade();
    await this.user.update();
    this.clearCache(...(await this.user.list()).map(p => p.path));
    await downgrade();
  }

  async uninstall(name) {
    await this.load();
    let plugin = this.plugins.filter(p => ['user', 'link'].includes(p.type)).find(p => p.name === name);
    if (!plugin) throw new Error(`${name} is not installed`);
    let downgrade = await this.lock.upgrade();
    switch (plugin.type) {
      case 'user':
        {
          if (!this.config.debug) this.out.action.start(`Uninstalling plugin ${name}`);
          await this.user.remove(name);
          break;
        }
      case 'link':
        {
          if (!this.config.debug) this.out.action.start(`Unlinking plugin ${name}`);
          this.linked.remove(plugin.path);
          break;
        }
    }
    this.clearCache(plugin.path);
    await downgrade();
    this.out.action.stop();
  }

  addPackageToPJSON(name, version = '*') {
    this.user.addPackageToPJSON(name, version);
  }

  async addLinkedPlugin(p) {
    let downgrade = await this.lock.upgrade();

    await this.load();
    _namespaces2.default.throwErrorIfNotPermitted(p, this.config);

    await this.linked.add(p);
    this.clearCache(p);
    await downgrade();
  }

  clearCache(...paths) {
    this.cache.deletePlugin(...paths);
  }

  get topics() {
    return (0, _lodash2.default)(this.plugins.reduce((t, p) => t.concat(p.topics), []), 'id');
  }
}
exports.default = Plugins;