# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ldns')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ldns')
    _ldns = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ldns', [dirname(__file__)])
        except ImportError:
            import _ldns
            return _ldns
        try:
            _mod = imp.load_module('_ldns', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ldns = swig_import_helper()
    del swig_import_helper
else:
    import _ldns
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


	#
	# Use and don't ignore DeprecationWarning and
	# PendingDeprecationWarning.
	#
import warnings
warnings.filterwarnings("module", category=DeprecationWarning)
warnings.filterwarnings("module", category=PendingDeprecationWarning)


def ldns_make_timeval(sec, usec):
    return _ldns.ldns_make_timeval(sec, usec)
ldns_make_timeval = _ldns.ldns_make_timeval

def ldns_read_timeval_sec(t):
    return _ldns.ldns_read_timeval_sec(t)
ldns_read_timeval_sec = _ldns.ldns_read_timeval_sec

def ldns_read_timeval_usec(t):
    return _ldns.ldns_read_timeval_usec(t)
ldns_read_timeval_usec = _ldns.ldns_read_timeval_usec

def _ldns_pkt_additional(p):
    return _ldns._ldns_pkt_additional(p)
_ldns_pkt_additional = _ldns._ldns_pkt_additional

def _ldns_pkt_answer(p):
    return _ldns._ldns_pkt_answer(p)
_ldns_pkt_answer = _ldns._ldns_pkt_answer

def _ldns_pkt_answerfrom(p):
    return _ldns._ldns_pkt_answerfrom(p)
_ldns_pkt_answerfrom = _ldns._ldns_pkt_answerfrom

def _ldns_pkt_authority(p):
    return _ldns._ldns_pkt_authority(p)
_ldns_pkt_authority = _ldns._ldns_pkt_authority

def _ldns_pkt_edns_data(p):
    return _ldns._ldns_pkt_edns_data(p)
_ldns_pkt_edns_data = _ldns._ldns_pkt_edns_data

def _ldns_pkt_tsig(pkt):
    return _ldns._ldns_pkt_tsig(pkt)
_ldns_pkt_tsig = _ldns._ldns_pkt_tsig

def _ldns_pkt_question(p):
    return _ldns._ldns_pkt_question(p)
_ldns_pkt_question = _ldns._ldns_pkt_question

def _ldns_pkt_query_new(rr_name, rr_type, rr_class, flags):
    return _ldns._ldns_pkt_query_new(rr_name, rr_type, rr_class, flags)
_ldns_pkt_query_new = _ldns._ldns_pkt_query_new

def _ldns_pkt_push_rr(p, sec, rr):
    return _ldns._ldns_pkt_push_rr(p, sec, rr)
_ldns_pkt_push_rr = _ldns._ldns_pkt_push_rr

def _ldns_pkt_safe_push_rr(pkt, sec, rr):
    return _ldns._ldns_pkt_safe_push_rr(pkt, sec, rr)
_ldns_pkt_safe_push_rr = _ldns._ldns_pkt_safe_push_rr

def _ldns_pkt_push_rr_list(p, sec, rrl):
    return _ldns._ldns_pkt_push_rr_list(p, sec, rrl)
_ldns_pkt_push_rr_list = _ldns._ldns_pkt_push_rr_list

def _ldns_pkt_safe_push_rr_list(p, s, rrl):
    return _ldns._ldns_pkt_safe_push_rr_list(p, s, rrl)
_ldns_pkt_safe_push_rr_list = _ldns._ldns_pkt_safe_push_rr_list

def _ldns_pkt_set_additional(p, rrl):
    return _ldns._ldns_pkt_set_additional(p, rrl)
_ldns_pkt_set_additional = _ldns._ldns_pkt_set_additional

def _ldns_pkt_set_answer(p, rrl):
    return _ldns._ldns_pkt_set_answer(p, rrl)
_ldns_pkt_set_answer = _ldns._ldns_pkt_set_answer

def _ldns_pkt_set_answerfrom(packet, rdf):
    return _ldns._ldns_pkt_set_answerfrom(packet, rdf)
_ldns_pkt_set_answerfrom = _ldns._ldns_pkt_set_answerfrom

def _ldns_pkt_set_authority(p, rrl):
    return _ldns._ldns_pkt_set_authority(p, rrl)
_ldns_pkt_set_authority = _ldns._ldns_pkt_set_authority

def _ldns_pkt_set_edns_data(packet, rdf):
    return _ldns._ldns_pkt_set_edns_data(packet, rdf)
_ldns_pkt_set_edns_data = _ldns._ldns_pkt_set_edns_data

def _ldns_pkt_set_question(p, rrl):
    return _ldns._ldns_pkt_set_question(p, rrl)
_ldns_pkt_set_question = _ldns._ldns_pkt_set_question

def _ldns_pkt_set_tsig(pkt, rr):
    return _ldns._ldns_pkt_set_tsig(pkt, rr)
_ldns_pkt_set_tsig = _ldns._ldns_pkt_set_tsig

def _ldns_axfr_last_pkt(res):
    return _ldns._ldns_axfr_last_pkt(res)
_ldns_axfr_last_pkt = _ldns._ldns_axfr_last_pkt

def _ldns_resolver_dnssec_anchors(res):
    return _ldns._ldns_resolver_dnssec_anchors(res)
_ldns_resolver_dnssec_anchors = _ldns._ldns_resolver_dnssec_anchors

def _ldns_resolver_domain(res):
    return _ldns._ldns_resolver_domain(res)
_ldns_resolver_domain = _ldns._ldns_resolver_domain

def _ldns_resolver_tsig_algorithm(res):
    return _ldns._ldns_resolver_tsig_algorithm(res)
_ldns_resolver_tsig_algorithm = _ldns._ldns_resolver_tsig_algorithm

def _ldns_resolver_tsig_keydata(res):
    return _ldns._ldns_resolver_tsig_keydata(res)
_ldns_resolver_tsig_keydata = _ldns._ldns_resolver_tsig_keydata

def _ldns_resolver_tsig_keyname(res):
    return _ldns._ldns_resolver_tsig_keyname(res)
_ldns_resolver_tsig_keyname = _ldns._ldns_resolver_tsig_keyname

def _ldns_resolver_set_dnssec_anchors(res, rrl):
    return _ldns._ldns_resolver_set_dnssec_anchors(res, rrl)
_ldns_resolver_set_dnssec_anchors = _ldns._ldns_resolver_set_dnssec_anchors

def _ldns_resolver_set_domain(res, rdf):
    return _ldns._ldns_resolver_set_domain(res, rdf)
_ldns_resolver_set_domain = _ldns._ldns_resolver_set_domain

def _rr_list_replace_content_with_clones(rrl):
    return _ldns._rr_list_replace_content_with_clones(rrl)
_rr_list_replace_content_with_clones = _ldns._rr_list_replace_content_with_clones

def _replacement_ldns_resolver_trusted_key(res, keys):
    return _ldns._replacement_ldns_resolver_trusted_key(res, keys)
_replacement_ldns_resolver_trusted_key = _ldns._replacement_ldns_resolver_trusted_key

def _ldns_rr_rdf(rr, i):
    return _ldns._ldns_rr_rdf(rr, i)
_ldns_rr_rdf = _ldns._ldns_rr_rdf

def _ldns_rr_rrsig_algorithm(rr):
    return _ldns._ldns_rr_rrsig_algorithm(rr)
_ldns_rr_rrsig_algorithm = _ldns._ldns_rr_rrsig_algorithm

def _ldns_rr_dnskey_algorithm(rr):
    return _ldns._ldns_rr_dnskey_algorithm(rr)
_ldns_rr_dnskey_algorithm = _ldns._ldns_rr_dnskey_algorithm

def _ldns_rr_dnskey_flags(rr):
    return _ldns._ldns_rr_dnskey_flags(rr)
_ldns_rr_dnskey_flags = _ldns._ldns_rr_dnskey_flags

def _ldns_rr_dnskey_key(rr):
    return _ldns._ldns_rr_dnskey_key(rr)
_ldns_rr_dnskey_key = _ldns._ldns_rr_dnskey_key

def _ldns_rr_dnskey_protocol(rr):
    return _ldns._ldns_rr_dnskey_protocol(rr)
_ldns_rr_dnskey_protocol = _ldns._ldns_rr_dnskey_protocol

def _ldns_rr_owner(rr):
    return _ldns._ldns_rr_owner(rr)
_ldns_rr_owner = _ldns._ldns_rr_owner

def _ldns_rr_a_address(rr):
    return _ldns._ldns_rr_a_address(rr)
_ldns_rr_a_address = _ldns._ldns_rr_a_address

def _ldns_rr_mx_exchange(rr):
    return _ldns._ldns_rr_mx_exchange(rr)
_ldns_rr_mx_exchange = _ldns._ldns_rr_mx_exchange

def _ldns_rr_mx_preference(rr):
    return _ldns._ldns_rr_mx_preference(rr)
_ldns_rr_mx_preference = _ldns._ldns_rr_mx_preference

def _ldns_rr_ns_nsdname(rr):
    return _ldns._ldns_rr_ns_nsdname(rr)
_ldns_rr_ns_nsdname = _ldns._ldns_rr_ns_nsdname

def _ldns_rr_rrsig_expiration(rr):
    return _ldns._ldns_rr_rrsig_expiration(rr)
_ldns_rr_rrsig_expiration = _ldns._ldns_rr_rrsig_expiration

def _ldns_rr_rrsig_inception(rr):
    return _ldns._ldns_rr_rrsig_inception(rr)
_ldns_rr_rrsig_inception = _ldns._ldns_rr_rrsig_inception

def _ldns_rr_rrsig_keytag(rr):
    return _ldns._ldns_rr_rrsig_keytag(rr)
_ldns_rr_rrsig_keytag = _ldns._ldns_rr_rrsig_keytag

def _ldns_rr_rrsig_labels(rr):
    return _ldns._ldns_rr_rrsig_labels(rr)
_ldns_rr_rrsig_labels = _ldns._ldns_rr_rrsig_labels

def _ldns_rr_rrsig_origttl(rr):
    return _ldns._ldns_rr_rrsig_origttl(rr)
_ldns_rr_rrsig_origttl = _ldns._ldns_rr_rrsig_origttl

def _ldns_rr_rrsig_sig(rr):
    return _ldns._ldns_rr_rrsig_sig(rr)
_ldns_rr_rrsig_sig = _ldns._ldns_rr_rrsig_sig

def _ldns_rr_rrsig_signame(rr):
    return _ldns._ldns_rr_rrsig_signame(rr)
_ldns_rr_rrsig_signame = _ldns._ldns_rr_rrsig_signame

def _ldns_rr_rrsig_typecovered(rr):
    return _ldns._ldns_rr_rrsig_typecovered(rr)
_ldns_rr_rrsig_typecovered = _ldns._ldns_rr_rrsig_typecovered

def _ldns_rr_a_set_address(rr, rdf):
    return _ldns._ldns_rr_a_set_address(rr, rdf)
_ldns_rr_a_set_address = _ldns._ldns_rr_a_set_address

def _ldns_rr_dnskey_set_algorithm(rr, rdf):
    return _ldns._ldns_rr_dnskey_set_algorithm(rr, rdf)
_ldns_rr_dnskey_set_algorithm = _ldns._ldns_rr_dnskey_set_algorithm

def _ldns_rr_dnskey_set_flags(rr, rdf):
    return _ldns._ldns_rr_dnskey_set_flags(rr, rdf)
_ldns_rr_dnskey_set_flags = _ldns._ldns_rr_dnskey_set_flags

def _ldns_rr_dnskey_set_key(rr, rdf):
    return _ldns._ldns_rr_dnskey_set_key(rr, rdf)
_ldns_rr_dnskey_set_key = _ldns._ldns_rr_dnskey_set_key

def _ldns_rr_dnskey_set_protocol(rr, rdf):
    return _ldns._ldns_rr_dnskey_set_protocol(rr, rdf)
_ldns_rr_dnskey_set_protocol = _ldns._ldns_rr_dnskey_set_protocol

def _ldns_rr_push_rdf(rr, rdf):
    return _ldns._ldns_rr_push_rdf(rr, rdf)
_ldns_rr_push_rdf = _ldns._ldns_rr_push_rdf

def _ldns_rr_rrsig_set_algorithm(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_algorithm(rr, rdf)
_ldns_rr_rrsig_set_algorithm = _ldns._ldns_rr_rrsig_set_algorithm

def _ldns_rr_rrsig_set_expiration(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_expiration(rr, rdf)
_ldns_rr_rrsig_set_expiration = _ldns._ldns_rr_rrsig_set_expiration

def _ldns_rr_rrsig_set_inception(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_inception(rr, rdf)
_ldns_rr_rrsig_set_inception = _ldns._ldns_rr_rrsig_set_inception

def _ldns_rr_rrsig_set_keytag(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_keytag(rr, rdf)
_ldns_rr_rrsig_set_keytag = _ldns._ldns_rr_rrsig_set_keytag

def _ldns_rr_rrsig_set_labels(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_labels(rr, rdf)
_ldns_rr_rrsig_set_labels = _ldns._ldns_rr_rrsig_set_labels

def _ldns_rr_rrsig_set_origttl(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_origttl(rr, rdf)
_ldns_rr_rrsig_set_origttl = _ldns._ldns_rr_rrsig_set_origttl

def _ldns_rr_rrsig_set_sig(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_sig(rr, rdf)
_ldns_rr_rrsig_set_sig = _ldns._ldns_rr_rrsig_set_sig

def _ldns_rr_rrsig_set_signame(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_signame(rr, rdf)
_ldns_rr_rrsig_set_signame = _ldns._ldns_rr_rrsig_set_signame

def _ldns_rr_rrsig_set_typecovered(rr, rdf):
    return _ldns._ldns_rr_rrsig_set_typecovered(rr, rdf)
_ldns_rr_rrsig_set_typecovered = _ldns._ldns_rr_rrsig_set_typecovered

def _ldns_rr_set_owner(rr, rdf):
    return _ldns._ldns_rr_set_owner(rr, rdf)
_ldns_rr_set_owner = _ldns._ldns_rr_set_owner

def _ldns_rr_set_rdf(rr, rdf, pos):
    return _ldns._ldns_rr_set_rdf(rr, rdf, pos)
_ldns_rr_set_rdf = _ldns._ldns_rr_set_rdf

def _ldns_rr_list_push_rr(r, rr):
    return _ldns._ldns_rr_list_push_rr(r, rr)
_ldns_rr_list_push_rr = _ldns._ldns_rr_list_push_rr

def _ldns_rr_list_push_rr_list(r, r2):
    return _ldns._ldns_rr_list_push_rr_list(r, r2)
_ldns_rr_list_push_rr_list = _ldns._ldns_rr_list_push_rr_list

def _ldns_rr_list_set_rr(rrl, rr, idx):
    return _ldns._ldns_rr_list_set_rr(rrl, rr, idx)
_ldns_rr_list_set_rr = _ldns._ldns_rr_list_set_rr

def _ldns_rr_list_cat(r, r2):
    return _ldns._ldns_rr_list_cat(r, r2)
_ldns_rr_list_cat = _ldns._ldns_rr_list_cat

def _ldns_rr_list_rr(r, i):
    return _ldns._ldns_rr_list_rr(r, i)
_ldns_rr_list_rr = _ldns._ldns_rr_list_rr

def _ldns_rr_list_owner(r):
    return _ldns._ldns_rr_list_owner(r)
_ldns_rr_list_owner = _ldns._ldns_rr_list_owner

def ldns_rr_descriptor_dummy_free(rd):
    return _ldns.ldns_rr_descriptor_dummy_free(rd)
ldns_rr_descriptor_dummy_free = _ldns.ldns_rr_descriptor_dummy_free

def ldns_verify_rrsig_keylist_status_only(rrset, rrsig, keys):
    return _ldns.ldns_verify_rrsig_keylist_status_only(rrset, rrsig, keys)
ldns_verify_rrsig_keylist_status_only = _ldns.ldns_verify_rrsig_keylist_status_only

def ldns_verify_rrsig_keylist_(rrset, rrsig, keys):
    return _ldns.ldns_verify_rrsig_keylist_(rrset, rrsig, keys)
ldns_verify_rrsig_keylist_ = _ldns.ldns_verify_rrsig_keylist_

def ldns_verify_rrsig_keylist_notime_status_only(rrset, rrsig, keys):
    return _ldns.ldns_verify_rrsig_keylist_notime_status_only(rrset, rrsig, keys)
ldns_verify_rrsig_keylist_notime_status_only = _ldns.ldns_verify_rrsig_keylist_notime_status_only

def ldns_verify_rrsig_keylist_notime_(rrset, rrsig, keys):
    return _ldns.ldns_verify_rrsig_keylist_notime_(rrset, rrsig, keys)
ldns_verify_rrsig_keylist_notime_ = _ldns.ldns_verify_rrsig_keylist_notime_
LDNS_MAX_LABELLEN = _ldns.LDNS_MAX_LABELLEN
LDNS_MAX_DOMAINLEN = _ldns.LDNS_MAX_DOMAINLEN
LDNS_MAX_POINTERS = _ldns.LDNS_MAX_POINTERS
LDNS_RR_OVERHEAD = _ldns.LDNS_RR_OVERHEAD
LDNS_RDATA_FIELD_DESCRIPTORS_COMMON = _ldns.LDNS_RDATA_FIELD_DESCRIPTORS_COMMON
LDNS_RR_CLASS_IN = _ldns.LDNS_RR_CLASS_IN
LDNS_RR_CLASS_CH = _ldns.LDNS_RR_CLASS_CH
LDNS_RR_CLASS_HS = _ldns.LDNS_RR_CLASS_HS
LDNS_RR_CLASS_NONE = _ldns.LDNS_RR_CLASS_NONE
LDNS_RR_CLASS_ANY = _ldns.LDNS_RR_CLASS_ANY
LDNS_RR_CLASS_FIRST = _ldns.LDNS_RR_CLASS_FIRST
LDNS_RR_CLASS_LAST = _ldns.LDNS_RR_CLASS_LAST
LDNS_RR_CLASS_COUNT = _ldns.LDNS_RR_CLASS_COUNT
LDNS_RR_COMPRESS = _ldns.LDNS_RR_COMPRESS
LDNS_RR_NO_COMPRESS = _ldns.LDNS_RR_NO_COMPRESS
LDNS_RR_TYPE_A = _ldns.LDNS_RR_TYPE_A
LDNS_RR_TYPE_NS = _ldns.LDNS_RR_TYPE_NS
LDNS_RR_TYPE_MD = _ldns.LDNS_RR_TYPE_MD
LDNS_RR_TYPE_MF = _ldns.LDNS_RR_TYPE_MF
LDNS_RR_TYPE_CNAME = _ldns.LDNS_RR_TYPE_CNAME
LDNS_RR_TYPE_SOA = _ldns.LDNS_RR_TYPE_SOA
LDNS_RR_TYPE_MB = _ldns.LDNS_RR_TYPE_MB
LDNS_RR_TYPE_MG = _ldns.LDNS_RR_TYPE_MG
LDNS_RR_TYPE_MR = _ldns.LDNS_RR_TYPE_MR
LDNS_RR_TYPE_NULL = _ldns.LDNS_RR_TYPE_NULL
LDNS_RR_TYPE_WKS = _ldns.LDNS_RR_TYPE_WKS
LDNS_RR_TYPE_PTR = _ldns.LDNS_RR_TYPE_PTR
LDNS_RR_TYPE_HINFO = _ldns.LDNS_RR_TYPE_HINFO
LDNS_RR_TYPE_MINFO = _ldns.LDNS_RR_TYPE_MINFO
LDNS_RR_TYPE_MX = _ldns.LDNS_RR_TYPE_MX
LDNS_RR_TYPE_TXT = _ldns.LDNS_RR_TYPE_TXT
LDNS_RR_TYPE_RP = _ldns.LDNS_RR_TYPE_RP
LDNS_RR_TYPE_AFSDB = _ldns.LDNS_RR_TYPE_AFSDB
LDNS_RR_TYPE_X25 = _ldns.LDNS_RR_TYPE_X25
LDNS_RR_TYPE_ISDN = _ldns.LDNS_RR_TYPE_ISDN
LDNS_RR_TYPE_RT = _ldns.LDNS_RR_TYPE_RT
LDNS_RR_TYPE_NSAP = _ldns.LDNS_RR_TYPE_NSAP
LDNS_RR_TYPE_NSAP_PTR = _ldns.LDNS_RR_TYPE_NSAP_PTR
LDNS_RR_TYPE_SIG = _ldns.LDNS_RR_TYPE_SIG
LDNS_RR_TYPE_KEY = _ldns.LDNS_RR_TYPE_KEY
LDNS_RR_TYPE_PX = _ldns.LDNS_RR_TYPE_PX
LDNS_RR_TYPE_GPOS = _ldns.LDNS_RR_TYPE_GPOS
LDNS_RR_TYPE_AAAA = _ldns.LDNS_RR_TYPE_AAAA
LDNS_RR_TYPE_LOC = _ldns.LDNS_RR_TYPE_LOC
LDNS_RR_TYPE_NXT = _ldns.LDNS_RR_TYPE_NXT
LDNS_RR_TYPE_EID = _ldns.LDNS_RR_TYPE_EID
LDNS_RR_TYPE_NIMLOC = _ldns.LDNS_RR_TYPE_NIMLOC
LDNS_RR_TYPE_SRV = _ldns.LDNS_RR_TYPE_SRV
LDNS_RR_TYPE_ATMA = _ldns.LDNS_RR_TYPE_ATMA
LDNS_RR_TYPE_NAPTR = _ldns.LDNS_RR_TYPE_NAPTR
LDNS_RR_TYPE_KX = _ldns.LDNS_RR_TYPE_KX
LDNS_RR_TYPE_CERT = _ldns.LDNS_RR_TYPE_CERT
LDNS_RR_TYPE_A6 = _ldns.LDNS_RR_TYPE_A6
LDNS_RR_TYPE_DNAME = _ldns.LDNS_RR_TYPE_DNAME
LDNS_RR_TYPE_SINK = _ldns.LDNS_RR_TYPE_SINK
LDNS_RR_TYPE_OPT = _ldns.LDNS_RR_TYPE_OPT
LDNS_RR_TYPE_APL = _ldns.LDNS_RR_TYPE_APL
LDNS_RR_TYPE_DS = _ldns.LDNS_RR_TYPE_DS
LDNS_RR_TYPE_SSHFP = _ldns.LDNS_RR_TYPE_SSHFP
LDNS_RR_TYPE_IPSECKEY = _ldns.LDNS_RR_TYPE_IPSECKEY
LDNS_RR_TYPE_RRSIG = _ldns.LDNS_RR_TYPE_RRSIG
LDNS_RR_TYPE_NSEC = _ldns.LDNS_RR_TYPE_NSEC
LDNS_RR_TYPE_DNSKEY = _ldns.LDNS_RR_TYPE_DNSKEY
LDNS_RR_TYPE_DHCID = _ldns.LDNS_RR_TYPE_DHCID
LDNS_RR_TYPE_NSEC3 = _ldns.LDNS_RR_TYPE_NSEC3
LDNS_RR_TYPE_NSEC3PARAM = _ldns.LDNS_RR_TYPE_NSEC3PARAM
LDNS_RR_TYPE_NSEC3PARAMS = _ldns.LDNS_RR_TYPE_NSEC3PARAMS
LDNS_RR_TYPE_TLSA = _ldns.LDNS_RR_TYPE_TLSA
LDNS_RR_TYPE_SMIMEA = _ldns.LDNS_RR_TYPE_SMIMEA
LDNS_RR_TYPE_HIP = _ldns.LDNS_RR_TYPE_HIP
LDNS_RR_TYPE_NINFO = _ldns.LDNS_RR_TYPE_NINFO
LDNS_RR_TYPE_RKEY = _ldns.LDNS_RR_TYPE_RKEY
LDNS_RR_TYPE_TALINK = _ldns.LDNS_RR_TYPE_TALINK
LDNS_RR_TYPE_CDS = _ldns.LDNS_RR_TYPE_CDS
LDNS_RR_TYPE_CDNSKEY = _ldns.LDNS_RR_TYPE_CDNSKEY
LDNS_RR_TYPE_OPENPGPKEY = _ldns.LDNS_RR_TYPE_OPENPGPKEY
LDNS_RR_TYPE_CSYNC = _ldns.LDNS_RR_TYPE_CSYNC
LDNS_RR_TYPE_SPF = _ldns.LDNS_RR_TYPE_SPF
LDNS_RR_TYPE_UINFO = _ldns.LDNS_RR_TYPE_UINFO
LDNS_RR_TYPE_UID = _ldns.LDNS_RR_TYPE_UID
LDNS_RR_TYPE_GID = _ldns.LDNS_RR_TYPE_GID
LDNS_RR_TYPE_UNSPEC = _ldns.LDNS_RR_TYPE_UNSPEC
LDNS_RR_TYPE_NID = _ldns.LDNS_RR_TYPE_NID
LDNS_RR_TYPE_L32 = _ldns.LDNS_RR_TYPE_L32
LDNS_RR_TYPE_L64 = _ldns.LDNS_RR_TYPE_L64
LDNS_RR_TYPE_LP = _ldns.LDNS_RR_TYPE_LP
LDNS_RR_TYPE_EUI48 = _ldns.LDNS_RR_TYPE_EUI48
LDNS_RR_TYPE_EUI64 = _ldns.LDNS_RR_TYPE_EUI64
LDNS_RR_TYPE_TKEY = _ldns.LDNS_RR_TYPE_TKEY
LDNS_RR_TYPE_TSIG = _ldns.LDNS_RR_TYPE_TSIG
LDNS_RR_TYPE_IXFR = _ldns.LDNS_RR_TYPE_IXFR
LDNS_RR_TYPE_AXFR = _ldns.LDNS_RR_TYPE_AXFR
LDNS_RR_TYPE_MAILB = _ldns.LDNS_RR_TYPE_MAILB
LDNS_RR_TYPE_MAILA = _ldns.LDNS_RR_TYPE_MAILA
LDNS_RR_TYPE_ANY = _ldns.LDNS_RR_TYPE_ANY
LDNS_RR_TYPE_URI = _ldns.LDNS_RR_TYPE_URI
LDNS_RR_TYPE_CAA = _ldns.LDNS_RR_TYPE_CAA
LDNS_RR_TYPE_AVC = _ldns.LDNS_RR_TYPE_AVC
LDNS_RR_TYPE_TA = _ldns.LDNS_RR_TYPE_TA
LDNS_RR_TYPE_DLV = _ldns.LDNS_RR_TYPE_DLV
LDNS_RR_TYPE_FIRST = _ldns.LDNS_RR_TYPE_FIRST
LDNS_RR_TYPE_LAST = _ldns.LDNS_RR_TYPE_LAST
LDNS_RR_TYPE_COUNT = _ldns.LDNS_RR_TYPE_COUNT
class ldns_rr(_object):
    """
    Resource Record (RR).

    The RR is the basic DNS element that contains actual data. This class allows
    to create RR and manipulate with the content.

    Use :meth:`ldns_rr_new`, :meth:`ldns_rr_new_frm_type`, :meth:`new_frm_fp`,
    :meth:`new_frm_fp_l`, :meth:`new_frm_str` or :meth:`new_question_frm_str`
    to create :class:`ldns_rr` instances.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_rr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_rr, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_owner"] = _ldns.ldns_rr__owner_set
    __swig_getmethods__["_owner"] = _ldns.ldns_rr__owner_get
    if _newclass:
        _owner = _swig_property(_ldns.ldns_rr__owner_get, _ldns.ldns_rr__owner_set)
    __swig_setmethods__["_ttl"] = _ldns.ldns_rr__ttl_set
    __swig_getmethods__["_ttl"] = _ldns.ldns_rr__ttl_get
    if _newclass:
        _ttl = _swig_property(_ldns.ldns_rr__ttl_get, _ldns.ldns_rr__ttl_set)
    __swig_setmethods__["_rd_count"] = _ldns.ldns_rr__rd_count_set
    __swig_getmethods__["_rd_count"] = _ldns.ldns_rr__rd_count_get
    if _newclass:
        _rd_count = _swig_property(_ldns.ldns_rr__rd_count_get, _ldns.ldns_rr__rd_count_set)
    __swig_setmethods__["_rr_type"] = _ldns.ldns_rr__rr_type_set
    __swig_getmethods__["_rr_type"] = _ldns.ldns_rr__rr_type_get
    if _newclass:
        _rr_type = _swig_property(_ldns.ldns_rr__rr_type_get, _ldns.ldns_rr__rr_type_set)
    __swig_setmethods__["_rr_class"] = _ldns.ldns_rr__rr_class_set
    __swig_getmethods__["_rr_class"] = _ldns.ldns_rr__rr_class_get
    if _newclass:
        _rr_class = _swig_property(_ldns.ldns_rr__rr_class_get, _ldns.ldns_rr__rr_class_set)
    __swig_setmethods__["_rr_question"] = _ldns.ldns_rr__rr_question_set
    __swig_getmethods__["_rr_question"] = _ldns.ldns_rr__rr_question_get
    if _newclass:
        _rr_question = _swig_property(_ldns.ldns_rr__rr_question_get, _ldns.ldns_rr__rr_question_set)

    def __init__(self):
        raise Exception("This class can't be created directly. " +
            "Please use: ldns_rr_new(), ldns_rr_new_frm_type(), " +
            "new_frm_fp(), new_frm_fp_l(), new_frm_str() or " +
            "new_question_frm_str()")

    __swig_destroy__ = _ldns._ldns_rr_free

    #
    # LDNS_RR_CONSTRUCTORS_
    #

    @staticmethod
    def new_frm_str(string, default_ttl=0, origin=None, prev=None, raiseException=True):
        """
           Creates an rr object from a string.

           The string should be a fully filled-in rr, like "owner_name
           [space] TTL [space] CLASS [space] TYPE [space] RDATA."

           :param string: The string to convert.
           :type string: str
           :param default_ttl: Default ttl value for the rr.
               If 0 DEF_TTL will be used.
           :type default_ttl: int
           :param origin: When the owner is relative add this.
           :type origin: :class:`ldns_dname`
           :param prev: The previous owner name.
           :type prev: :class:`ldns_rdf`
           :param raiseException: If True, an exception occurs in case a rr
               instance can't be created.
           :throws Exception: If `raiseExceprion` is set and fails.
           :throws TypeError: When parameters of incorrect types.
           :return: (:class:`ldns_rr`) RR instance or None.

           .. note::
               The type checking of `origin` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.

           **Usage**

           >>> import ldns
           >>> rr = ldns.ldns_rr.new_frm_str("www.nic.cz. IN A 192.168.1.1", 300)
           >>> print rr
           www.nic.cz.  300  IN  A  192.168.1.1
           >>> rr = ldns.ldns_rr.new_frm_str("test.nic.cz. 600 IN A 192.168.1.2")
           >>> print rr
           test.nic.cz.  600  IN  A  192.168.1.2

        """
        if (not isinstance(origin, ldns_dname)) and \
           isinstance(origin, ldns_rdf) and \
           origin.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_rr.new_frm_str() method will" +
                " drop the possibility to accept ldns_rdf as origin." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        status, rr, prev = _ldns.ldns_rr_new_frm_str_(string, default_ttl,
            origin, prev)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create RR, error: %d" % status)
            return None
        return rr

    @staticmethod
    def new_question_frm_str(string, default_ttl=0, origin=None, prev=None, raiseException=True):
        """
           Creates an rr object from a string.

           The string is like :meth:`new_frm_str` but without rdata.

           :param string: The string to convert.
           :type string: str
           :param origin: When the owner is relative add this.
           :type origin: :class:`ldns_dname`
           :param prev: The previous owner name.
           :type prev: :class:`ldns_rdf`
           :param raiseException: If True, an exception occurs in case
               a rr instance can't be created.
           :throws Exception: If `raiseExceprion` is set and fails.
           :throws TypeError: When parameters of incorrect types.
           :return: (:class:`ldns_rr`) RR instance or None. If the object
               can't be created and `raiseException` is True,
               an exception occurs.

           .. note::
               The type checking of `origin` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(origin, ldns_dname)) and \
           isinstance(origin, ldns_rdf) and \
           origin.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_rr.new_question_frm_str() method will" +
                " drop the possibility to accept ldns_rdf as origin." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        status, rr, prev = _ldns.ldns_rr_new_question_frm_str_(string,
            origin, prev)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create RR, error: %d" % status)
            return None
        return rr

    @staticmethod
    def new_frm_str_prev(string, default_ttl=0, origin=None, prev=None, raiseException=True):
        """
           Creates an rr object from a string.

           The string should be a fully filled-in rr, like "owner_name
           [space] TTL [space] CLASS [space] TYPE [space] RDATA".

           :param string: The string to convert.
           :type string: str
           :param default_ttl: Default ttl value for the rr.
               If 0 DEF_TTL will be used.
           :type default_ttl: int
           :param origin: When the owner is relative add this.
           :type origin: :class:`ldns_dname`
           :param prev: The previous owner name.
           :type prev: :class:`ldns_rdf`
           :param raiseException: If True, an exception occurs in case when
               a rr instance can't be created.
           :throws Exception: If `raiseExceprion` is set and fails.
           :throws TypeError: When parameters of incorrect types.
           :return: None when fails, otherwise a tuple containing:

              * rr - (:class:`ldns_rr`) RR instance or None.
                If the object can't be created and `raiseException`
                is True, an exception occurs.

              * prev - (:class:`ldns_rdf`) Owner name found in this string
                or None.

           .. note::
               The type checking of `origin` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(origin, ldns_dname)) and \
           isinstance(origin, ldns_rdf) and \
           origin.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_rr.new_frm_str_prev() method will" +
                " drop the possibility to accept ldns_rdf as origin." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        status, rr, prev = _ldns.ldns_rr_new_frm_str_(string, default_ttl,
            origin, prev)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create RR, error: %d" % status)
            return None
        return rr, prev

    @staticmethod
    def new_frm_fp(file, default_ttl=0, origin=None, prev=None, raiseException=True):
        """
           Creates a new rr from a file containing a string.

           :param file: Opened file.
           :param default_ttl: If 0 DEF_TTL will be used.
           :type default_ttl: int
           :param origin: When the owner is relative add this.
           :type origin: :class:`ldns_dname`
           :param prev: When the owner is white spaces use this.
           :type prev: :class:`ldns_rdf`
           :param raiseException: If True, an exception occurs in case
               a resolver object can't be created.
           :throws Exception: If `raiseException` is set and the input
               cannot be read.
           :throws TypeError: When parameters of incorrect types.
           :return: None when fails, otherwise a tuple containing:

               * rr - (:class:`ldns_rr`) RR object or None. If the object
                 can't be created and `raiseException` is True,
                 an exception occurs.

               * ttl - (int) None or TTL if the file contains a TTL
                 directive.

               * origin - (:class:`ldns_rdf`) None or dname rdf if the file
                 contains a ORIGIN directive.

               * prev - (:class:`ldns_rdf`) None or updated value
                 of prev parameter.

           .. note::
               The type checking of `origin` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(origin, ldns_dname)) and \
           isinstance(origin, ldns_rdf) and \
           origin.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_rr.new_frm_fp() method will" +
                " drop the possibility to accept ldns_rdf as origin." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        res = _ldns.ldns_rr_new_frm_fp_(file, default_ttl, origin, prev)
        if res[0] != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create RR, error: %d" % res[0])
            return None
        return res[1:]

    @staticmethod
    def new_frm_fp_l(file, default_ttl=0, origin=None, prev=None, raiseException=True):
        """
           Creates a new rr from a file containing a string.

           :param file: Opened file.
           :param default_ttl: If 0 DEF_TTL will be used.
           :type default_ttl: int
           :param origin: When the owner is relative add this.
           :type origin: :class:`ldns_dname`
           :param prev: When the owner is white spaces use this.
           :type prev: :class:`ldns_rdf`
           :param raiseException: Iif True, an exception occurs in case
               a resolver object can't be created.
           :throws Exception: If `raiseException` is set and the input
               cannot be read.
           :throws TypeError: When parameters of incorrect types.
           :return: None when fails, otherwise a tuple containing:

              * rr - (:class:`ldns_rr`) RR object or None. If the object
                can't be created and `raiseException` is True,
                an exception occurs.

              * line - (int) line number (for debugging).

              * ttl - (int) None or TTL if the file contains a TTL
                directive .

              * origin - (:class:`ldns_rdf`) None or dname rdf if the file
                contains a ORIGIN directive.

              * prev - (:class:`ldns_rdf`) None or updated value of prev
                parameter.

           .. note::
               The type checking of `origin` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(origin, ldns_dname)) and \
           isinstance(origin, ldns_rdf) and \
           origin.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_rr.new_frm_fp_l() method will" +
                " drop the possibility to accept ldns_rdf as origin." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        res = _ldns.ldns_rr_new_frm_fp_l_(file, default_ttl, origin, prev)
        if res[0] != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create RR, error: %d" % res[0])
            return None
        return res[1:]

    #
    # _LDNS_RR_CONSTRUCTORS
    #

    def __str__(self):
        """
           Converts the data in the resource record to presentation format.

           :return: (str)
        """
        return _ldns.ldns_rr2str(self)

    def __cmp__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (int) 0 if equal, -1 if `self` comes before `other`,
               1 if `other` RR comes before `self`.
        """
        return _ldns.ldns_rr_compare(self, other)

    def __lt__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (bool) True when `self` is less than 'other'.
        """
        return _ldns.ldns_rr_compare(self, other) == -1

    def __le__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (bool) True when `self` is less than or equal to
               'other'.
        """
        return _ldns.ldns_rr_compare(self, other) != 1

    def __eq__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (bool) True when `self` is equal to 'other'.
        """
        return _ldns.ldns_rr_compare(self, other) == 0

    def __ne__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (bool) True when `self` is not equal to 'other'.
        """
        return _ldns.ldns_rr_compare(self, other) != 0

    def __gt__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (bool) True when `self` is greater than 'other'.
        """
        return _ldns.ldns_rr_compare(self, other) == 1

    def __ge__(self, other):
        """
           Compares two rrs.

           The TTL is not looked at.

           :param other: The second RR one.
           :type other: :class:`ldns_rr`
           :throws TypeError: When `other` of non-:class:`ldns_rr` type.
           :return: (bool) True when `self` is greater than or equal to
                'other'.
        """
        return _ldns.ldns_rr_compare(self, other) != -1

    @staticmethod
    def class_by_name(string):
        """
           Retrieves a class identifier value by looking up its name.

           :param string: Class name.
           :type string: str
           :throws TypeError: when `string` of inappropriate type.
           :return: (int) Class identifier value, or 0 if not valid
               class name given.
        """
        return _ldns.ldns_get_rr_class_by_name(string)

    def rdfs(self):
        """
           Returns a generator object of rdata records.

           :return: Generator of :class:`ldns_rdf`.
        """
        for i in range(0, self.rd_count()):
            yield self.rdf(i)

    def print_to_file(self, output):
        """
           Prints the data in the resource record to the given file stream
           (in presentation format).

           :param output: Opened file stream.
           :throws TypeError: When `output` not a file.
        """
        _ldns.ldns_rr_print(output, self)
    #parameters: FILE *, const ldns_rr *,

    def get_type_str(self):
        """
           Converts an RR type value to its string representation,
           and returns that string.

           :return: (str) containing type identification.
        """
        return _ldns.ldns_rr_type2str(self.get_type())
    #parameters: const ldns_rr_type,

    def get_class_str(self):
        """
           Converts an RR class value to its string representation,
           and returns that string.

           :return: (str) containing class identification.
        """
        return _ldns.ldns_rr_class2str(self.get_class())
    #parameters: const ldns_rr_class,

    @staticmethod
    def dnskey_key_size_raw(keydata, len, alg):
        """
           Get the length of the keydata in bits.

           :param keydata: Key raw data.
           :type keydata: unsigned char \*
           :param len: Number of bytes of `keydata`.
           :type len: size_t
           :param alg: Algorithm identifier.
           :type alg: ldns_algorithm

           :return: (size_t) The length of key data in bits.
        """
        return _ldns.ldns_rr_dnskey_key_size_raw(keydata, len, alg)
    #parameters: const unsigned char *,const size_t,const ldns_algorithm,
    #retvals: size_t

    def write_to_buffer(self,buffer,section):
        """
           Copies the rr data to the buffer in wire format.

           :param buffer: Buffer to append the result to.
           :type buffer: :class:`ldns_buffer`
           :param section: The section in the packet this rr is supposed
               to be in (to determine whether to add rdata or not).
           :type section: int
           :throws TypeError: when arguments of mismatching types passed.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rr2buffer_wire(buffer, self, section)
    #parameters: ldns_buffer *,const ldns_rr *,int,
    #retvals: ldns_status

    def write_to_buffer_canonical(self,buffer,section):
        """
           Copies the rr data to the buffer in wire format, in canonical
           format according to RFC3597 (every dname in rdata fields
           of RR's mentioned in that RFC will be converted to lower-case).

           :param buffer: Buffer to append the result to.
           :type buffer: :class:`ldns_buffer`
           :param section: The section in the packet this rr is supposed
               to be in (to determine whether to add rdata or not).
           :type section: int
           :throws TypeError: when arguments of mismatching types passed.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rr2buffer_wire_canonical(buffer,self,section)
    #parameters: ldns_buffer *,const ldns_rr *,int,
    #retvals: ldns_status

    def write_data_to_buffer(self, buffer):
        """
           Converts an rr's rdata to wire format, while excluding the
           owner name and all the stuff before the rdata.

           This is needed in DNSSEC key-tag calculation, the ds
           calculation from the key and maybe elsewhere.

           :param buffer: Buffer to append the result to.
           :type buffer: :class:`ldns_buffer`
           :throws TypeError: when `buffer` of non-:class:`ldns_buffer`
               type.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rr_rdata2buffer_wire(buffer,self)
    #parameters: ldns_buffer *, const ldns_rr *,
    #retvals: ldns_status

    def write_rrsig_to_buffer(self, buffer):
        """
           Converts a rrsig to wire format BUT EXCLUDE the rrsig rdata.

           This is needed in DNSSEC verification.

           :param buffer: Buffer to append the result to.
           :type buffer: :class:`ldns_buffer`
           :throws TypeError: when `buffer` of non-:class:`ldns_buffer`
               type.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rrsig2buffer_wire(buffer,self)
    #parameters: ldns_buffer *,const ldns_rr *,
    #retvals: ldns_status

    #
    # LDNS_RR_METHODS_
    #

    def a_address(self):
        """
           Returns the address rdf of a LDNS_RR_TYPE_A or LDNS_RR_TYPE_AAAA
           rr.

           :return: (:class:`ldns_rdf`) with the address or None on
               failure.
        """
        return _ldns._ldns_rr_a_address(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def a_set_address(self, f):
        """
           Sets the address of a LDNS_RR_TYPE_A or LDNS_RR_TYPE_AAAA rr.

           :param f: The address to be set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: When `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_a_set_address(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def clone(self):
        """
           Clones a rr and all its data.

           :return: (:class:`ldns_rr`) The new rr or None on failure.
        """
        return _ldns.ldns_rr_clone(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rr *

    def compare_ds(self, rr2):
        """
           Returns True if the given rr's are equal. 

           Also returns True if one record is a DS that represents the
           same DNSKEY record as the other record.

           :param rr2: The second rr.
           :type rr2: :class:`ldns_rr`
           :throws TypeError: When `rr2` of non-:class:`ldns_rr` type.
           :return: (bool) True if equal otherwise False.
        """
        return _ldns.ldns_rr_compare_ds(self, rr2)
    #parameters: const ldns_rr *, const ldns_rr *,
    #retvals: bool

    def compare_no_rdata(self, rr2):
        """
           Compares two rrs, up to the rdata.

           :param rr2: Rhe second rr.
           :type rr2: :class:`ldns_rr`
           :throws TypeError: When `rr2` of non-:class:`ldns_rr` type.
           :return: (int) 0 if equal, negative integer if `self` comes
               before `rr2`, positive integer if `rr2` comes before `self`.
        """
        return _ldns.ldns_rr_compare_no_rdata(self, rr2)
    #parameters: const ldns_rr *, const ldns_rr *,
    #retvals: int

    def dnskey_algorithm(self):
        """
           Returns the algorithm of a LDNS_RR_TYPE_DNSKEY rr.

           :return: (:class:`ldns_rdf`) with the algorithm or None
               on failure.
        """
        return _ldns._ldns_rr_dnskey_algorithm(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def dnskey_flags(self):
        """
           Returns the flags of a LDNS_RR_TYPE_DNSKEY rr.

           :return: (:class:`ldns_rdf`) with the flags or None on failure.
        """
        return _ldns._ldns_rr_dnskey_flags(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def dnskey_key(self):
        """
           Returns the key data of a LDNS_RR_TYPE_DNSKEY rr.

           :return: (:class:`ldns_rdf`) with the key data or None on
               failure.
        """
        return _ldns._ldns_rr_dnskey_key(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def dnskey_key_size(self):
        """
           Get the length of the keydata in bits.

           :return: (size_t) the keysize in bits.
        """
        return _ldns.ldns_rr_dnskey_key_size(self)
    #parameters: const ldns_rr *,
    #retvals: size_t

    def dnskey_protocol(self):
        """
           Returns the protocol of a LDNS_RR_TYPE_DNSKEY rr.

           :return: (:class:`ldns_rdf`) with the protocol or None on
               failure.
        """
        return _ldns._ldns_rr_dnskey_protocol(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def dnskey_set_algorithm(self, f):
        """
           Sets the algorithm of a LDNS_RR_TYPE_DNSKEY rr

           :param f: The algorithm to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: When `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_dnskey_set_algorithm(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def dnskey_set_flags(self, f):
        """
           Sets the flags of a LDNS_RR_TYPE_DNSKEY rr.

           :param f: The flags to be set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: When `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_dnskey_set_flags(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def dnskey_set_key(self, f):
        """
           Sets the key data of a LDNS_RR_TYPE_DNSKEY rr.

           :param f: The key data to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: When `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_dnskey_set_key(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def dnskey_set_protocol(self,f):
        """
           Sets the protocol of a LDNS_RR_TYPE_DNSKEY rr.

           :param f: The protocol to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: When `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_dnskey_set_protocol(self,f)
    #parameters: ldns_rr *,ldns_rdf *,
    #retvals: bool

    def get_class(self):
        """
           Returns the class of the rr.

           :return: (int) The class identifier of the rr.
        """
        return _ldns.ldns_rr_get_class(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rr_class

    def get_type(self):
        """
           Returns the type of the rr.

           :return: (int) The type identifier of the rr.
        """
        return _ldns.ldns_rr_get_type(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rr_type

    def is_question(self):
        """
           Returns the question flag of a rr structure.

           :return: (bool) True if question flag is set.
        """
        return _ldns.ldns_rr_is_question(self)

    def label_count(self):
        """
           Counts the number of labels of the owner name.

           :return: (int) The number of labels.
        """
        return _ldns.ldns_rr_label_count(self)
    #parameters: ldns_rr *,
    #retvals: uint8_t

    def mx_exchange(self):
        """
           Returns the mx host of a LDNS_RR_TYPE_MX rr.

           :return: (:class:`ldns_rdf`) with the name of the MX host
              or None on failure.
        """
        return _ldns._ldns_rr_mx_exchange(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def mx_preference(self):
        """
           Returns the mx preference of a LDNS_RR_TYPE_MX rr.

           :return: (:class:`ldns_rdf`) with the preference or None
               on failure.
        """
        return _ldns._ldns_rr_mx_preference(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def ns_nsdname(self):
        """
           Returns the name of a LDNS_RR_TYPE_NS rr.

           :return: (:class:`ldns_rdf`) A dname rdf with the name or
               None on failure.
        """
        return _ldns._ldns_rr_ns_nsdname(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def owner(self):
        """
           Returns the owner name of an rr structure.

           :return: (:class:`ldns_dname`) Owner name or None on failure.
        """
        rdf = _ldns._ldns_rr_owner(self)
        if rdf:
            rdf = ldns_dname(rdf, clone=False)
        return rdf
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def pop_rdf(self):
        """
           Removes a rd_field member, it will be popped from the last
           position.

           :return: (:class:`ldns_rdf`) rdf which was popped, None if
               nothing.
        """
        return _ldns.ldns_rr_pop_rdf(self)
    #parameters: ldns_rr *,
    #retvals: ldns_rdf *

    def push_rdf(self,f):
        """
           Sets rd_field member, it will be placed in the next available
           spot.

           :param f: The rdf to be appended.
           :type f: :class:`ldns_rdf`
           :throws TypeError: When `f` of non-:class:`ldns_rdf` type.
           :return: (bool) Returns True if success, False otherwise.
        """
        return _ldns._ldns_rr_push_rdf(self, f)
    #parameters: ldns_rr *, const ldns_rdf *,
    #retvals: bool

    def rd_count(self):
        """
           Returns the rd_count of an rr structure.

           :return: (size_t) the rd count of the rr.
        """
        return _ldns.ldns_rr_rd_count(self)
    #parameters: const ldns_rr *,
    #retvals: size_t

    def rdf(self, nr):
        """
           Returns the rdata field with the given index.

           :param nr: The index of the rdf to return.
           :type nr: positive int
           :throws TypeError: When `nr` not a positive integer.
           :return: (:class:`ldns_rdf`) The given rdf or None if fails.
        """
        return _ldns._ldns_rr_rdf(self, nr)
    #parameters: const ldns_rr *, size_t,
    #retvals: ldns_rdf *

    def rrsig_algorithm(self):
        """
           Returns the algorithm identifier of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the algorithm or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_algorithm(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_expiration(self):
        """
           Returns the expiration time of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the expiration time or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_expiration(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_inception(self):
        """
           Returns the inception time of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the inception time or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_inception(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_keytag(self):
        """
           Returns the keytag of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the keytag or None on failure.
        """
        return _ldns._ldns_rr_rrsig_keytag(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_labels(self):
        """
           Returns the number of labels of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the number of labels or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_labels(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_origttl(self):
        """
           Returns the original TTL of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the original TTL or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_origttl(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_set_algorithm(self, f):
        """
           Sets the algorithm of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The algorithm to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_algorithm(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_expiration(self, f):
        """
           Sets the expireation date of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The expireation date to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_expiration(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_inception(self, f):
        """
           Sets the inception date of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The inception date to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_inception(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_keytag(self, f):
        """
           Sets the keytag of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The keytag to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_keytag(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_labels(self, f):
        """
           Sets the number of labels of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The number of labels to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_labels(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_origttl(self, f):
        """
           Sets the original TTL of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The original TTL to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_origttl(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_sig(self, f):
        """
           Sets the signature data of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The signature data to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_sig(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_signame(self, f):
        """
           Sets the signers name of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The signers name to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_signame(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_set_typecovered(self, f):
        """
           Sets the typecovered of a LDNS_RR_TYPE_RRSIG rr.

           :param f: The type covered to set.
           :type f: :class:`ldns_rdf`
           :throws TypeError: when `f` of non-:class:`ldns_rdf` type.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns._ldns_rr_rrsig_set_typecovered(self, f)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals: bool

    def rrsig_sig(self):
        """
           Returns the signature data of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the signature data or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_sig(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_signame(self):
        """
           Returns the signers name of a LDNS_RR_TYPE_RRSIG RR.

           :return: (:class:`ldns_rdf`) with the signers name or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_signame(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def rrsig_typecovered(self):
        """
           Returns the type covered of a LDNS_RR_TYPE_RRSIG rr.

           :return: (:class:`ldns_rdf`) with the type covered or None
               on failure.
        """
        return _ldns._ldns_rr_rrsig_typecovered(self)
    #parameters: const ldns_rr *,
    #retvals: ldns_rdf *

    def set_class(self, rr_class):
        """
           Sets the class in the rr.

           :param rr_class: Set to this class.
           :type rr_class: int
           :throws TypeError: when `rr_class` of non-integer type.
        """
        _ldns.ldns_rr_set_class(self, rr_class)
    #parameters: ldns_rr *, ldns_rr_class,
    #retvals: 

    def set_owner(self, owner):
        """
           Sets the owner in the rr structure.

           :param owner: Owner name.
           :type owner: :class:`ldns_dname`
           :throws TypeError: when `owner` of non-:class:`ldns_dname` type.

           .. note::
               The type checking of `owner` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(owner, ldns_dname)) and \
           isinstance(owner, ldns_rdf) and \
           owner.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_rr.new_frm_str() method will" +
                " drop the possibility to accept ldns_rdf as owner." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        _ldns._ldns_rr_set_owner(self, owner)
    #parameters: ldns_rr *, ldns_rdf *,
    #retvals:

    def set_question(self, question):
        """
           Sets the question flag in the rr structure.

           :param question: Question flag.
           :type question: bool
        """
        _ldns.ldns_rr_set_question(self, question)
    #parameters: ldns_rr *, bool,
    #retvals:

    def set_rd_count(self, count):
        """
           Sets the rd_count in the rr.

           :param count: Set to this count.
           :type count: positive int
           :throws TypeError: when `count` of non-integer type.
        """
        _ldns.ldns_rr_set_rd_count(self, count)
    #parameters: ldns_rr *, size_t,
    #retvals: 

    def set_rdf(self, f, position):
        """
           Sets a rdf member, it will be set on the position given.

           The old value is returned, like pop.

           :param f: The rdf to be set.
           :type f: :class:`ldns_rdf`
           :param position: The position the set the rdf.
           :type position: positive int
           :throws TypeError: when mismatching types passed.
           :return: (:class:`ldns_rdf`) the old value in the rr, None
               on failure.
        """
        return _ldns._ldns_rr_set_rdf(self, f, position)
    #parameters: ldns_rr *, const ldns_rdf *, size_t,
    #retvals: ldns_rdf *

    def set_ttl(self, ttl):
        """
           Sets the ttl in the rr structure.

           :param ttl: Set to this ttl.
           :type ttl: positive int
           :throws TypeError: when `ttl` of non-integer type.
        """
        _ldns.ldns_rr_set_ttl(self, ttl)
    #parameters: ldns_rr *, uint32_t,
    #retvals: 

    def set_type(self, rr_type):
        """
           Sets the type in the rr.

           :param rr_type: Set to this type.
           :type rr_type: ineteger
           :throws TypeError: when `rr_type` of non-integer type.
        """
        _ldns.ldns_rr_set_type(self, rr_type)
    #parameters: ldns_rr *, ldns_rr_type,
    #retvals:

    def to_canonical(self):
        """
           Converts each dname in a rr to its canonical form.
        """
        _ldns.ldns_rr2canonical(self)

    def ttl(self):
        """
           Returns the ttl of an rr structure.

           :return: (int) the ttl of the rr.
        """
        return _ldns.ldns_rr_ttl(self)
    #parameters: const ldns_rr *,
    #retvals: uint32_t

    @staticmethod
    def type_by_name(string):
        """
           Retrieves a rr type identifier value by looking up its name.

           Returns 0 if invalid name passed.

           :param string: RR type name.
           :type string: str
           :throws TypeError: when `string` of inappropriate type.
           :return: (int) RR type identifier, or 0 if no matching value
               to identifier found.
        """
        return _ldns.ldns_get_rr_type_by_name(string)

    def uncompressed_size(self):
        """
           Calculates the uncompressed size of an RR.

           :return: (inetger) size of the rr.
        """
        return _ldns.ldns_rr_uncompressed_size(self)
    #parameters: const ldns_rr *,
    #retvals: size_t

    #
    # _LDNS_RR_METHODS
    #

ldns_rr_swigregister = _ldns.ldns_rr_swigregister
ldns_rr_swigregister(ldns_rr)

class ldns_rr_list(_object):
    """
    List of Resource Records.

    This class contains a list of RR's (see :class:`ldns.ldns_rr`).

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_rr_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_rr_list, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_rr_count"] = _ldns.ldns_rr_list__rr_count_set
    __swig_getmethods__["_rr_count"] = _ldns.ldns_rr_list__rr_count_get
    if _newclass:
        _rr_count = _swig_property(_ldns.ldns_rr_list__rr_count_get, _ldns.ldns_rr_list__rr_count_set)
    __swig_setmethods__["_rr_capacity"] = _ldns.ldns_rr_list__rr_capacity_set
    __swig_getmethods__["_rr_capacity"] = _ldns.ldns_rr_list__rr_capacity_get
    if _newclass:
        _rr_capacity = _swig_property(_ldns.ldns_rr_list__rr_capacity_get, _ldns.ldns_rr_list__rr_capacity_set)

    def __init__(self):
        self.this = _ldns.ldns_rr_list_new()
        if not self.this:
            raise Exception("Can't create new RR_LIST")

    __swig_destroy__ = _ldns._ldns_rr_list_deep_free

    #
    # LDNS_RR_LIST_CONSTRUCTORS_
    #

    @staticmethod
    def new(raiseException=True):
        """
           Creates an empty RR List object.

           :param raiseException: Set to True if an exception should
               signal an error.
           :type raiseException: bool
           :throws Exception: when `raiseException` is True and error
               occurs.
           :return: :class:`ldns_rr_list` Empty RR list.
        """
        rrl = _ldns.ldns_rr_list_new()
        if (not rrl) and raiseException:
            raise Exception("Can't create RR List.")
        return rrl

    @staticmethod
    def new_frm_file(filename="/etc/hosts", raiseException=True):
        """
           Creates an RR List object from file content.

           Goes through a file and returns a rr list containing
           all the defined hosts in there.

           :param filename: The filename to use.
           :type filename: str
           :param raiseException: Set to True if an exception should
               signal an error.
           :type raiseException: bool
           :throws TypeError: when `filename` of inappropriate type.
           :throws Exception: when `raiseException` is True and error
               occurs.
           :return: RR List object or None. If the object can't be
               created and `raiseException` is True, an exception occurs.

           **Usage**

           >>> alist = ldns.ldns_rr_list.new_frm_file()
           >>> print alist
           localhost.	3600	IN	A	127.0.0.1
           ...

        """
        rr = _ldns.ldns_get_rr_list_hosts_frm_file(filename)
        if (not rr) and (raiseException):
            raise Exception("Can't create RR List.")
        return rr

    #
    # _LDNS_RR_LIST_CONSTRUCTORS
    #

    def __str__(self):
        """
           Converts a list of resource records to presentation format.

           :return: (str) Presentation format.
        """
        return _ldns.ldns_rr_list2str(self)

    def print_to_file(self, output):
        """
           Print a rr_list to output.

           :param output: Opened file to print to.
           :throws TypeError: when `output` of inappropriate type.
        """
        _ldns.ldns_rr_list_print(output, self)


    def to_canonical(self):
        """
           Converts each dname in each rr in a rr_list to its canonical
           form.
        """
        _ldns.ldns_rr_list2canonical(self)
    #parameters: ldns_rr_list *,
    #retvals: 

    def rrs(self):
        """
           Returns a generator object of a list of rr records.

           :return: (generator) generator object.
        """
        for i in range(0, self.rr_count()):
            yield self.rr(i)

    def is_rrset(self):
        """
           Checks if the rr list is a rr set.

           :return: (bool) True if rr list is a rr set.
        """
        return _ldns.ldns_is_rrset(self)

    def __cmp__(self, rrl2):
        """
           Compares two rr lists.

           :param rrl2: The second one.
           :type rrl2: :class:`ldns_rr_list`
           :throws TypeError: when `rrl2` of non-:class:`ldns_rr_list`
               type.
           :return: (int) 0 if equal, -1 if this list comes before
               `rrl2`, 1 if `rrl2` comes before this list.
        """
        return _ldns.ldns_rr_list_compare(self, rrl2)

    def __lt__(self, other):
        """
           Compares two rr lists.

           :param other: The second one.
           :type other: :class:`ldns_rr_list`
           :throws TypeError: when `other` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True when `self` is less than 'other'.
        """
        return _ldns.ldns_rr_list_compare(self, other) == -1

    def __le__(self, other):
        """
           Compares two rr lists.

           :param other: The second one.
           :type other: :class:`ldns_rr_list`
           :throws TypeError: when `other` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True when `self` is less than or equal to
               'other'.
        """
        return _ldns.ldns_rr_list_compare(self, other) != 1

    def __eq__(self, other):
        """
           Compares two rr lists.

           :param other: The second one.
           :type other: :class:`ldns_rr_list`
           :throws TypeError: when `other` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True when `self` is equal to 'other'.
        """
        return _ldns.ldns_rr_list_compare(self, other) == 0

    def __ne__(self, other):
        """
           Compares two rr lists.

           :param other: The second one.
           :type other: :class:`ldns_rr_list`
           :throws TypeError: when `other` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True when `self` is not equal to 'other'.
        """
        return _ldns.ldns_rr_list_compare(self, other) != 0

    def __gt__(self, other):
        """
           Compares two rr lists.

           :param other: The second one.
           :type other: :class:`ldns_rr_list`
           :throws TypeError: when `other` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True when `self` is greater than 'other'.
        """
        return _ldns.ldns_rr_list_compare(self, other) == 1

    def __ge__(self, other):
        """
           Compares two rr lists.

           :param other: The second one.
           :type other: :class:`ldns_rr_list`
           :throws TypeError: when `other` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True when `self` is greater than or equal to
               'other'.
        """
        return _ldns.ldns_rr_list_compare(self, other) != -1

    def write_to_buffer(self, buffer):
        """
           Copies the rr_list data to the buffer in wire format.

           :param buffer: Output buffer to append the result to.
           :type buffer: :class:`ldns_buffer`
           :throws TypeError: when `buffer` of non-:class:`ldns_buffer`
               type.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rr_list2buffer_wire(buffer, self)

    #
    # LDNS_RR_LIST_METHODS_
    #

    def cat(self, right):
        """
           Concatenates two ldns_rr_lists together.

           This modifies rr list (to extend it and adds RRs from right).

           :param right: The right-hand side.
           :type right: :class:`ldns_rr_list`
           :throws TypeError: when `right` of non-:class:`ldns_rr_list`
               type.
           :return: (bool) True if success.
        """
        return _ldns._ldns_rr_list_cat(self, right)
    #parameters: ldns_rr_list *, ldns_rr_list *,
    #retvals: bool

    def cat_clone(self, right):
        """
           Concatenates two ldns_rr_lists together, creates a new list
           of the rr's (instead of appending the content to an existing
           list).

           :param right: The right-hand side.
           :type right: :class:`ldns_rr_list`
           :throws TypeError: when `right` of non-:class:`ldns_rr_list`
               type.
           :return: (:class:`ldns_rr_list`) rr list with left-hand side +
               right-hand side concatenated, on None on error.
        """
        return _ldns.ldns_rr_list_cat_clone(self, right)
    #parameters: ldns_rr_list *, ldns_rr_list *,
    #retvals: ldns_rr_list *

    def clone(self):
        """
           Clones an rrlist.

           :return: (:class:`ldns_rr_list`) the cloned rr list,
               or None on error.
        """
        return _ldns.ldns_rr_list_clone(self)
    #parameters: const ldns_rr_list *,
    #retvals: ldns_rr_list *

    def contains_rr(self, rr):
        """
           Returns True if the given rr is one of the rrs in the list,
           or if it is equal to one.

           :param rr: The rr to check.
           :type rr: :class:`ldns_rr`
           :throws TypeError: when `rr` of non-:class:`ldns_rr` type.
           :return: (bool) True if rr_list contains `rr`, False otherwise.
        """
        return _ldns.ldns_rr_list_contains_rr(self, rr)
    #parameters: const ldns_rr_list *, ldns_rr *,
    #retvals: bool

    def owner(self):
        """
           Returns the owner domain name rdf of the first element of
           the RR. If there are no elements present, None is returned.

           :return: (:class:`ldns_dname`) dname of the first element,
               or None if the list is empty.
        """
        rdf = _ldns._ldns_rr_list_owner(self)
        if rdf:
            rdf = ldns_dname(rdf, clone=False)
        return rdf
    #parameters: const ldns_rr_list *,
    #retvals: ldns_rdf *

    def pop_rr(self):
        """
           Pops the last rr from an rrlist.

           :return: (:class:`ldns_rr`) None if nothing to pop.
               Otherwise the popped RR.
        """
        rr = _ldns.ldns_rr_list_pop_rr(self)
        return rr
    #parameters: ldns_rr_list *,
    #retvals: ldns_rr *

    def pop_rr_list(self, size):
        """
           Pops an rr_list of size s from an rrlist.

           :param size: The number of rr's to pop.
           :type size: positive int
           :throws TypeError: when `size` of inappropriate type.
           :return: (:class:`ldns_rr_list`) None if nothing to pop.
               Otherwise the popped rr list.
        """
        return _ldns.ldns_rr_list_pop_rr_list(self, size)
    #parameters: ldns_rr_list *, size_t,
    #retvals: ldns_rr_list *

    def pop_rrset(self):
        """
           Pops the first rrset from the list, the list must be sorted,
           so that all rr's from each rrset are next to each other.

           :return: (:class:`ldns_rr_list`) the first rrset, or None when
               empty.
        """
        return _ldns.ldns_rr_list_pop_rrset(self)
    #parameters: ldns_rr_list *,
    #retvals: ldns_rr_list *

    def push_rr(self, rr):
        """
           Pushes an rr to an rrlist.

           :param rr: The rr to push.
           :type rr: :class:`ldns_rr`
           :throws TypeError: when `rr` of non-:class:`ldns_rr` type.
           :return: (bool) False on error, otherwise True.
        """
        return _ldns._ldns_rr_list_push_rr(self, rr)
    #parameters: ldns_rr_list *, const ldns_rr *,
    #retvals: bool

    def push_rr_list(self, push_list):
        """
           Pushes an rr list to an rr list.

           :param push_list: The rr_list to push.
           :type push_list: :class:`ldns_rr_list`
           :throws TypeError: when `push_list` of non-:class:`ldns_rr_list`
               type.
           :returns: (bool) False on error, otherwise True.
        """
        return _ldns._ldns_rr_list_push_rr_list(self, push_list)
    #parameters: ldns_rr_list *, const ldns_rr_list *,
    #retvals: bool

    def rr(self, nr):
        """
           Returns a specific rr of an rrlist.

           :param nr: Index of the desired rr.
           :type nr: positive int
           :throws TypeError: when `nr` of inappropriate type.
           :return: (:class:`ldns_rr`) The rr at position `nr`, or None
               if failed.
        """
        return _ldns._ldns_rr_list_rr(self, nr)
    #parameters: const ldns_rr_list *, size_t,
    #retvals: ldns_rr *

    def rr_count(self):
        """
           Returns the number of rr's in an rr_list.

           :return: (int) The number of rr's.
        """
        return _ldns.ldns_rr_list_rr_count(self)
    #parameters: const ldns_rr_list *,
    #retvals: size_t

    def set_rr(self, r, idx):
        """
           Set a rr on a specific index in a ldns_rr_list.

           :param r: The rr to set.
           :type r: :class:`ldns_rr`
           :param idx: Index into the rr_list.
           :type idx: positive int
           :throws TypeError: when parameters of inappropriate types.
           :return: (:class:`ldns_rr`) the old rr which was stored in
               the rr_list, or None if the index was too large
               to set a specific rr.
        """
        return _ldns._ldns_rr_list_set_rr(self, r, idx)
    #parameters: ldns_rr_list *, const ldns_rr *, size_t,
    #retvals: ldns_rr *

    def set_rr_count(self, count):
        """
           Sets the number of rr's in an rr_list.

           :param count: The number of rr in this list.
           :type count: positive int
           :throws TypeError: when `count` of non-integer type.
           :throws Exception: when `count` out of acceptable range.

           .. warning::
               Don't use this method unless you really know what you
               are doing.
        """
    # The function C has a tendency to generate an assertion fail when 
    # the count exceeds the list's capacity -- therefore the checking
    # code.
        if isinstance(count, int) and \
           ((count < 0) or (count > self._rr_capacity)):
            raise Exception("Given count %d is out of range " % (count) +
                "of the rr list's capacity %d." % (self._rr_capacity))
        _ldns.ldns_rr_list_set_rr_count(self, count)
    #parameters: ldns_rr_list *, size_t,
    #retvals: 

    def sort(self):
        """
           Sorts an rr_list (canonical wire format).
        """
        _ldns.ldns_rr_list_sort(self)
    #parameters: ldns_rr_list *,
    #retvals: 

    def subtype_by_rdf(self, r, pos):
        """
           Return the rr_list which matches the rdf at position field.

           Think type-covered stuff for RRSIG.

           :param r: The rdf to use for the comparison.
           :type r: :class:`ldns_rdf`
           :param pos: At which position we can find the rdf.
           :type pos: positive int
           :throws TypeError: when parameters of inappropriate types.
           :return: (:class:`ldns_rr_list`) a new rr list with only
               the RRs that match, or None when nothing matches.
        """
        return _ldns.ldns_rr_list_subtype_by_rdf(self, r, pos)
    #parameters: ldns_rr_list *, ldns_rdf *, size_t,
    #retvals: ldns_rr_list *

    def type(self):
        """
           Returns the type of the first element of the RR.

           If there are no elements present, 0 is returned.

           :return: (int) rr_type of the first element,
               or 0 if the list is empty.
        """
        return _ldns.ldns_rr_list_type(self)
    #parameters: const ldns_rr_list *,
    #retvals: ldns_rr_type

    #
    # _LDNS_RR_LIST_METHODS
    #

ldns_rr_list_swigregister = _ldns.ldns_rr_list_swigregister
ldns_rr_list_swigregister(ldns_rr_list)

class ldns_rr_descriptor(_object):
    """
    Resource Record descriptor.

    This structure contains, for all rr types, the rdata fields that are defined.

    In order to create a class instance use :meth:`ldns_rr_descriptor`.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_rr_descriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_rr_descriptor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_type"] = _ldns.ldns_rr_descriptor__type_set
    __swig_getmethods__["_type"] = _ldns.ldns_rr_descriptor__type_get
    if _newclass:
        _type = _swig_property(_ldns.ldns_rr_descriptor__type_get, _ldns.ldns_rr_descriptor__type_set)
    __swig_getmethods__["_name"] = _ldns.ldns_rr_descriptor__name_get
    if _newclass:
        _name = _swig_property(_ldns.ldns_rr_descriptor__name_get)
    __swig_setmethods__["_minimum"] = _ldns.ldns_rr_descriptor__minimum_set
    __swig_getmethods__["_minimum"] = _ldns.ldns_rr_descriptor__minimum_get
    if _newclass:
        _minimum = _swig_property(_ldns.ldns_rr_descriptor__minimum_get, _ldns.ldns_rr_descriptor__minimum_set)
    __swig_setmethods__["_maximum"] = _ldns.ldns_rr_descriptor__maximum_set
    __swig_getmethods__["_maximum"] = _ldns.ldns_rr_descriptor__maximum_get
    if _newclass:
        _maximum = _swig_property(_ldns.ldns_rr_descriptor__maximum_get, _ldns.ldns_rr_descriptor__maximum_set)
    __swig_setmethods__["_wireformat"] = _ldns.ldns_rr_descriptor__wireformat_set
    __swig_getmethods__["_wireformat"] = _ldns.ldns_rr_descriptor__wireformat_get
    if _newclass:
        _wireformat = _swig_property(_ldns.ldns_rr_descriptor__wireformat_get, _ldns.ldns_rr_descriptor__wireformat_set)
    __swig_setmethods__["_variable"] = _ldns.ldns_rr_descriptor__variable_set
    __swig_getmethods__["_variable"] = _ldns.ldns_rr_descriptor__variable_get
    if _newclass:
        _variable = _swig_property(_ldns.ldns_rr_descriptor__variable_get, _ldns.ldns_rr_descriptor__variable_set)
    __swig_setmethods__["_compress"] = _ldns.ldns_rr_descriptor__compress_set
    __swig_getmethods__["_compress"] = _ldns.ldns_rr_descriptor__compress_get
    if _newclass:
        _compress = _swig_property(_ldns.ldns_rr_descriptor__compress_get, _ldns.ldns_rr_descriptor__compress_set)
    __swig_setmethods__["_dname_count"] = _ldns.ldns_rr_descriptor__dname_count_set
    __swig_getmethods__["_dname_count"] = _ldns.ldns_rr_descriptor__dname_count_get
    if _newclass:
        _dname_count = _swig_property(_ldns.ldns_rr_descriptor__dname_count_get, _ldns.ldns_rr_descriptor__dname_count_set)

    def __init__(self, rr_type):
        """
           Returns the resource record descriptor for the given type.

           :param rr_type: RR type. 
           :type rr_type: int
           :throws TypeError: when `rr_type` of inappropriate type.
           :return: (:class:`ldns_rr_descriptor`) RR descriptor class.
        """
        self.this = self.ldns_rr_descriptor(rr_type)

    def __str__(self):
        raise Exception("The content of this class cannot be printed.")

    __swig_destroy__ = _ldns.ldns_rr_descriptor_dummy_free

    #
    # LDNS_RR_DESCRIPTOR_CONSTRUCTORS_
    #

    @staticmethod
    def ldns_rr_descriptor(rr_type):
        """
           Returns the resource record descriptor for the given type.

           :param rr_type: RR type. 
           :type rr_type: int
           :throws TypeError: when `rr_type` of inappropriate type.
           :return: (:class:`ldns_rr_descriptor`) RR descriptor class.
        """
        return _ldns.ldns_rr_descript(rr_type)
    #parameters: uint16_t
    #retvals: const ldns_rr_descriptor *

    #
    # _LDNS_RR_DESCRIPTOR_CONSTRUCTORS
    #

    #
    # LDNS_RR_DESCRIPTOR_METHODS_
    #

    def field_type(self, field):
        """
           Returns the rdf type for the given rdata field number of the
           rr type for the given descriptor.

           :param field: The field number.
           :type field: positive int
           :throws TypeError: when `field` of non-inetger type.
           :return: (int) the rdf type for the field.
        """
        return _ldns.ldns_rr_descriptor_field_type(self, field)
    #parameters: const ldns_rr_descriptor *, size_t,
    #retvals: ldns_rdf_type

    def maximum(self):
        """
           Returns the maximum number of rdata fields of the rr type this
           descriptor describes.

           :return: (int) the maximum number of rdata fields.
        """
        return _ldns.ldns_rr_descriptor_maximum(self)
    #parameters: const ldns_rr_descriptor *,
    #retvals: size_t

    def minimum(self):
        """
           Returns the minimum number of rdata fields of the rr type this
           descriptor describes.

           :return: (int) the minimum number of rdata fields.
        """
        return _ldns.ldns_rr_descriptor_minimum(self)
    #parameters: const ldns_rr_descriptor *,
    #retvals: size_t

    #
    # _LDNS_RR_DESCRIPTOR_METHODS
    #

ldns_rr_descriptor_swigregister = _ldns.ldns_rr_descriptor_swigregister
ldns_rr_descriptor_swigregister(ldns_rr_descriptor)


def ldns_rdf_bitmap_known_rr_types_space(rdf):
    return _ldns.ldns_rdf_bitmap_known_rr_types_space(rdf)
ldns_rdf_bitmap_known_rr_types_space = _ldns.ldns_rdf_bitmap_known_rr_types_space

def ldns_rdf_bitmap_known_rr_types(rdf):
    return _ldns.ldns_rdf_bitmap_known_rr_types(rdf)
ldns_rdf_bitmap_known_rr_types = _ldns.ldns_rdf_bitmap_known_rr_types

def ldns_rr_new():
    return _ldns.ldns_rr_new()
ldns_rr_new = _ldns.ldns_rr_new

def ldns_rr_new_frm_type(t):
    return _ldns.ldns_rr_new_frm_type(t)
ldns_rr_new_frm_type = _ldns.ldns_rr_new_frm_type

def _ldns_rr_free(rr):
    return _ldns._ldns_rr_free(rr)
_ldns_rr_free = _ldns._ldns_rr_free

def _ldns_rr_new_frm_str(str, default_ttl, origin, prev):
    return _ldns._ldns_rr_new_frm_str(str, default_ttl, origin, prev)
_ldns_rr_new_frm_str = _ldns._ldns_rr_new_frm_str

def ldns_rr_new_question_frm_str(str, origin, prev):
    return _ldns.ldns_rr_new_question_frm_str(str, origin, prev)
ldns_rr_new_question_frm_str = _ldns.ldns_rr_new_question_frm_str

def _ldns_rr_new_frm_fp(fp, origin, prev):
    return _ldns._ldns_rr_new_frm_fp(fp, origin, prev)
_ldns_rr_new_frm_fp = _ldns._ldns_rr_new_frm_fp

def _ldns_rr_new_frm_fp_l(fp, origin, prev):
    return _ldns._ldns_rr_new_frm_fp_l(fp, origin, prev)
_ldns_rr_new_frm_fp_l = _ldns._ldns_rr_new_frm_fp_l

def __ldns_rr_set_owner(rr, owner):
    return _ldns.__ldns_rr_set_owner(rr, owner)
__ldns_rr_set_owner = _ldns.__ldns_rr_set_owner

def ldns_rr_set_question(rr, question):
    return _ldns.ldns_rr_set_question(rr, question)
ldns_rr_set_question = _ldns.ldns_rr_set_question

def ldns_rr_set_ttl(rr, ttl):
    return _ldns.ldns_rr_set_ttl(rr, ttl)
ldns_rr_set_ttl = _ldns.ldns_rr_set_ttl

def ldns_rr_set_rd_count(rr, count):
    return _ldns.ldns_rr_set_rd_count(rr, count)
ldns_rr_set_rd_count = _ldns.ldns_rr_set_rd_count

def ldns_rr_set_type(rr, rr_type):
    return _ldns.ldns_rr_set_type(rr, rr_type)
ldns_rr_set_type = _ldns.ldns_rr_set_type

def ldns_rr_set_class(rr, rr_class):
    return _ldns.ldns_rr_set_class(rr, rr_class)
ldns_rr_set_class = _ldns.ldns_rr_set_class

def __ldns_rr_set_rdf(rr, f, position):
    return _ldns.__ldns_rr_set_rdf(rr, f, position)
__ldns_rr_set_rdf = _ldns.__ldns_rr_set_rdf

def __ldns_rr_push_rdf(rr, f):
    return _ldns.__ldns_rr_push_rdf(rr, f)
__ldns_rr_push_rdf = _ldns.__ldns_rr_push_rdf

def ldns_rr_pop_rdf(rr):
    return _ldns.ldns_rr_pop_rdf(rr)
ldns_rr_pop_rdf = _ldns.ldns_rr_pop_rdf

def __ldns_rr_rdf(rr, nr):
    return _ldns.__ldns_rr_rdf(rr, nr)
__ldns_rr_rdf = _ldns.__ldns_rr_rdf

def __ldns_rr_owner(rr):
    return _ldns.__ldns_rr_owner(rr)
__ldns_rr_owner = _ldns.__ldns_rr_owner

def ldns_rr_is_question(rr):
    return _ldns.ldns_rr_is_question(rr)
ldns_rr_is_question = _ldns.ldns_rr_is_question

def ldns_rr_ttl(rr):
    return _ldns.ldns_rr_ttl(rr)
ldns_rr_ttl = _ldns.ldns_rr_ttl

def ldns_rr_rd_count(rr):
    return _ldns.ldns_rr_rd_count(rr)
ldns_rr_rd_count = _ldns.ldns_rr_rd_count

def ldns_rr_get_type(rr):
    return _ldns.ldns_rr_get_type(rr)
ldns_rr_get_type = _ldns.ldns_rr_get_type

def ldns_rr_get_class(rr):
    return _ldns.ldns_rr_get_class(rr)
ldns_rr_get_class = _ldns.ldns_rr_get_class

def ldns_rr_list_rr_count(rr_list):
    return _ldns.ldns_rr_list_rr_count(rr_list)
ldns_rr_list_rr_count = _ldns.ldns_rr_list_rr_count

def ldns_rr_list_set_rr_count(rr_list, count):
    return _ldns.ldns_rr_list_set_rr_count(rr_list, count)
ldns_rr_list_set_rr_count = _ldns.ldns_rr_list_set_rr_count

def __ldns_rr_list_set_rr(rr_list, r, count):
    return _ldns.__ldns_rr_list_set_rr(rr_list, r, count)
__ldns_rr_list_set_rr = _ldns.__ldns_rr_list_set_rr

def __ldns_rr_list_rr(rr_list, nr):
    return _ldns.__ldns_rr_list_rr(rr_list, nr)
__ldns_rr_list_rr = _ldns.__ldns_rr_list_rr

def ldns_rr_list_new():
    return _ldns.ldns_rr_list_new()
ldns_rr_list_new = _ldns.ldns_rr_list_new

def _ldns_rr_list_free(rr_list):
    return _ldns._ldns_rr_list_free(rr_list)
_ldns_rr_list_free = _ldns._ldns_rr_list_free

def _ldns_rr_list_deep_free(rr_list):
    return _ldns._ldns_rr_list_deep_free(rr_list)
_ldns_rr_list_deep_free = _ldns._ldns_rr_list_deep_free

def __ldns_rr_list_cat(left, right):
    return _ldns.__ldns_rr_list_cat(left, right)
__ldns_rr_list_cat = _ldns.__ldns_rr_list_cat

def ldns_rr_list_cat_clone(left, right):
    return _ldns.ldns_rr_list_cat_clone(left, right)
ldns_rr_list_cat_clone = _ldns.ldns_rr_list_cat_clone

def __ldns_rr_list_push_rr(rr_list, rr):
    return _ldns.__ldns_rr_list_push_rr(rr_list, rr)
__ldns_rr_list_push_rr = _ldns.__ldns_rr_list_push_rr

def __ldns_rr_list_push_rr_list(rr_list, push_list):
    return _ldns.__ldns_rr_list_push_rr_list(rr_list, push_list)
__ldns_rr_list_push_rr_list = _ldns.__ldns_rr_list_push_rr_list

def ldns_rr_list_pop_rr(rr_list):
    return _ldns.ldns_rr_list_pop_rr(rr_list)
ldns_rr_list_pop_rr = _ldns.ldns_rr_list_pop_rr

def ldns_rr_list_pop_rr_list(rr_list, size):
    return _ldns.ldns_rr_list_pop_rr_list(rr_list, size)
ldns_rr_list_pop_rr_list = _ldns.ldns_rr_list_pop_rr_list

def ldns_rr_list_contains_rr(rr_list, rr):
    return _ldns.ldns_rr_list_contains_rr(rr_list, rr)
ldns_rr_list_contains_rr = _ldns.ldns_rr_list_contains_rr

def ldns_is_rrset(rr_list):
    return _ldns.ldns_is_rrset(rr_list)
ldns_is_rrset = _ldns.ldns_is_rrset

def ldns_rr_set_push_rr(rr_list, rr):
    return _ldns.ldns_rr_set_push_rr(rr_list, rr)
ldns_rr_set_push_rr = _ldns.ldns_rr_set_push_rr

def ldns_rr_set_pop_rr(rr_list):
    return _ldns.ldns_rr_set_pop_rr(rr_list)
ldns_rr_set_pop_rr = _ldns.ldns_rr_set_pop_rr

def ldns_rr_list_pop_rrset(rr_list):
    return _ldns.ldns_rr_list_pop_rrset(rr_list)
ldns_rr_list_pop_rrset = _ldns.ldns_rr_list_pop_rrset

def ldns_get_rr_type_by_name(name):
    return _ldns.ldns_get_rr_type_by_name(name)
ldns_get_rr_type_by_name = _ldns.ldns_get_rr_type_by_name

def ldns_get_rr_class_by_name(name):
    return _ldns.ldns_get_rr_class_by_name(name)
ldns_get_rr_class_by_name = _ldns.ldns_get_rr_class_by_name

def ldns_rr_clone(rr):
    return _ldns.ldns_rr_clone(rr)
ldns_rr_clone = _ldns.ldns_rr_clone

def ldns_rr_list_clone(rrlist):
    return _ldns.ldns_rr_list_clone(rrlist)
ldns_rr_list_clone = _ldns.ldns_rr_list_clone

def ldns_rr_list_sort(unsorted):
    return _ldns.ldns_rr_list_sort(unsorted)
ldns_rr_list_sort = _ldns.ldns_rr_list_sort

def ldns_rr_compare(rr1, rr2):
    return _ldns.ldns_rr_compare(rr1, rr2)
ldns_rr_compare = _ldns.ldns_rr_compare

def ldns_rr_compare_no_rdata(rr1, rr2):
    return _ldns.ldns_rr_compare_no_rdata(rr1, rr2)
ldns_rr_compare_no_rdata = _ldns.ldns_rr_compare_no_rdata

def ldns_rr_compare_wire(rr1_buf, rr2_buf):
    return _ldns.ldns_rr_compare_wire(rr1_buf, rr2_buf)
ldns_rr_compare_wire = _ldns.ldns_rr_compare_wire

def ldns_rr_compare_ds(rr1, rr2):
    return _ldns.ldns_rr_compare_ds(rr1, rr2)
ldns_rr_compare_ds = _ldns.ldns_rr_compare_ds

def ldns_rr_list_compare(rrl1, rrl2):
    return _ldns.ldns_rr_list_compare(rrl1, rrl2)
ldns_rr_list_compare = _ldns.ldns_rr_list_compare

def ldns_rr_uncompressed_size(r):
    return _ldns.ldns_rr_uncompressed_size(r)
ldns_rr_uncompressed_size = _ldns.ldns_rr_uncompressed_size

def ldns_rr2canonical(rr):
    return _ldns.ldns_rr2canonical(rr)
ldns_rr2canonical = _ldns.ldns_rr2canonical

def ldns_rr_list2canonical(rr_list):
    return _ldns.ldns_rr_list2canonical(rr_list)
ldns_rr_list2canonical = _ldns.ldns_rr_list2canonical

def ldns_rr_label_count(rr):
    return _ldns.ldns_rr_label_count(rr)
ldns_rr_label_count = _ldns.ldns_rr_label_count

def ldns_rr_descript(type):
    return _ldns.ldns_rr_descript(type)
ldns_rr_descript = _ldns.ldns_rr_descript

def ldns_rr_descriptor_minimum(descriptor):
    return _ldns.ldns_rr_descriptor_minimum(descriptor)
ldns_rr_descriptor_minimum = _ldns.ldns_rr_descriptor_minimum

def ldns_rr_descriptor_maximum(descriptor):
    return _ldns.ldns_rr_descriptor_maximum(descriptor)
ldns_rr_descriptor_maximum = _ldns.ldns_rr_descriptor_maximum

def ldns_rr_descriptor_field_type(descriptor, field):
    return _ldns.ldns_rr_descriptor_field_type(descriptor, field)
ldns_rr_descriptor_field_type = _ldns.ldns_rr_descriptor_field_type

def ldns_rr_list_subtype_by_rdf(l, r, pos):
    return _ldns.ldns_rr_list_subtype_by_rdf(l, r, pos)
ldns_rr_list_subtype_by_rdf = _ldns.ldns_rr_list_subtype_by_rdf

def ldns_rdf2rr_type(rd):
    return _ldns.ldns_rdf2rr_type(rd)
ldns_rdf2rr_type = _ldns.ldns_rdf2rr_type

def ldns_rr_list_type(rr_list):
    return _ldns.ldns_rr_list_type(rr_list)
ldns_rr_list_type = _ldns.ldns_rr_list_type

def __ldns_rr_list_owner(rr_list):
    return _ldns.__ldns_rr_list_owner(rr_list)
__ldns_rr_list_owner = _ldns.__ldns_rr_list_owner

def Python_str_Check(o):
    return _ldns.Python_str_Check(o)
Python_str_Check = _ldns.Python_str_Check

def ldns_rdf_type2str(rdf):
    return _ldns.ldns_rdf_type2str(rdf)
ldns_rdf_type2str = _ldns.ldns_rdf_type2str

def ldns_rdf_data_as_bytearray(rdf):
    return _ldns.ldns_rdf_data_as_bytearray(rdf)
ldns_rdf_data_as_bytearray = _ldns.ldns_rdf_data_as_bytearray

def ldns_dnssec_zone_sign_defcb(zone, new_rrs, key_list, cbtype):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_sign_defcb(zone, new_rrs, key_list, cbtype)

def ldns_dnssec_zone_add_rr_(zone, rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_add_rr_(zone, rr)
LDNS_VERSION = _ldns.LDNS_VERSION
LDNS_REVISION = _ldns.LDNS_REVISION

def ldns_read_uint16(src):
    """LDNS buffer."""
    return _ldns.ldns_read_uint16(src)

def ldns_read_uint32(src):
    """LDNS buffer."""
    return _ldns.ldns_read_uint32(src)

def ldns_write_uint16(dst, data):
    """LDNS buffer."""
    return _ldns.ldns_write_uint16(dst, data)

def ldns_write_uint32(dst, data):
    """LDNS buffer."""
    return _ldns.ldns_write_uint32(dst, data)

def ldns_write_uint64_as_uint48(dst, data):
    """LDNS buffer."""
    return _ldns.ldns_write_uint64_as_uint48(dst, data)
class ldns_schwartzian_compare_struct(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_schwartzian_compare_struct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_schwartzian_compare_struct, name)
    __repr__ = _swig_repr
    __swig_setmethods__["original_object"] = _ldns.ldns_schwartzian_compare_struct_original_object_set
    __swig_getmethods__["original_object"] = _ldns.ldns_schwartzian_compare_struct_original_object_get
    if _newclass:
        original_object = _swig_property(_ldns.ldns_schwartzian_compare_struct_original_object_get, _ldns.ldns_schwartzian_compare_struct_original_object_set)
    __swig_setmethods__["transformed_object"] = _ldns.ldns_schwartzian_compare_struct_transformed_object_set
    __swig_getmethods__["transformed_object"] = _ldns.ldns_schwartzian_compare_struct_transformed_object_get
    if _newclass:
        transformed_object = _swig_property(_ldns.ldns_schwartzian_compare_struct_transformed_object_get, _ldns.ldns_schwartzian_compare_struct_transformed_object_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_schwartzian_compare_struct()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_schwartzian_compare_struct
    __del__ = lambda self: None
ldns_schwartzian_compare_struct_swigregister = _ldns.ldns_schwartzian_compare_struct_swigregister
ldns_schwartzian_compare_struct_swigregister(ldns_schwartzian_compare_struct)

class ldns_struct_lookup_table(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_lookup_table, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_lookup_table, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _ldns.ldns_struct_lookup_table_id_set
    __swig_getmethods__["id"] = _ldns.ldns_struct_lookup_table_id_get
    if _newclass:
        id = _swig_property(_ldns.ldns_struct_lookup_table_id_get, _ldns.ldns_struct_lookup_table_id_set)
    __swig_getmethods__["name"] = _ldns.ldns_struct_lookup_table_name_get
    if _newclass:
        name = _swig_property(_ldns.ldns_struct_lookup_table_name_get)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_lookup_table()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_lookup_table
    __del__ = lambda self: None
ldns_struct_lookup_table_swigregister = _ldns.ldns_struct_lookup_table_swigregister
ldns_struct_lookup_table_swigregister(ldns_struct_lookup_table)


def ldns_lookup_by_name(table, name):
    """LDNS buffer."""
    return _ldns.ldns_lookup_by_name(table, name)

def ldns_lookup_by_id(table, id):
    """LDNS buffer."""
    return _ldns.ldns_lookup_by_id(table, id)

def ldns_get_bit(bits, index):
    """LDNS buffer."""
    return _ldns.ldns_get_bit(bits, index)

def ldns_get_bit_r(bits, index):
    """LDNS buffer."""
    return _ldns.ldns_get_bit_r(bits, index)

def ldns_set_bit(byte, bit_nr, value):
    """LDNS buffer."""
    return _ldns.ldns_set_bit(byte, bit_nr, value)

def ldns_power(a, b):
    """LDNS buffer."""
    return _ldns.ldns_power(a, b)

def ldns_hexdigit_to_int(ch):
    """LDNS buffer."""
    return _ldns.ldns_hexdigit_to_int(ch)

def ldns_int_to_hexdigit(ch):
    """LDNS buffer."""
    return _ldns.ldns_int_to_hexdigit(ch)

def ldns_hexstring_to_data(data, str):
    """LDNS buffer."""
    return _ldns.ldns_hexstring_to_data(data, str)

def ldns_version():
    """LDNS buffer."""
    return _ldns.ldns_version()

def ldns_mktime_from_utc(tm):
    """LDNS buffer."""
    return _ldns.ldns_mktime_from_utc(tm)

def mktime_from_utc(tm):
    """LDNS buffer."""
    return _ldns.mktime_from_utc(tm)

def ldns_serial_arithmitics_gmtime_r(time, now, result):
    """LDNS buffer."""
    return _ldns.ldns_serial_arithmitics_gmtime_r(time, now, result)

def ldns_init_random(fd, size):
    """LDNS buffer."""
    return _ldns.ldns_init_random(fd, size)

def ldns_get_random():
    """LDNS buffer."""
    return _ldns.ldns_get_random()

def ldns_bubblebabble(data, len):
    """LDNS buffer."""
    return _ldns.ldns_bubblebabble(data, len)

def ldns_time(t):
    """LDNS buffer."""
    return _ldns.ldns_time(t)

def ldns_b32_ntop_calculate_size(src_data_length):
    """LDNS buffer."""
    return _ldns.ldns_b32_ntop_calculate_size(src_data_length)

def ldns_b32_ntop_calculate_size_no_padding(src_data_length):
    """LDNS buffer."""
    return _ldns.ldns_b32_ntop_calculate_size_no_padding(src_data_length)

def ldns_b32_ntop(src_data, src_data_length, target_text_buffer, target_text_buffer_size):
    """LDNS buffer."""
    return _ldns.ldns_b32_ntop(src_data, src_data_length, target_text_buffer, target_text_buffer_size)

def ldns_b32_ntop_extended_hex(src_data, src_data_length, target_text_buffer, target_text_buffer_size):
    """LDNS buffer."""
    return _ldns.ldns_b32_ntop_extended_hex(src_data, src_data_length, target_text_buffer, target_text_buffer_size)

def b32_ntop(src_data, src_data_length, target_text_buffer, target_text_buffer_size):
    """LDNS buffer."""
    return _ldns.b32_ntop(src_data, src_data_length, target_text_buffer, target_text_buffer_size)

def b32_ntop_extended_hex(src_data, src_data_length, target_text_buffer, target_text_buffer_size):
    """LDNS buffer."""
    return _ldns.b32_ntop_extended_hex(src_data, src_data_length, target_text_buffer, target_text_buffer_size)

def ldns_b32_pton_calculate_size(src_text_length):
    """LDNS buffer."""
    return _ldns.ldns_b32_pton_calculate_size(src_text_length)

def ldns_b32_pton(src_text, src_text_length, target_data_buffer, target_data_buffer_size):
    """LDNS buffer."""
    return _ldns.ldns_b32_pton(src_text, src_text_length, target_data_buffer, target_data_buffer_size)

def ldns_b32_pton_extended_hex(src_text, src_text_length, target_data_buffer, target_data_buffer_size):
    """LDNS buffer."""
    return _ldns.ldns_b32_pton_extended_hex(src_text, src_text_length, target_data_buffer, target_data_buffer_size)

def b32_pton(src_text, src_text_length, target_data_buffer, target_data_buffer_size):
    """LDNS buffer."""
    return _ldns.b32_pton(src_text, src_text_length, target_data_buffer, target_data_buffer_size)

def b32_pton_extended_hex(src_text, src_text_length, target_data_buffer, target_data_buffer_size):
    """LDNS buffer."""
    return _ldns.b32_pton_extended_hex(src_text, src_text_length, target_data_buffer, target_data_buffer_size)
LDNS_MIN_BUFLEN = _ldns.LDNS_MIN_BUFLEN
class ldns_buffer(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_buffer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_buffer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __init__(self, capacity):
        """
           Creates a new buffer with the specified capacity.

           :param capacity: Number of bytes to allocate for the buffer.
           :type capacity: integer
           :throws TypeError: When `capacity` of non-integer type.
           :return: (:class:`ldns_buffer`)
        """
        self.this = _ldns.ldns_buffer_new(capacity)

    __swig_destroy__ = _ldns._ldns_buffer_free

    def __str__(self):
        """
           Returns the data in the buffer as a string.
           Buffer data must be char * type.

           :return: string
        """
        return _ldns.ldns_buffer2str(self)

    def getc(self):
        """
           Returns the next character from a buffer.

           Advances the position pointer with 1. When end of buffer
           is reached returns EOF. This is the buffer's equivalent
           for getc().

           :return: (integer) EOF on failure otherwise return
               the character.
        """
        return _ldns.ldns_bgetc(self)

    #
    # LDNS_BUFFER_METHODS_
    #

    def at(self, at):
        """
           Returns a pointer to the data at the indicated position.

           :param at: position
           :type at: positive integer
           :throws TypeError: When `at` of non-integer type.
           :return: (uint8_t \*) The pointer to the data.
        """
        return _ldns.ldns_buffer_at(self, at)
    #parameters: const ldns_buffer *, size_t,
    #retvals: uint8_t *

    def available(self, count):
        """
           Checks whether the buffer has count bytes available at
           the current position.

           :param count: How much is available.
           :type count: integer
           :throws TypeError: When `count` of non-integer type.
           :return: (bool) True or False.
        """
        return _ldns.ldns_buffer_available(self, count) != 0
    #parameters: ldns_buffer *, size_t,
    #retvals: int

    def available_at(self, at, count):
        """
           Checks if the buffer has at least `count` more bytes available.

           Before reading or writing the caller needs to ensure that
           enough space is available!

           :param at: Indicated position.
           :type at: positive integer
           :param count: How much is available.
           :type count: positive integer
           :throws TypeError: When `at` or `count` of non-integer type.
           :return: (bool) True or False.
        """
        return _ldns.ldns_buffer_available_at(self, at, count) != 0
    #parameters: ldns_buffer *,size_t,size_t,
    #retvals: int

    def begin(self):
        """
           Returns a pointer to the beginning of the buffer
           (the data at position 0).

           :return: (uint8_t \*) Pointer.
        """
        return _ldns.ldns_buffer_begin(self)
    #parameters: const ldns_buffer *,
    #retvals: uint8_t *

    def capacity(self):
        """
           Returns the number of bytes the buffer can hold.

           :return: (size_t) The number of bytes.
        """
        return _ldns.ldns_buffer_capacity(self)
    #parameters: ldns_buffer *,
    #retvals: size_t

    def clear(self):
        """
           Clears the buffer and make it ready for writing.

           The buffer's limit is set to the capacity and the position
           is set to 0.
        """
        _ldns.ldns_buffer_clear(self)
    #parameters: ldns_buffer *,
    #retvals: 

    def copy(self, bfrom):
        """
           Copy contents of the other buffer to this buffer.

           Silently truncated if this buffer is too small.

           :param bfrom: Source buffer.
           :type bfrom: :class:`ldns_buffer`
           :throws TypeError: When `bfrom` of non-:class:`ldns_buffer`
               type.
        """
        _ldns.ldns_buffer_copy(self, bfrom)
    #parameters: ldns_buffer *, ldns_buffer *,
    #retvals: 

    def current(self):
        """
           Returns a pointer to the data at the buffer's current position.

           :return: (uint8_t \*) A pointer.
        """
        return _ldns.ldns_buffer_current(self)
    #parameters: ldns_buffer *,
    #retvals: uint8_t *

    def end(self):
        """
           Returns a pointer to the end of the buffer (the data
           at the buffer's limit).

           :return: (uint8_t \*) Pointer.
        """
        return _ldns.ldns_buffer_end(self)
    #parameters: ldns_buffer *,
    #retvals: uint8_t *

    def export(self):
        """
           Makes the buffer fixed and returns a pointer to the data.

           The caller is responsible for freeing the result.

           :return: (void \*) Void pointer.
        """
        return _ldns.ldns_buffer_export(self)
    #parameters: ldns_buffer *,
    #retvals: void *

    def flip(self):
        """
           Makes the buffer ready for reading the data that has been
           written to the buffer.

           The buffer's limit is set to the current position and
           the position is set to 0.
        """
        _ldns.ldns_buffer_flip(self)
    #parameters: ldns_buffer *,

    def invariant(self):
        """
           Performs no action.

           In debugging mode this method performs a buffer settings
           check. It asserts if something is wrong.
        """
        _ldns.ldns_buffer_invariant(self)
    #parameters: ldns_buffer *,

    def limit(self):
        """
           Returns the maximum size of the buffer.

           :return: (size_t) The size.
        """
        return _ldns.ldns_buffer_limit(self)
    #parameters: ldns_buffer *,
    #retvals: size_t

    def position(self):
        """
           Returns the current position in the buffer
           (as a number of bytes).

           :return: (size_t) The current position.
        """
        return _ldns.ldns_buffer_position(self)
    #parameters: ldns_buffer *,
    #retvals: size_t

    def printf(self, string, *args):
        """
           Prints to the buffer, increasing the capacity
           if required using buffer_reserve().

           The buffer's position is set to the terminating '\0'.
           Returns the number of characters written (not including
           the terminating '\0') or -1 on failure.

           :param string: A string to be written.
           :type string: string
           :throws: TypeError when `string` not a string.
           :return: (int) Number of written characters or -1 on failure.
        """
        data = string % args
        return _ldns.ldns_buffer_printf(self, data)
    #parameters: ldns_buffer *, const char *, ...
    #retvals: int

    def read(self, data, count):
        """
           Copies count bytes of data at the current position to the given
           `data`-array

           :param data: Target buffer to copy to.
           :type data: void \*
           :param count: The length of the data to copy.
           :type count: size_t
        """
        _ldns.ldns_buffer_read(self,data,count)
    #parameters: ldns_buffer *, void *, size_t,
    #retvals: 

    def read_at(self, at, data, count):
        """
           Copies count bytes of data at the given position to the
           given `data`-array.

           :param at: The position in the buffer to start reading.
           :type at: size_t
           :param data: Target buffer to copy to.
           :type data: void \*
           :param count: The length of the data to copy.
           :type count: size_t
        """
        _ldns.ldns_buffer_read_at(self,at,data,count)
    #parameters: ldns_buffer *, size_t, void *, size_t,
    #retvals: 

    def read_u16(self):
        """
           Returns the 2-byte integer value at the current position
           from the buffer.

           :return: (uint16_t) Word.
        """
        return _ldns.ldns_buffer_read_u16(self)
    #parameters: ldns_buffer *,
    #retvals: uint16_t

    def read_u16_at(self, at):
        """
           Returns the 2-byte integer value at the given position
           from the buffer.

           :param at: Position in the buffer.
           :type at: positive integer
           :throws TypeError: When `at` of non-integer type.
           :return: (uint16_t) Word.
        """
        return _ldns.ldns_buffer_read_u16_at(self, at)
    #parameters: ldns_buffer *, size_t,
    #retvals: uint16_t

    def read_u32(self):
        """
           Returns the 4-byte integer value at the current position
           from the buffer.

           :return: (uint32_t) Double-word.
        """
        return _ldns.ldns_buffer_read_u32(self)
    #parameters: ldns_buffer *,
    #retvals: uint32_t

    def read_u32_at(self, at):
        """
           Returns the 4-byte integer value at the given position
           from the buffer.

           :param at: Position in the buffer.
           :type at: positive integer
           :throws TypeError: When `at` of non-integer type.
           :return: (uint32_t) Double-word.
        """
        return _ldns.ldns_buffer_read_u32_at(self, at)
    #parameters: ldns_buffer *, size_t,
    #retvals: uint32_t

    def read_u8(self):
        """
           Returns the byte value at the current position from the buffer.

           :return: (uint8_t) A byte (not a character).
        """
        return _ldns.ldns_buffer_read_u8(self)
    #parameters: ldns_buffer *,
    #retvals: uint8_t

    def read_u8_at(self, at):
        """
           Returns the byte value at the given position from the buffer.

           :param at: The position in the buffer.
           :type at: positive integer
           :throws TypeError: When `at` of non-integer type.
           :return: (uint8_t) Byte value.
        """
        return _ldns.ldns_buffer_read_u8_at(self, at)
    #parameters: ldns_buffer *, size_t,
    #retvals: uint8_t

    def remaining(self):
        """
           Returns the number of bytes remaining between the buffer's
           position and limit.

           :return: (size_t) The number of bytes.
        """
        return _ldns.ldns_buffer_remaining(self)
    #parameters: ldns_buffer *,
    #retvals: size_t

    def remaining_at(self, at):
        """
           Returns the number of bytes remaining between the indicated
           position and the limit.

           :param at: Indicated position.
           :type at: positive integer
           :throws TypeError: When `at` of non-integer type.
           :return: (size_t) number of bytes
        """
        return _ldns.ldns_buffer_remaining_at(self, at)
    #parameters: ldns_buffer *,size_t,
    #retvals: size_t

    def reserve(self, amount):
        """
           Ensures that the buffer can contain at least `amount` more
           bytes.

           The buffer's capacity is increased if necessary using
           buffer_set_capacity().

           The buffer's limit is always set to the (possibly increased)
           capacity.

           :param amount: Amount to use.
           :type amount: positive integer
           :throws TypeError: When `amount` of non-integer type.
           :return: (bool) hether this failed or succeeded.
        """
        return _ldns.ldns_buffer_reserve(self, amount)
    #parameters: ldns_buffer *, size_t,
    #retvals: bool

    def rewind(self):
        """
           Make the buffer ready for re-reading the data.

           The buffer's position is reset to 0.
        """
        _ldns.ldns_buffer_rewind(self)
    #parameters: ldns_buffer *,
    #retvals: 

    def set_capacity(self, capacity):
        """
           Changes the buffer's capacity.

           The data is reallocated so any pointers to the data may become
           invalid. The buffer's limit is set to the buffer's new capacity.

           :param capacity: The capacity to use.
           :type capacity: positive integer
           :throws TypeError: When `capacity` of non-integer type.
           :return: (bool) whether this failed or succeeded
        """
        return _ldns.ldns_buffer_set_capacity(self, capacity)
    #parameters: ldns_buffer *, size_t,
    #retvals: bool

    def set_limit(self, limit):
        """
           Changes the buffer's limit.

           If the buffer's position is greater than the new limit
           then the position is set to the limit.

           :param limit: The new limit.
           :type limit: positive integer
           :throws TypeError: When `limit` of non-integer type.
        """
        _ldns.ldns_buffer_set_limit(self, limit)
    #parameters: ldns_buffer *, size_t,
    #retvals: 

    def set_position(self,mark):
        """
           Sets the buffer's position to `mark`.

           The position must be less than or equal to the buffer's limit.

           :param mark: The mark to use.
           :type mark: positive integer
           :throws TypeError: When `mark` of non-integer type.
        """
        _ldns.ldns_buffer_set_position(self,mark)
    #parameters: ldns_buffer *,size_t,
    #retvals: 

    def skip(self, count):
        """
           Changes the buffer's position by `count` bytes.

           The position must not be moved behind the buffer's limit or
           before the beginning of the buffer.

           :param count: The count to use.
           :type count: integer
           :throws TypeError: When `count` of non-integer type.
        """
        _ldns.ldns_buffer_skip(self, count)
    #parameters: ldns_buffer *, ssize_t,
    #retvals: 

    def status(self):
        """
           Returns the status of the buffer.

           :return: (ldns_status) The status.
        """
        return _ldns.ldns_buffer_status(self)
    #parameters: ldns_buffer *,
    #retvals: ldns_status

    def status_ok(self):
        """
           Returns True if the status of the buffer is LDNS_STATUS_OK,
           False otherwise.

           :return: (bool) True or False.
        """
        return _ldns.ldns_buffer_status_ok(self)
    #parameters: ldns_buffer *,
    #retvals: bool

    def write(self, data, count):
        """
           Writes count bytes of data to the current position of
           the buffer.

           :param data: The data to write.
           :type data: void \*
           :param count: The length of the data to write.
           :type count: size_t
        """
        _ldns.ldns_buffer_write(self, data, count)
    #parameters: ldns_buffer *, const void *, size_t,
    #retvals: 

    def write_at(self, at, data, count):
        """
           Writes the given data to the buffer at the specified position
           by `at`.

           :param at: The position (in number of bytes) to write the
               data at.
           :param data: Pointer to the data to write to the buffer.
           :param count: The number of bytes of data to write.
        """
        _ldns.ldns_buffer_write_at(self, at, data, count)
    #parameters: ldns_buffer *, size_t, const void *, size_t,
    #retvals: 

    def write_string(self, string):
        """
           Copies the given (null-delimited) string to the current
           position into the buffer.

           :param string: The string to write.
           :type string: string
           :throws TypeError: When `string` not a string.
        """
        _ldns.ldns_buffer_write_string(self,string)
    #parameters: ldns_buffer *,const char *,
    #retvals: 

    def write_string_at(self, at, string):
        """
           Copies the given (null-delimited) string to the specified
           position `at` into the buffer.

           :param at: The position in the buffer.
           :type at: positive integer
           :param string: The string to write.
           :type string: string
           :throws TypeError: When types mismatch.
        """
        _ldns.ldns_buffer_write_string_at(self, at, string)
    #parameters: ldns_buffer *, size_t, const char *,
    #retvals: 

    def write_u16(self, data):
        """Writes the given 2 byte integer at the current
           position in the buffer.

           :param data: The word to write.
           :type data: uint16_t
           :throws TypeError: When `data` of non-integer type.
        """
        _ldns.ldns_buffer_write_u16(self, data)
    #parameters: ldns_buffer *, uint16_t,
    #retvals: 

    def write_u16_at(self, at, data):
        """
           Writes the given 2 byte integer at the given position
           in the buffer.

           :param at: The position in the buffer.
           :type at: positive integer
           :param data: The word to write.
           :type data: uint16_t
           :throws TypeError: When `at` or `data` of non-integer type.
        """
        _ldns.ldns_buffer_write_u16_at(self,at,data)
    #parameters: ldns_buffer *,size_t,uint16_t,
    #retvals: 

    def write_u32(self, data):
        """
           Writes the given 4 byte integer at the current position
           in the buffer.

           :param data: The double-word to write.
           :type data: uint32_t
           :throws TypeError: When `data` of non-integer type.
        """
        _ldns.ldns_buffer_write_u32(self, data)
    #parameters: ldns_buffer *, uint32_t,
    #retvals: 

    def write_u32_at(self, at, data):
        """
           Writes the given 4 byte integer at the given position
           in the buffer.

           :param at: The position in the buffer.
           :type at: positive integer
           :param data: The double-word to write.
           :type data: uint32_t
           :throws TypeError: When `at` or `data` of non-integer type.
        """
        _ldns.ldns_buffer_write_u32_at(self, at, data)
    #parameters: ldns_buffer *,size_t,uint32_t,
    #retvals: 

    def write_u8(self, data):
        """
           Writes the given byte of data at the current position
           in the buffer.

           :param data: The byte to write.
           :type data: uint8_t
           :throws TypeError: When `data` of non-integer type.
        """
        _ldns.ldns_buffer_write_u8(self, data)
    #parameters: ldns_buffer *, uint8_t,
    #retvals: 

    def write_u8_at(self,at,data):
        """
           Writes the given byte of data at the given position
           in the buffer.

           :param at: The position in the buffer.
           :type at: positive integer
           :param data: The byte to write.
           :type data: uint8_t
           :throws TypeError: When `at` or `data` of non-integer type.
        """
        _ldns.ldns_buffer_write_u8_at(self,at,data)
    #parameters: ldns_buffer *,size_t,uint8_t,
    #retvals: 

    #
    # _LDNS_BUFFER_METHODS
    #

ldns_buffer_swigregister = _ldns.ldns_buffer_swigregister
ldns_buffer_swigregister(ldns_buffer)


def ldns_buffer_invariant(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_invariant(buffer)

def ldns_buffer_new(capacity):
    """LDNS buffer."""
    return _ldns.ldns_buffer_new(capacity)

def ldns_buffer_clear(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_clear(buffer)

def ldns_buffer_flip(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_flip(buffer)

def ldns_buffer_rewind(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_rewind(buffer)

def ldns_buffer_position(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_position(buffer)

def ldns_buffer_set_position(buffer, mark):
    """LDNS buffer."""
    return _ldns.ldns_buffer_set_position(buffer, mark)

def ldns_buffer_skip(buffer, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_skip(buffer, count)

def ldns_buffer_limit(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_limit(buffer)

def ldns_buffer_set_limit(buffer, limit):
    """LDNS buffer."""
    return _ldns.ldns_buffer_set_limit(buffer, limit)

def ldns_buffer_capacity(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_capacity(buffer)

def ldns_buffer_set_capacity(buffer, capacity):
    """LDNS buffer."""
    return _ldns.ldns_buffer_set_capacity(buffer, capacity)

def ldns_buffer_reserve(buffer, amount):
    """LDNS buffer."""
    return _ldns.ldns_buffer_reserve(buffer, amount)

def ldns_buffer_at(buffer, at):
    """LDNS buffer."""
    return _ldns.ldns_buffer_at(buffer, at)

def ldns_buffer_begin(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_begin(buffer)

def ldns_buffer_end(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_end(buffer)

def ldns_buffer_current(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_current(buffer)

def ldns_buffer_remaining_at(buffer, at):
    """LDNS buffer."""
    return _ldns.ldns_buffer_remaining_at(buffer, at)

def ldns_buffer_remaining(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_remaining(buffer)

def ldns_buffer_available_at(buffer, at, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_available_at(buffer, at, count)

def ldns_buffer_available(buffer, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_available(buffer, count)

def ldns_buffer_write_at(buffer, at, data, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_at(buffer, at, data, count)

def ldns_buffer_write(buffer, data, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write(buffer, data, count)

def ldns_buffer_write_string_at(buffer, at, str):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_string_at(buffer, at, str)

def ldns_buffer_write_string(buffer, str):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_string(buffer, str)

def ldns_buffer_write_u8_at(buffer, at, data):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_u8_at(buffer, at, data)

def ldns_buffer_write_u8(buffer, data):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_u8(buffer, data)

def ldns_buffer_write_u16_at(buffer, at, data):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_u16_at(buffer, at, data)

def ldns_buffer_write_u16(buffer, data):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_u16(buffer, data)

def ldns_buffer_write_u32_at(buffer, at, data):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_u32_at(buffer, at, data)

def ldns_buffer_write_u32(buffer, data):
    """LDNS buffer."""
    return _ldns.ldns_buffer_write_u32(buffer, data)

def ldns_buffer_read_at(buffer, at, data, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_at(buffer, at, data, count)

def ldns_buffer_read(buffer, data, count):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read(buffer, data, count)

def ldns_buffer_read_u8_at(buffer, at):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_u8_at(buffer, at)

def ldns_buffer_read_u8(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_u8(buffer)

def ldns_buffer_read_u16_at(buffer, at):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_u16_at(buffer, at)

def ldns_buffer_read_u16(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_u16(buffer)

def ldns_buffer_read_u32_at(buffer, at):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_u32_at(buffer, at)

def ldns_buffer_read_u32(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_read_u32(buffer)

def ldns_buffer_status(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_status(buffer)

def ldns_buffer_status_ok(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_status_ok(buffer)

def ldns_buffer_printf(buffer, format, arg1=None, arg2=None):
    """LDNS buffer."""
    return _ldns.ldns_buffer_printf(buffer, format, arg1, arg2)

def _ldns_buffer_free(buffer):
    """LDNS buffer."""
    return _ldns._ldns_buffer_free(buffer)

def ldns_buffer_export(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_export(buffer)

def ldns_buffer_copy(result, arg2):
    """LDNS buffer."""
    return _ldns.ldns_buffer_copy(result, arg2)
LDNS_MAX_KEYLEN = _ldns.LDNS_MAX_KEYLEN
LDNS_DNSSEC_KEYPROTO = _ldns.LDNS_DNSSEC_KEYPROTO
LDNS_DEFAULT_EXP_TIME = _ldns.LDNS_DEFAULT_EXP_TIME
LDNS_SIGNATURE_LEAVE_ADD_NEW = _ldns.LDNS_SIGNATURE_LEAVE_ADD_NEW
LDNS_SIGNATURE_LEAVE_NO_ADD = _ldns.LDNS_SIGNATURE_LEAVE_NO_ADD
LDNS_SIGNATURE_REMOVE_ADD_NEW = _ldns.LDNS_SIGNATURE_REMOVE_ADD_NEW
LDNS_SIGNATURE_REMOVE_NO_ADD = _ldns.LDNS_SIGNATURE_REMOVE_NO_ADD

def ldns_dnssec_get_rrsig_for_name_and_type(name, type, rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_get_rrsig_for_name_and_type(name, type, rrs)

def ldns_dnssec_get_dnskey_for_rrsig(rrsig, rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_get_dnskey_for_rrsig(rrsig, rrs)

def ldns_nsec_get_bitmap(nsec):
    """LDNS buffer."""
    return _ldns.ldns_nsec_get_bitmap(nsec)
LDNS_NSEC3_MAX_ITERATIONS = _ldns.LDNS_NSEC3_MAX_ITERATIONS

def ldns_dnssec_nsec3_closest_encloser(qname, qtype, nsec3s):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_nsec3_closest_encloser(qname, qtype, nsec3s)

def ldns_dnssec_pkt_has_rrsigs(pkt):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_pkt_has_rrsigs(pkt)

def ldns_dnssec_pkt_get_rrsigs_for_name_and_type(pkt, name, type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_pkt_get_rrsigs_for_name_and_type(pkt, name, type)

def ldns_dnssec_pkt_get_rrsigs_for_type(pkt, type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_pkt_get_rrsigs_for_type(pkt, type)

def ldns_calc_keytag(key):
    """LDNS buffer."""
    return _ldns.ldns_calc_keytag(key)

def ldns_calc_keytag_raw(key, keysize):
    """LDNS buffer."""
    return _ldns.ldns_calc_keytag_raw(key, keysize)

def ldns_key_rr2ds(key, h):
    """LDNS buffer."""
    return _ldns.ldns_key_rr2ds(key, h)

def ldns_dnssec_create_nsec_bitmap(rr_type_list, size, nsec_type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_create_nsec_bitmap(rr_type_list, size, nsec_type)

def ldns_dnssec_rrsets_contains_type(rrsets, type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_contains_type(rrsets, type)

def ldns_dnssec_create_nsec(arg1, to, nsec_type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_create_nsec(arg1, to, nsec_type)

def ldns_dnssec_create_nsec3(arg1, to, zone_name, algorithm, flags, iterations, salt_length, salt):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_create_nsec3(arg1, to, zone_name, algorithm, flags, iterations, salt_length, salt)

def ldns_create_nsec(cur_owner, next_owner, rrs):
    """LDNS buffer."""
    return _ldns.ldns_create_nsec(cur_owner, next_owner, rrs)

def ldns_nsec3_hash_name(name, algorithm, iterations, salt_length, salt):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_hash_name(name, algorithm, iterations, salt_length, salt)

def ldns_nsec3_add_param_rdfs(rr, algorithm, flags, iterations, salt_length, salt):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_add_param_rdfs(rr, algorithm, flags, iterations, salt_length, salt)

def ldns_create_nsec3(cur_owner, cur_zone, rrs, algorithm, flags, iterations, salt_length, salt, emptynonterminal):
    """LDNS buffer."""
    return _ldns.ldns_create_nsec3(cur_owner, cur_zone, rrs, algorithm, flags, iterations, salt_length, salt, emptynonterminal)

def ldns_nsec3_algorithm(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_algorithm(nsec3_rr)

def ldns_nsec3_flags(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_flags(nsec3_rr)

def ldns_nsec3_optout(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_optout(nsec3_rr)

def ldns_nsec3_iterations(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_iterations(nsec3_rr)

def ldns_nsec3_salt(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_salt(nsec3_rr)

def ldns_nsec3_salt_length(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_salt_length(nsec3_rr)

def ldns_nsec3_salt_data(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_salt_data(nsec3_rr)

def ldns_nsec3_next_owner(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_next_owner(nsec3_rr)

def ldns_nsec3_bitmap(nsec3_rr):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_bitmap(nsec3_rr)

def ldns_nsec3_hash_name_frm_nsec3(nsec, name):
    """LDNS buffer."""
    return _ldns.ldns_nsec3_hash_name_frm_nsec3(nsec, name)

def ldns_nsec_bitmap_covers_type(bitmap, type):
    """LDNS buffer."""
    return _ldns.ldns_nsec_bitmap_covers_type(bitmap, type)

def ldns_nsec_bitmap_set_type(bitmap, type):
    """LDNS buffer."""
    return _ldns.ldns_nsec_bitmap_set_type(bitmap, type)

def ldns_nsec_bitmap_clear_type(bitmap, type):
    """LDNS buffer."""
    return _ldns.ldns_nsec_bitmap_clear_type(bitmap, type)

def ldns_nsec_covers_name(nsec, name):
    """LDNS buffer."""
    return _ldns.ldns_nsec_covers_name(nsec, name)

def ldns_dnssec_chain_nsec3_list(nsec3_rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_chain_nsec3_list(nsec3_rrs)

def qsort_rr_compare_nsec3(a, b):
    """LDNS buffer."""
    return _ldns.qsort_rr_compare_nsec3(a, b)

def ldns_rr_list_sort_nsec3(unsorted):
    """LDNS buffer."""
    return _ldns.ldns_rr_list_sort_nsec3(unsorted)

def ldns_dnssec_default_add_to_signatures(sig, n):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_default_add_to_signatures(sig, n)

def ldns_dnssec_default_leave_signatures(sig, n):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_default_leave_signatures(sig, n)

def ldns_dnssec_default_delete_signatures(sig, n):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_default_delete_signatures(sig, n)

def ldns_dnssec_default_replace_signatures(sig, n):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_default_replace_signatures(sig, n)
LDNS_DNSSEC_TRUST_TREE_MAX_PARENTS = _ldns.LDNS_DNSSEC_TRUST_TREE_MAX_PARENTS
class ldns_dnssec_data_chain_struct(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_dnssec_data_chain_struct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_dnssec_data_chain_struct, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rrset"] = _ldns.ldns_dnssec_data_chain_struct_rrset_set
    __swig_getmethods__["rrset"] = _ldns.ldns_dnssec_data_chain_struct_rrset_get
    if _newclass:
        rrset = _swig_property(_ldns.ldns_dnssec_data_chain_struct_rrset_get, _ldns.ldns_dnssec_data_chain_struct_rrset_set)
    __swig_setmethods__["signatures"] = _ldns.ldns_dnssec_data_chain_struct_signatures_set
    __swig_getmethods__["signatures"] = _ldns.ldns_dnssec_data_chain_struct_signatures_get
    if _newclass:
        signatures = _swig_property(_ldns.ldns_dnssec_data_chain_struct_signatures_get, _ldns.ldns_dnssec_data_chain_struct_signatures_set)
    __swig_setmethods__["parent_type"] = _ldns.ldns_dnssec_data_chain_struct_parent_type_set
    __swig_getmethods__["parent_type"] = _ldns.ldns_dnssec_data_chain_struct_parent_type_get
    if _newclass:
        parent_type = _swig_property(_ldns.ldns_dnssec_data_chain_struct_parent_type_get, _ldns.ldns_dnssec_data_chain_struct_parent_type_set)
    __swig_setmethods__["parent"] = _ldns.ldns_dnssec_data_chain_struct_parent_set
    __swig_getmethods__["parent"] = _ldns.ldns_dnssec_data_chain_struct_parent_get
    if _newclass:
        parent = _swig_property(_ldns.ldns_dnssec_data_chain_struct_parent_get, _ldns.ldns_dnssec_data_chain_struct_parent_set)
    __swig_setmethods__["packet_rcode"] = _ldns.ldns_dnssec_data_chain_struct_packet_rcode_set
    __swig_getmethods__["packet_rcode"] = _ldns.ldns_dnssec_data_chain_struct_packet_rcode_get
    if _newclass:
        packet_rcode = _swig_property(_ldns.ldns_dnssec_data_chain_struct_packet_rcode_get, _ldns.ldns_dnssec_data_chain_struct_packet_rcode_set)
    __swig_setmethods__["packet_qtype"] = _ldns.ldns_dnssec_data_chain_struct_packet_qtype_set
    __swig_getmethods__["packet_qtype"] = _ldns.ldns_dnssec_data_chain_struct_packet_qtype_get
    if _newclass:
        packet_qtype = _swig_property(_ldns.ldns_dnssec_data_chain_struct_packet_qtype_get, _ldns.ldns_dnssec_data_chain_struct_packet_qtype_set)
    __swig_setmethods__["packet_nodata"] = _ldns.ldns_dnssec_data_chain_struct_packet_nodata_set
    __swig_getmethods__["packet_nodata"] = _ldns.ldns_dnssec_data_chain_struct_packet_nodata_get
    if _newclass:
        packet_nodata = _swig_property(_ldns.ldns_dnssec_data_chain_struct_packet_nodata_get, _ldns.ldns_dnssec_data_chain_struct_packet_nodata_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_dnssec_data_chain_struct()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_dnssec_data_chain_struct
    __del__ = lambda self: None
ldns_dnssec_data_chain_struct_swigregister = _ldns.ldns_dnssec_data_chain_struct_swigregister
ldns_dnssec_data_chain_struct_swigregister(ldns_dnssec_data_chain_struct)


def ldns_dnssec_data_chain_new():
    """LDNS buffer."""
    return _ldns.ldns_dnssec_data_chain_new()

def ldns_dnssec_data_chain_free(chain):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_data_chain_free(chain)

def ldns_dnssec_data_chain_deep_free(chain):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_data_chain_deep_free(chain)

def ldns_dnssec_data_chain_print(out, chain):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_data_chain_print(out, chain)

def ldns_dnssec_data_chain_print_fmt(out, fmt, chain):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_data_chain_print_fmt(out, fmt, chain)

def ldns_dnssec_build_data_chain(res, qflags, data_set, pkt, orig_rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_build_data_chain(res, qflags, data_set, pkt, orig_rr)
class ldns_dnssec_trust_tree_struct(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_dnssec_trust_tree_struct, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_dnssec_trust_tree_struct, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rr"] = _ldns.ldns_dnssec_trust_tree_struct_rr_set
    __swig_getmethods__["rr"] = _ldns.ldns_dnssec_trust_tree_struct_rr_get
    if _newclass:
        rr = _swig_property(_ldns.ldns_dnssec_trust_tree_struct_rr_get, _ldns.ldns_dnssec_trust_tree_struct_rr_set)
    __swig_setmethods__["rrset"] = _ldns.ldns_dnssec_trust_tree_struct_rrset_set
    __swig_getmethods__["rrset"] = _ldns.ldns_dnssec_trust_tree_struct_rrset_get
    if _newclass:
        rrset = _swig_property(_ldns.ldns_dnssec_trust_tree_struct_rrset_get, _ldns.ldns_dnssec_trust_tree_struct_rrset_set)
    __swig_setmethods__["parents"] = _ldns.ldns_dnssec_trust_tree_struct_parents_set
    __swig_getmethods__["parents"] = _ldns.ldns_dnssec_trust_tree_struct_parents_get
    if _newclass:
        parents = _swig_property(_ldns.ldns_dnssec_trust_tree_struct_parents_get, _ldns.ldns_dnssec_trust_tree_struct_parents_set)
    __swig_setmethods__["parent_status"] = _ldns.ldns_dnssec_trust_tree_struct_parent_status_set
    __swig_getmethods__["parent_status"] = _ldns.ldns_dnssec_trust_tree_struct_parent_status_get
    if _newclass:
        parent_status = _swig_property(_ldns.ldns_dnssec_trust_tree_struct_parent_status_get, _ldns.ldns_dnssec_trust_tree_struct_parent_status_set)
    __swig_setmethods__["parent_signature"] = _ldns.ldns_dnssec_trust_tree_struct_parent_signature_set
    __swig_getmethods__["parent_signature"] = _ldns.ldns_dnssec_trust_tree_struct_parent_signature_get
    if _newclass:
        parent_signature = _swig_property(_ldns.ldns_dnssec_trust_tree_struct_parent_signature_get, _ldns.ldns_dnssec_trust_tree_struct_parent_signature_set)
    __swig_setmethods__["parent_count"] = _ldns.ldns_dnssec_trust_tree_struct_parent_count_set
    __swig_getmethods__["parent_count"] = _ldns.ldns_dnssec_trust_tree_struct_parent_count_get
    if _newclass:
        parent_count = _swig_property(_ldns.ldns_dnssec_trust_tree_struct_parent_count_get, _ldns.ldns_dnssec_trust_tree_struct_parent_count_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_dnssec_trust_tree_struct()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_dnssec_trust_tree_struct
    __del__ = lambda self: None
ldns_dnssec_trust_tree_struct_swigregister = _ldns.ldns_dnssec_trust_tree_struct_swigregister
ldns_dnssec_trust_tree_struct_swigregister(ldns_dnssec_trust_tree_struct)


def ldns_dnssec_trust_tree_new():
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_new()

def ldns_dnssec_trust_tree_free(tree):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_free(tree)

def ldns_dnssec_trust_tree_depth(tree):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_depth(tree)

def ldns_dnssec_trust_tree_print(out, tree, tabs, extended):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_print(out, tree, tabs, extended)

def ldns_dnssec_trust_tree_print_fmt(out, fmt, tree, tabs, extended):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_print_fmt(out, fmt, tree, tabs, extended)

def ldns_dnssec_trust_tree_add_parent(tree, parent, parent_signature, parent_status):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_add_parent(tree, parent, parent_signature, parent_status)

def ldns_dnssec_derive_trust_tree(data_chain, rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree(data_chain, rr)

def ldns_dnssec_derive_trust_tree_time(data_chain, rr, check_time):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_time(data_chain, rr, check_time)

def ldns_dnssec_derive_trust_tree_normal_rrset(new_tree, data_chain, cur_sig_rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_normal_rrset(new_tree, data_chain, cur_sig_rr)

def ldns_dnssec_derive_trust_tree_normal_rrset_time(new_tree, data_chain, cur_sig_rr, check_time):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_normal_rrset_time(new_tree, data_chain, cur_sig_rr, check_time)

def ldns_dnssec_derive_trust_tree_dnskey_rrset(new_tree, data_chain, cur_rr, cur_sig_rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_dnskey_rrset(new_tree, data_chain, cur_rr, cur_sig_rr)

def ldns_dnssec_derive_trust_tree_dnskey_rrset_time(new_tree, data_chain, cur_rr, cur_sig_rr, check_time):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_dnskey_rrset_time(new_tree, data_chain, cur_rr, cur_sig_rr, check_time)

def ldns_dnssec_derive_trust_tree_ds_rrset(new_tree, data_chain, cur_rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_ds_rrset(new_tree, data_chain, cur_rr)

def ldns_dnssec_derive_trust_tree_ds_rrset_time(new_tree, data_chain, cur_rr, check_time):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_ds_rrset_time(new_tree, data_chain, cur_rr, check_time)

def ldns_dnssec_derive_trust_tree_no_sig(new_tree, data_chain):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_no_sig(new_tree, data_chain)

def ldns_dnssec_derive_trust_tree_no_sig_time(new_tree, data_chain, check_time):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_derive_trust_tree_no_sig_time(new_tree, data_chain, check_time)

def ldns_dnssec_trust_tree_contains_keys(tree, keys):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_trust_tree_contains_keys(tree, keys)

def ldns_verify(rrset, rrsig, keys, good_keys):
    """LDNS buffer."""
    return _ldns.ldns_verify(rrset, rrsig, keys, good_keys)

def ldns_verify_time(rrset, rrsig, keys, check_time, good_keys):
    """LDNS buffer."""
    return _ldns.ldns_verify_time(rrset, rrsig, keys, check_time, good_keys)

def ldns_verify_notime(rrset, rrsig, keys, good_keys):
    """LDNS buffer."""
    return _ldns.ldns_verify_notime(rrset, rrsig, keys, good_keys)

def ldns_fetch_valid_domain_keys(res, domain, keys, status):
    """LDNS buffer."""
    return _ldns.ldns_fetch_valid_domain_keys(res, domain, keys, status)

def ldns_fetch_valid_domain_keys_time(res, domain, keys, check_time, status):
    """LDNS buffer."""
    return _ldns.ldns_fetch_valid_domain_keys_time(res, domain, keys, check_time, status)

def ldns_validate_domain_dnskey(res, domain, keys):
    """LDNS buffer."""
    return _ldns.ldns_validate_domain_dnskey(res, domain, keys)

def ldns_validate_domain_dnskey_time(res, domain, keys, check_time):
    """LDNS buffer."""
    return _ldns.ldns_validate_domain_dnskey_time(res, domain, keys, check_time)

def ldns_validate_domain_ds(res, domain, keys):
    """LDNS buffer."""
    return _ldns.ldns_validate_domain_ds(res, domain, keys)

def ldns_validate_domain_ds_time(res, domain, keys, check_time):
    """LDNS buffer."""
    return _ldns.ldns_validate_domain_ds_time(res, domain, keys, check_time)

def ldns_verify_trusted(res, rrset, rrsigs, validating_keys):
    """LDNS buffer."""
    return _ldns.ldns_verify_trusted(res, rrset, rrsigs, validating_keys)

def ldns_verify_trusted_time(res, rrset, rrsigs, check_time, validating_keys):
    """LDNS buffer."""
    return _ldns.ldns_verify_trusted_time(res, rrset, rrsigs, check_time, validating_keys)

def ldns_dnssec_verify_denial(rr, nsecs, rrsigs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_verify_denial(rr, nsecs, rrsigs)

def ldns_dnssec_verify_denial_nsec3(rr, nsecs, rrsigs, packet_rcode, packet_qtype, packet_nodata):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_verify_denial_nsec3(rr, nsecs, rrsigs, packet_rcode, packet_qtype, packet_nodata)

def ldns_dnssec_verify_denial_nsec3_match(rr, nsecs, rrsigs, packet_rcode, packet_qtype, packet_nodata):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_verify_denial_nsec3_match(rr, nsecs, rrsigs, packet_rcode, packet_qtype, packet_nodata)

def ldns_verify_rrsig_buffers(rawsig_buf, verify_buf, key_buf, algo):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_buffers(rawsig_buf, verify_buf, key_buf, algo)

def ldns_verify_rrsig_buffers_raw(sig, siglen, verify_buf, key, keylen, algo):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_buffers_raw(sig, siglen, verify_buf, key, keylen, algo)

def __ldns_verify_rrsig_keylist(rrset, rrsig, keys, good_keys):
    """LDNS buffer."""
    return _ldns.__ldns_verify_rrsig_keylist(rrset, rrsig, keys, good_keys)

def ldns_verify_rrsig_keylist_time(rrset, rrsig, keys, check_time, good_keys):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_keylist_time(rrset, rrsig, keys, check_time, good_keys)

def __ldns_verify_rrsig_keylist_notime(rrset, rrsig, keys, good_keys):
    """LDNS buffer."""
    return _ldns.__ldns_verify_rrsig_keylist_notime(rrset, rrsig, keys, good_keys)

def ldns_verify_rrsig(rrset, rrsig, key):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig(rrset, rrsig, key)

def ldns_verify_rrsig_time(rrset, rrsig, key, check_time):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_time(rrset, rrsig, key, check_time)

def ldns_verify_rrsig_dsa(sig, rrset, key):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_dsa(sig, rrset, key)

def ldns_verify_rrsig_rsasha1(sig, rrset, key):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_rsasha1(sig, rrset, key)

def ldns_verify_rrsig_rsamd5(sig, rrset, key):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_rsamd5(sig, rrset, key)

def ldns_verify_rrsig_dsa_raw(sig, siglen, rrset, key, keylen):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_dsa_raw(sig, siglen, rrset, key, keylen)

def ldns_verify_rrsig_rsasha1_raw(sig, siglen, rrset, key, keylen):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_rsasha1_raw(sig, siglen, rrset, key, keylen)

def ldns_verify_rrsig_rsasha256_raw(sig, siglen, rrset, key, keylen):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_rsasha256_raw(sig, siglen, rrset, key, keylen)

def ldns_verify_rrsig_rsasha512_raw(sig, siglen, rrset, key, keylen):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_rsasha512_raw(sig, siglen, rrset, key, keylen)

def ldns_verify_rrsig_rsamd5_raw(sig, siglen, rrset, key, keylen):
    """LDNS buffer."""
    return _ldns.ldns_verify_rrsig_rsamd5_raw(sig, siglen, rrset, key, keylen)
LDNS_SIGN_DNSKEY_WITH_ZSK = _ldns.LDNS_SIGN_DNSKEY_WITH_ZSK
LDNS_SIGN_WITH_ALL_ALGORITHMS = _ldns.LDNS_SIGN_WITH_ALL_ALGORITHMS

def ldns_create_empty_rrsig(rrset, key):
    """LDNS buffer."""
    return _ldns.ldns_create_empty_rrsig(rrset, key)

def ldns_sign_public_buffer(sign_buf, key):
    """LDNS buffer."""
    return _ldns.ldns_sign_public_buffer(sign_buf, key)

def ldns_sign_public(rrset, keys):
    """LDNS buffer."""
    return _ldns.ldns_sign_public(rrset, keys)

def ldns_dnssec_zone_mark_and_get_glue(zone, glue_list):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_mark_and_get_glue(zone, glue_list)

def ldns_dnssec_zone_mark_glue(zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_mark_glue(zone)

def ldns_dnssec_name_node_next_nonglue(node):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_node_next_nonglue(node)

def ldns_dnssec_zone_create_nsecs(zone, new_rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_create_nsecs(zone, new_rrs)

def ldns_dnssec_zone_create_nsec3s(zone, new_rrs, algorithm, flags, iterations, salt_length, salt):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_create_nsec3s(zone, new_rrs, algorithm, flags, iterations, salt_length, salt)

def ldns_dnssec_remove_signatures(signatures, key_list, func, arg):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_remove_signatures(signatures, key_list, func, arg)

def ldns_dnssec_zone_create_rrsigs_flg(zone, new_rrs, key_list, func, arg, flags):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_create_rrsigs_flg(zone, new_rrs, key_list, func, arg, flags)

def ldns_dnssec_zone_create_rrsigs(zone, new_rrs, key_list, func, arg):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_create_rrsigs(zone, new_rrs, key_list, func, arg)

def ldns_dnssec_zone_sign_flg(zone, new_rrs, key_list, func, arg, flags):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_sign_flg(zone, new_rrs, key_list, func, arg, flags)

def ldns_dnssec_zone_sign_nsec3_flg(zone, new_rrs, key_list, func, arg, algorithm, flags, iterations, salt_length, salt, signflags):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_sign_nsec3_flg(zone, new_rrs, key_list, func, arg, algorithm, flags, iterations, salt_length, salt, signflags)

def ldns_dnssec_zone_sign_nsec3_flg_mkmap(zone, new_rrs, key_list, func, arg, algorithm, flags, iterations, salt_length, salt, signflags, map):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_sign_nsec3_flg_mkmap(zone, new_rrs, key_list, func, arg, algorithm, flags, iterations, salt_length, salt, signflags, map)

def ldns_dnssec_zone_sign(zone, new_rrs, key_list, func, arg):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_sign(zone, new_rrs, key_list, func, arg)

def ldns_dnssec_zone_sign_nsec3(zone, new_rrs, key_list, func, arg, algorithm, flags, iterations, salt_length, salt):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_sign_nsec3(zone, new_rrs, key_list, func, arg, algorithm, flags, iterations, salt_length, salt)

def ldns_zone_sign(zone, key_list):
    """LDNS buffer."""
    return _ldns.ldns_zone_sign(zone, key_list)

def ldns_zone_sign_nsec3(zone, key_list, algorithm, flags, iterations, salt_length, salt):
    """LDNS buffer."""
    return _ldns.ldns_zone_sign_nsec3(zone, key_list, algorithm, flags, iterations, salt_length, salt)
LDNS_STATUS_OK = _ldns.LDNS_STATUS_OK
LDNS_STATUS_EMPTY_LABEL = _ldns.LDNS_STATUS_EMPTY_LABEL
LDNS_STATUS_LABEL_OVERFLOW = _ldns.LDNS_STATUS_LABEL_OVERFLOW
LDNS_STATUS_DOMAINNAME_OVERFLOW = _ldns.LDNS_STATUS_DOMAINNAME_OVERFLOW
LDNS_STATUS_DOMAINNAME_UNDERFLOW = _ldns.LDNS_STATUS_DOMAINNAME_UNDERFLOW
LDNS_STATUS_DDD_OVERFLOW = _ldns.LDNS_STATUS_DDD_OVERFLOW
LDNS_STATUS_PACKET_OVERFLOW = _ldns.LDNS_STATUS_PACKET_OVERFLOW
LDNS_STATUS_INVALID_POINTER = _ldns.LDNS_STATUS_INVALID_POINTER
LDNS_STATUS_MEM_ERR = _ldns.LDNS_STATUS_MEM_ERR
LDNS_STATUS_INTERNAL_ERR = _ldns.LDNS_STATUS_INTERNAL_ERR
LDNS_STATUS_SSL_ERR = _ldns.LDNS_STATUS_SSL_ERR
LDNS_STATUS_ERR = _ldns.LDNS_STATUS_ERR
LDNS_STATUS_INVALID_INT = _ldns.LDNS_STATUS_INVALID_INT
LDNS_STATUS_INVALID_IP4 = _ldns.LDNS_STATUS_INVALID_IP4
LDNS_STATUS_INVALID_IP6 = _ldns.LDNS_STATUS_INVALID_IP6
LDNS_STATUS_INVALID_STR = _ldns.LDNS_STATUS_INVALID_STR
LDNS_STATUS_INVALID_B32_EXT = _ldns.LDNS_STATUS_INVALID_B32_EXT
LDNS_STATUS_INVALID_B64 = _ldns.LDNS_STATUS_INVALID_B64
LDNS_STATUS_INVALID_HEX = _ldns.LDNS_STATUS_INVALID_HEX
LDNS_STATUS_INVALID_TIME = _ldns.LDNS_STATUS_INVALID_TIME
LDNS_STATUS_NETWORK_ERR = _ldns.LDNS_STATUS_NETWORK_ERR
LDNS_STATUS_ADDRESS_ERR = _ldns.LDNS_STATUS_ADDRESS_ERR
LDNS_STATUS_FILE_ERR = _ldns.LDNS_STATUS_FILE_ERR
LDNS_STATUS_UNKNOWN_INET = _ldns.LDNS_STATUS_UNKNOWN_INET
LDNS_STATUS_NOT_IMPL = _ldns.LDNS_STATUS_NOT_IMPL
LDNS_STATUS_NULL = _ldns.LDNS_STATUS_NULL
LDNS_STATUS_CRYPTO_UNKNOWN_ALGO = _ldns.LDNS_STATUS_CRYPTO_UNKNOWN_ALGO
LDNS_STATUS_CRYPTO_ALGO_NOT_IMPL = _ldns.LDNS_STATUS_CRYPTO_ALGO_NOT_IMPL
LDNS_STATUS_CRYPTO_NO_RRSIG = _ldns.LDNS_STATUS_CRYPTO_NO_RRSIG
LDNS_STATUS_CRYPTO_NO_DNSKEY = _ldns.LDNS_STATUS_CRYPTO_NO_DNSKEY
LDNS_STATUS_CRYPTO_NO_TRUSTED_DNSKEY = _ldns.LDNS_STATUS_CRYPTO_NO_TRUSTED_DNSKEY
LDNS_STATUS_CRYPTO_NO_DS = _ldns.LDNS_STATUS_CRYPTO_NO_DS
LDNS_STATUS_CRYPTO_NO_TRUSTED_DS = _ldns.LDNS_STATUS_CRYPTO_NO_TRUSTED_DS
LDNS_STATUS_CRYPTO_NO_MATCHING_KEYTAG_DNSKEY = _ldns.LDNS_STATUS_CRYPTO_NO_MATCHING_KEYTAG_DNSKEY
LDNS_STATUS_CRYPTO_VALIDATED = _ldns.LDNS_STATUS_CRYPTO_VALIDATED
LDNS_STATUS_CRYPTO_BOGUS = _ldns.LDNS_STATUS_CRYPTO_BOGUS
LDNS_STATUS_CRYPTO_SIG_EXPIRED = _ldns.LDNS_STATUS_CRYPTO_SIG_EXPIRED
LDNS_STATUS_CRYPTO_SIG_NOT_INCEPTED = _ldns.LDNS_STATUS_CRYPTO_SIG_NOT_INCEPTED
LDNS_STATUS_CRYPTO_TSIG_BOGUS = _ldns.LDNS_STATUS_CRYPTO_TSIG_BOGUS
LDNS_STATUS_CRYPTO_TSIG_ERR = _ldns.LDNS_STATUS_CRYPTO_TSIG_ERR
LDNS_STATUS_CRYPTO_EXPIRATION_BEFORE_INCEPTION = _ldns.LDNS_STATUS_CRYPTO_EXPIRATION_BEFORE_INCEPTION
LDNS_STATUS_CRYPTO_TYPE_COVERED_ERR = _ldns.LDNS_STATUS_CRYPTO_TYPE_COVERED_ERR
LDNS_STATUS_ENGINE_KEY_NOT_LOADED = _ldns.LDNS_STATUS_ENGINE_KEY_NOT_LOADED
LDNS_STATUS_NSEC3_ERR = _ldns.LDNS_STATUS_NSEC3_ERR
LDNS_STATUS_RES_NO_NS = _ldns.LDNS_STATUS_RES_NO_NS
LDNS_STATUS_RES_QUERY = _ldns.LDNS_STATUS_RES_QUERY
LDNS_STATUS_WIRE_INCOMPLETE_HEADER = _ldns.LDNS_STATUS_WIRE_INCOMPLETE_HEADER
LDNS_STATUS_WIRE_INCOMPLETE_QUESTION = _ldns.LDNS_STATUS_WIRE_INCOMPLETE_QUESTION
LDNS_STATUS_WIRE_INCOMPLETE_ANSWER = _ldns.LDNS_STATUS_WIRE_INCOMPLETE_ANSWER
LDNS_STATUS_WIRE_INCOMPLETE_AUTHORITY = _ldns.LDNS_STATUS_WIRE_INCOMPLETE_AUTHORITY
LDNS_STATUS_WIRE_INCOMPLETE_ADDITIONAL = _ldns.LDNS_STATUS_WIRE_INCOMPLETE_ADDITIONAL
LDNS_STATUS_NO_DATA = _ldns.LDNS_STATUS_NO_DATA
LDNS_STATUS_CERT_BAD_ALGORITHM = _ldns.LDNS_STATUS_CERT_BAD_ALGORITHM
LDNS_STATUS_SYNTAX_TYPE_ERR = _ldns.LDNS_STATUS_SYNTAX_TYPE_ERR
LDNS_STATUS_SYNTAX_CLASS_ERR = _ldns.LDNS_STATUS_SYNTAX_CLASS_ERR
LDNS_STATUS_SYNTAX_TTL_ERR = _ldns.LDNS_STATUS_SYNTAX_TTL_ERR
LDNS_STATUS_SYNTAX_INCLUDE_ERR_NOTIMPL = _ldns.LDNS_STATUS_SYNTAX_INCLUDE_ERR_NOTIMPL
LDNS_STATUS_SYNTAX_RDATA_ERR = _ldns.LDNS_STATUS_SYNTAX_RDATA_ERR
LDNS_STATUS_SYNTAX_DNAME_ERR = _ldns.LDNS_STATUS_SYNTAX_DNAME_ERR
LDNS_STATUS_SYNTAX_VERSION_ERR = _ldns.LDNS_STATUS_SYNTAX_VERSION_ERR
LDNS_STATUS_SYNTAX_ALG_ERR = _ldns.LDNS_STATUS_SYNTAX_ALG_ERR
LDNS_STATUS_SYNTAX_KEYWORD_ERR = _ldns.LDNS_STATUS_SYNTAX_KEYWORD_ERR
LDNS_STATUS_SYNTAX_TTL = _ldns.LDNS_STATUS_SYNTAX_TTL
LDNS_STATUS_SYNTAX_ORIGIN = _ldns.LDNS_STATUS_SYNTAX_ORIGIN
LDNS_STATUS_SYNTAX_INCLUDE = _ldns.LDNS_STATUS_SYNTAX_INCLUDE
LDNS_STATUS_SYNTAX_EMPTY = _ldns.LDNS_STATUS_SYNTAX_EMPTY
LDNS_STATUS_SYNTAX_ITERATIONS_OVERFLOW = _ldns.LDNS_STATUS_SYNTAX_ITERATIONS_OVERFLOW
LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR = _ldns.LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR
LDNS_STATUS_SYNTAX_INTEGER_OVERFLOW = _ldns.LDNS_STATUS_SYNTAX_INTEGER_OVERFLOW
LDNS_STATUS_SYNTAX_BAD_ESCAPE = _ldns.LDNS_STATUS_SYNTAX_BAD_ESCAPE
LDNS_STATUS_SOCKET_ERROR = _ldns.LDNS_STATUS_SOCKET_ERROR
LDNS_STATUS_SYNTAX_ERR = _ldns.LDNS_STATUS_SYNTAX_ERR
LDNS_STATUS_DNSSEC_EXISTENCE_DENIED = _ldns.LDNS_STATUS_DNSSEC_EXISTENCE_DENIED
LDNS_STATUS_DNSSEC_NSEC_RR_NOT_COVERED = _ldns.LDNS_STATUS_DNSSEC_NSEC_RR_NOT_COVERED
LDNS_STATUS_DNSSEC_NSEC_WILDCARD_NOT_COVERED = _ldns.LDNS_STATUS_DNSSEC_NSEC_WILDCARD_NOT_COVERED
LDNS_STATUS_DNSSEC_NSEC3_ORIGINAL_NOT_FOUND = _ldns.LDNS_STATUS_DNSSEC_NSEC3_ORIGINAL_NOT_FOUND
LDNS_STATUS_MISSING_RDATA_FIELDS_RRSIG = _ldns.LDNS_STATUS_MISSING_RDATA_FIELDS_RRSIG
LDNS_STATUS_MISSING_RDATA_FIELDS_KEY = _ldns.LDNS_STATUS_MISSING_RDATA_FIELDS_KEY
LDNS_STATUS_CRYPTO_SIG_EXPIRED_WITHIN_MARGIN = _ldns.LDNS_STATUS_CRYPTO_SIG_EXPIRED_WITHIN_MARGIN
LDNS_STATUS_CRYPTO_SIG_NOT_INCEPTED_WITHIN_MARGIN = _ldns.LDNS_STATUS_CRYPTO_SIG_NOT_INCEPTED_WITHIN_MARGIN
LDNS_STATUS_DANE_STATUS_MESSAGES = _ldns.LDNS_STATUS_DANE_STATUS_MESSAGES
LDNS_STATUS_DANE_UNKNOWN_CERTIFICATE_USAGE = _ldns.LDNS_STATUS_DANE_UNKNOWN_CERTIFICATE_USAGE
LDNS_STATUS_DANE_UNKNOWN_SELECTOR = _ldns.LDNS_STATUS_DANE_UNKNOWN_SELECTOR
LDNS_STATUS_DANE_UNKNOWN_MATCHING_TYPE = _ldns.LDNS_STATUS_DANE_UNKNOWN_MATCHING_TYPE
LDNS_STATUS_DANE_UNKNOWN_PROTOCOL = _ldns.LDNS_STATUS_DANE_UNKNOWN_PROTOCOL
LDNS_STATUS_DANE_UNKNOWN_TRANSPORT = _ldns.LDNS_STATUS_DANE_UNKNOWN_TRANSPORT
LDNS_STATUS_DANE_MISSING_EXTRA_CERTS = _ldns.LDNS_STATUS_DANE_MISSING_EXTRA_CERTS
LDNS_STATUS_DANE_EXTRA_CERTS_NOT_USED = _ldns.LDNS_STATUS_DANE_EXTRA_CERTS_NOT_USED
LDNS_STATUS_DANE_OFFSET_OUT_OF_RANGE = _ldns.LDNS_STATUS_DANE_OFFSET_OUT_OF_RANGE
LDNS_STATUS_DANE_INSECURE = _ldns.LDNS_STATUS_DANE_INSECURE
LDNS_STATUS_DANE_BOGUS = _ldns.LDNS_STATUS_DANE_BOGUS
LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH = _ldns.LDNS_STATUS_DANE_TLSA_DID_NOT_MATCH
LDNS_STATUS_DANE_NON_CA_CERTIFICATE = _ldns.LDNS_STATUS_DANE_NON_CA_CERTIFICATE
LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE = _ldns.LDNS_STATUS_DANE_PKIX_DID_NOT_VALIDATE
LDNS_STATUS_DANE_PKIX_NO_SELF_SIGNED_TRUST_ANCHOR = _ldns.LDNS_STATUS_DANE_PKIX_NO_SELF_SIGNED_TRUST_ANCHOR
LDNS_STATUS_EXISTS_ERR = _ldns.LDNS_STATUS_EXISTS_ERR
LDNS_STATUS_INVALID_ILNP64 = _ldns.LDNS_STATUS_INVALID_ILNP64
LDNS_STATUS_INVALID_EUI48 = _ldns.LDNS_STATUS_INVALID_EUI48
LDNS_STATUS_INVALID_EUI64 = _ldns.LDNS_STATUS_INVALID_EUI64
LDNS_STATUS_WIRE_RDATA_ERR = _ldns.LDNS_STATUS_WIRE_RDATA_ERR
LDNS_STATUS_INVALID_TAG = _ldns.LDNS_STATUS_INVALID_TAG
LDNS_STATUS_TYPE_NOT_IN_BITMAP = _ldns.LDNS_STATUS_TYPE_NOT_IN_BITMAP
LDNS_STATUS_INVALID_RDF_TYPE = _ldns.LDNS_STATUS_INVALID_RDF_TYPE
LDNS_STATUS_RDATA_OVERFLOW = _ldns.LDNS_STATUS_RDATA_OVERFLOW
LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR = _ldns.LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR
LDNS_STATUS_NSEC3_DOMAINNAME_OVERFLOW = _ldns.LDNS_STATUS_NSEC3_DOMAINNAME_OVERFLOW
LDNS_STATUS_DANE_NEED_OPENSSL_GE_1_1_FOR_DANE_TA = _ldns.LDNS_STATUS_DANE_NEED_OPENSSL_GE_1_1_FOR_DANE_TA

def ldns_get_errorstr_by_id(err):
    """LDNS buffer."""
    return _ldns.ldns_get_errorstr_by_id(err)

def ldns_get_rr_list_addr_by_name(r, name, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_get_rr_list_addr_by_name(r, name, c, flags)

def ldns_get_rr_list_name_by_addr(r, addr, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_get_rr_list_name_by_addr(r, addr, c, flags)

def ldns_get_rr_list_hosts_frm_fp(fp):
    """LDNS buffer."""
    return _ldns.ldns_get_rr_list_hosts_frm_fp(fp)

def ldns_get_rr_list_hosts_frm_fp_l(fp):
    """LDNS buffer."""
    return _ldns.ldns_get_rr_list_hosts_frm_fp_l(fp)

def ldns_get_rr_list_hosts_frm_file(filename):
    """LDNS buffer."""
    return _ldns.ldns_get_rr_list_hosts_frm_file(filename)

def ldns_getaddrinfo(res, node, c, list):
    """LDNS buffer."""
    return _ldns.ldns_getaddrinfo(res, node, c, list)

def ldns_nsec_type_check(nsec, t):
    """LDNS buffer."""
    return _ldns.ldns_nsec_type_check(nsec, t)

def ldns_print_rr_rdf(fp, r, rdfnum):
    """LDNS buffer."""
    return _ldns.ldns_print_rr_rdf(fp, r, rdfnum)
LDNS_APL_IP4 = _ldns.LDNS_APL_IP4
LDNS_APL_IP6 = _ldns.LDNS_APL_IP6
LDNS_APL_MASK = _ldns.LDNS_APL_MASK
LDNS_APL_NEGATION = _ldns.LDNS_APL_NEGATION
LDNS_COMMENT_NULLS = _ldns.LDNS_COMMENT_NULLS
LDNS_COMMENT_KEY_ID = _ldns.LDNS_COMMENT_KEY_ID
LDNS_COMMENT_KEY_TYPE = _ldns.LDNS_COMMENT_KEY_TYPE
LDNS_COMMENT_KEY_SIZE = _ldns.LDNS_COMMENT_KEY_SIZE
LDNS_COMMENT_BUBBLEBABBLE = _ldns.LDNS_COMMENT_BUBBLEBABBLE
LDNS_COMMENT_FLAGS = _ldns.LDNS_COMMENT_FLAGS
LDNS_COMMENT_NSEC3_CHAIN = _ldns.LDNS_COMMENT_NSEC3_CHAIN
LDNS_COMMENT_LAYOUT = _ldns.LDNS_COMMENT_LAYOUT
LDNS_COMMENT_RRSIGS = _ldns.LDNS_COMMENT_RRSIGS
LDNS_FMT_ZEROIZE_RRSIGS = _ldns.LDNS_FMT_ZEROIZE_RRSIGS
LDNS_FMT_PAD_SOA_SERIAL = _ldns.LDNS_FMT_PAD_SOA_SERIAL
LDNS_FMT_RFC3597 = _ldns.LDNS_FMT_RFC3597
LDNS_FMT_FLAGS_WITH_DATA = _ldns.LDNS_FMT_FLAGS_WITH_DATA
LDNS_COMMENT_KEY = _ldns.LDNS_COMMENT_KEY
class ldns_struct_output_format(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_output_format, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_output_format, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _ldns.ldns_struct_output_format_flags_set
    __swig_getmethods__["flags"] = _ldns.ldns_struct_output_format_flags_get
    if _newclass:
        flags = _swig_property(_ldns.ldns_struct_output_format_flags_get, _ldns.ldns_struct_output_format_flags_set)
    __swig_setmethods__["data"] = _ldns.ldns_struct_output_format_data_set
    __swig_getmethods__["data"] = _ldns.ldns_struct_output_format_data_get
    if _newclass:
        data = _swig_property(_ldns.ldns_struct_output_format_data_get, _ldns.ldns_struct_output_format_data_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_output_format()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_output_format
    __del__ = lambda self: None
ldns_struct_output_format_swigregister = _ldns.ldns_struct_output_format_swigregister
ldns_struct_output_format_swigregister(ldns_struct_output_format)
cvar = _ldns.cvar
ldns_error_str = cvar.ldns_error_str

class ldns_struct_output_format_storage(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_output_format_storage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_output_format_storage, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _ldns.ldns_struct_output_format_storage_flags_set
    __swig_getmethods__["flags"] = _ldns.ldns_struct_output_format_storage_flags_get
    if _newclass:
        flags = _swig_property(_ldns.ldns_struct_output_format_storage_flags_get, _ldns.ldns_struct_output_format_storage_flags_set)
    __swig_setmethods__["hashmap"] = _ldns.ldns_struct_output_format_storage_hashmap_set
    __swig_getmethods__["hashmap"] = _ldns.ldns_struct_output_format_storage_hashmap_get
    if _newclass:
        hashmap = _swig_property(_ldns.ldns_struct_output_format_storage_hashmap_get, _ldns.ldns_struct_output_format_storage_hashmap_set)
    __swig_setmethods__["bitmap"] = _ldns.ldns_struct_output_format_storage_bitmap_set
    __swig_getmethods__["bitmap"] = _ldns.ldns_struct_output_format_storage_bitmap_get
    if _newclass:
        bitmap = _swig_property(_ldns.ldns_struct_output_format_storage_bitmap_get, _ldns.ldns_struct_output_format_storage_bitmap_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_output_format_storage()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_output_format_storage
    __del__ = lambda self: None
ldns_struct_output_format_storage_swigregister = _ldns.ldns_struct_output_format_storage_swigregister
ldns_struct_output_format_storage_swigregister(ldns_struct_output_format_storage)


def ldns_output_format_init(fmt):
    """LDNS buffer."""
    return _ldns.ldns_output_format_init(fmt)

def ldns_output_format_set(fmt, flag):
    """LDNS buffer."""
    return _ldns.ldns_output_format_set(fmt, flag)

def ldns_output_format_clear(fmt, flag):
    """LDNS buffer."""
    return _ldns.ldns_output_format_clear(fmt, flag)

def ldns_output_format_set_type(fmt, type):
    """LDNS buffer."""
    return _ldns.ldns_output_format_set_type(fmt, type)

def ldns_output_format_clear_type(fmt, type):
    """LDNS buffer."""
    return _ldns.ldns_output_format_clear_type(fmt, type)

def ldns_pkt_opcode2buffer_str(output, opcode):
    """LDNS buffer."""
    return _ldns.ldns_pkt_opcode2buffer_str(output, opcode)

def ldns_pkt_rcode2buffer_str(output, rcode):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rcode2buffer_str(output, rcode)

def ldns_algorithm2buffer_str(output, algorithm):
    """LDNS buffer."""
    return _ldns.ldns_algorithm2buffer_str(output, algorithm)

def ldns_cert_algorithm2buffer_str(output, cert_algorithm):
    """LDNS buffer."""
    return _ldns.ldns_cert_algorithm2buffer_str(output, cert_algorithm)

def ldns_pkt_opcode2str(opcode):
    """LDNS buffer."""
    return _ldns.ldns_pkt_opcode2str(opcode)

def ldns_pkt_rcode2str(rcode):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rcode2str(rcode)

def ldns_pkt_algorithm2str(algorithm):
    """LDNS buffer."""
    return _ldns.ldns_pkt_algorithm2str(algorithm)

def ldns_pkt_cert_algorithm2str(cert_algorithm):
    """LDNS buffer."""
    return _ldns.ldns_pkt_cert_algorithm2str(cert_algorithm)

def ldns_rdf2buffer_str_a(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_a(output, rdf)

def ldns_rdf2buffer_str_aaaa(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_aaaa(output, rdf)

def ldns_rdf2buffer_str_str(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_str(output, rdf)

def ldns_rdf2buffer_str_b64(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_b64(output, rdf)

def ldns_rdf2buffer_str_b32_ext(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_b32_ext(output, rdf)

def ldns_rdf2buffer_str_hex(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_hex(output, rdf)

def ldns_rdf2buffer_str_type(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_type(output, rdf)

def ldns_rdf2buffer_str_class(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_class(output, rdf)

def ldns_rdf2buffer_str_alg(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_alg(output, rdf)

def ldns_rr_type2buffer_str(output, type):
    """LDNS buffer."""
    return _ldns.ldns_rr_type2buffer_str(output, type)

def ldns_rr_type2str(type):
    """LDNS buffer."""
    return _ldns.ldns_rr_type2str(type)

def ldns_rr_class2buffer_str(output, klass):
    """LDNS buffer."""
    return _ldns.ldns_rr_class2buffer_str(output, klass)

def ldns_rr_class2str(klass):
    """LDNS buffer."""
    return _ldns.ldns_rr_class2str(klass)

def ldns_rdf2buffer_str_cert_alg(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_cert_alg(output, rdf)

def ldns_rdf2buffer_str_loc(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_loc(output, rdf)

def ldns_rdf2buffer_str_unknown(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_unknown(output, rdf)

def ldns_rdf2buffer_str_nsap(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_nsap(output, rdf)

def ldns_rdf2buffer_str_atma(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_atma(output, rdf)

def ldns_rdf2buffer_str_wks(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_wks(output, rdf)

def ldns_rdf2buffer_str_nsec(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_nsec(output, rdf)

def ldns_rdf2buffer_str_period(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_period(output, rdf)

def ldns_rdf2buffer_str_tsigtime(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_tsigtime(output, rdf)

def ldns_rdf2buffer_str_apl(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_apl(output, rdf)

def ldns_rdf2buffer_str_int16_data(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_int16_data(output, rdf)

def ldns_rdf2buffer_str_ipseckey(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_ipseckey(output, rdf)

def ldns_rdf2buffer_str(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str(output, rdf)

def ldns_rr2buffer_str(output, rr):
    """LDNS buffer."""
    return _ldns.ldns_rr2buffer_str(output, rr)

def ldns_rr2buffer_str_fmt(output, fmt, rr):
    """LDNS buffer."""
    return _ldns.ldns_rr2buffer_str_fmt(output, fmt, rr)

def ldns_pkt2buffer_str(output, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt2buffer_str(output, pkt)

def ldns_pkt2buffer_str_fmt(output, fmt, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt2buffer_str_fmt(output, fmt, pkt)

def ldns_rdf2buffer_str_nsec3_salt(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_nsec3_salt(output, rdf)

def ldns_key2buffer_str(output, k):
    """LDNS buffer."""
    return _ldns.ldns_key2buffer_str(output, k)

def ldns_rdf2buffer_str_int8(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_int8(output, rdf)

def ldns_rdf2buffer_str_int16(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_int16(output, rdf)

def ldns_rdf2buffer_str_int32(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_int32(output, rdf)

def ldns_rdf2buffer_str_time(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_time(output, rdf)

def ldns_rdf2buffer_str_ilnp64(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_ilnp64(output, rdf)

def ldns_rdf2buffer_str_eui48(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_eui48(output, rdf)

def ldns_rdf2buffer_str_eui64(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_eui64(output, rdf)

def ldns_rdf2buffer_str_tag(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_tag(output, rdf)

def ldns_rdf2buffer_str_long_str(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_long_str(output, rdf)

def ldns_rdf2buffer_str_hip(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_hip(output, rdf)

def ldns_rdf2str(rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2str(rdf)

def ldns_rr2str(rr):
    """LDNS buffer."""
    return _ldns.ldns_rr2str(rr)

def ldns_rr2str_fmt(fmt, rr):
    """LDNS buffer."""
    return _ldns.ldns_rr2str_fmt(fmt, rr)

def ldns_pkt2str(pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt2str(pkt)

def ldns_pkt2str_fmt(fmt, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt2str_fmt(fmt, pkt)

def ldns_key2str(k):
    """LDNS buffer."""
    return _ldns.ldns_key2str(k)

def ldns_rr_list2str(rr_list):
    """LDNS buffer."""
    return _ldns.ldns_rr_list2str(rr_list)

def ldns_rr_list2str_fmt(fmt, rr_list):
    """LDNS buffer."""
    return _ldns.ldns_rr_list2str_fmt(fmt, rr_list)

def ldns_buffer2str(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer2str(buffer)

def ldns_buffer_export2str(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer_export2str(buffer)

def ldns_rdf_print(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf_print(output, rdf)

def ldns_rr_print(output, rr):
    """LDNS buffer."""
    return _ldns.ldns_rr_print(output, rr)

def ldns_rr_print_fmt(output, fmt, rr):
    """LDNS buffer."""
    return _ldns.ldns_rr_print_fmt(output, fmt, rr)

def ldns_pkt_print(output, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt_print(output, pkt)

def ldns_pkt_print_fmt(output, fmt, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt_print_fmt(output, fmt, pkt)

def ldns_rr_list2buffer_str(output, list):
    """LDNS buffer."""
    return _ldns.ldns_rr_list2buffer_str(output, list)

def ldns_rr_list2buffer_str_fmt(output, fmt, list):
    """LDNS buffer."""
    return _ldns.ldns_rr_list2buffer_str_fmt(output, fmt, list)

def ldns_pktheader2buffer_str(output, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pktheader2buffer_str(output, pkt)

def ldns_rr_list_print(output, list):
    """LDNS buffer."""
    return _ldns.ldns_rr_list_print(output, list)

def ldns_rr_list_print_fmt(output, fmt, list):
    """LDNS buffer."""
    return _ldns.ldns_rr_list_print_fmt(output, fmt, list)

def ldns_resolver_print(output, r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_print(output, r)

def ldns_resolver_print_fmt(output, fmt, r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_print_fmt(output, fmt, r)

def ldns_zone_print(output, z):
    """LDNS buffer."""
    return _ldns.ldns_zone_print(output, z)

def ldns_zone_print_fmt(output, fmt, z):
    """LDNS buffer."""
    return _ldns.ldns_zone_print_fmt(output, fmt, z)

def ldns_rdf2buffer_str_dname(output, dname):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_str_dname(output, dname)

def ldns_dname2buffer_wire(buffer, name):
    """LDNS buffer."""
    return _ldns.ldns_dname2buffer_wire(buffer, name)

def ldns_dname2buffer_wire_compress(buffer, name, compression_data):
    """LDNS buffer."""
    return _ldns.ldns_dname2buffer_wire_compress(buffer, name, compression_data)

def ldns_rdf2buffer_wire(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_wire(output, rdf)

def ldns_rdf2buffer_wire_compress(output, rdf, compression_data):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_wire_compress(output, rdf, compression_data)

def ldns_rdf2buffer_wire_canonical(output, rdf):
    """LDNS buffer."""
    return _ldns.ldns_rdf2buffer_wire_canonical(output, rdf)

def ldns_rr2buffer_wire(output, rr, section):
    """LDNS buffer."""
    return _ldns.ldns_rr2buffer_wire(output, rr, section)

def ldns_rr2buffer_wire_compress(output, rr, section, compression_data):
    """LDNS buffer."""
    return _ldns.ldns_rr2buffer_wire_compress(output, rr, section, compression_data)

def ldns_rr2buffer_wire_canonical(output, rr, section):
    """LDNS buffer."""
    return _ldns.ldns_rr2buffer_wire_canonical(output, rr, section)

def ldns_rrsig2buffer_wire(output, sigrr):
    """LDNS buffer."""
    return _ldns.ldns_rrsig2buffer_wire(output, sigrr)

def ldns_rr_rdata2buffer_wire(output, rr):
    """LDNS buffer."""
    return _ldns.ldns_rr_rdata2buffer_wire(output, rr)

def ldns_pkt2buffer_wire(output, pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt2buffer_wire(output, pkt)

def ldns_rr_list2buffer_wire(output, rrlist):
    """LDNS buffer."""
    return _ldns.ldns_rr_list2buffer_wire(output, rrlist)

def ldns_rdf2wire(dest, rdf, size):
    """LDNS buffer."""
    return _ldns.ldns_rdf2wire(dest, rdf, size)

def ldns_rr2wire(dest, rr, section, size):
    """LDNS buffer."""
    return _ldns.ldns_rr2wire(dest, rr, section, size)

def ldns_pkt2wire(dest, p, size):
    """LDNS buffer."""
    return _ldns.ldns_pkt2wire(dest, p, size)
LDNS_DEFAULT_TIMEOUT_SEC = _ldns.LDNS_DEFAULT_TIMEOUT_SEC
LDNS_DEFAULT_TIMEOUT_USEC = _ldns.LDNS_DEFAULT_TIMEOUT_USEC

def ldns_udp_send(result, qbin, to, tolen, timeout, answersize):
    """LDNS buffer."""
    return _ldns.ldns_udp_send(result, qbin, to, tolen, timeout, answersize)

def ldns_udp_bgsend(qbin, to, tolen, timeout):
    """LDNS buffer."""
    return _ldns.ldns_udp_bgsend(qbin, to, tolen, timeout)

def ldns_tcp_bgsend(qbin, to, tolen, timeout):
    """LDNS buffer."""
    return _ldns.ldns_tcp_bgsend(qbin, to, tolen, timeout)

def ldns_tcp_send(result, qbin, to, tolen, timeout, answersize):
    """LDNS buffer."""
    return _ldns.ldns_tcp_send(result, qbin, to, tolen, timeout, answersize)

def ldns_send(r, query_pkt):
    """LDNS buffer."""
    return _ldns.ldns_send(r, query_pkt)

def ldns_send_buffer(r, qb, tsig_mac):
    """LDNS buffer."""
    return _ldns.ldns_send_buffer(r, qb, tsig_mac)

def ldns_tcp_connect(to, tolen, timeout):
    """LDNS buffer."""
    return _ldns.ldns_tcp_connect(to, tolen, timeout)

def ldns_udp_connect(to, timeout):
    """LDNS buffer."""
    return _ldns.ldns_udp_connect(to, timeout)

def ldns_tcp_send_query(qbin, sockfd, to, tolen):
    """LDNS buffer."""
    return _ldns.ldns_tcp_send_query(qbin, sockfd, to, tolen)

def ldns_udp_send_query(qbin, sockfd, to, tolen):
    """LDNS buffer."""
    return _ldns.ldns_udp_send_query(qbin, sockfd, to, tolen)

def ldns_tcp_read_wire_timeout(sockfd, size, timeout):
    """LDNS buffer."""
    return _ldns.ldns_tcp_read_wire_timeout(sockfd, size, timeout)

def ldns_tcp_read_wire(sockfd, size):
    """LDNS buffer."""
    return _ldns.ldns_tcp_read_wire(sockfd, size)

def ldns_udp_read_wire(sockfd, size, fr, frlen):
    """LDNS buffer."""
    return _ldns.ldns_udp_read_wire(sockfd, size, fr, frlen)

def ldns_rdf2native_sockaddr_storage(rd, port, size):
    """LDNS buffer."""
    return _ldns.ldns_rdf2native_sockaddr_storage(rd, port, size)

def ldns_sockaddr_storage2rdf(sock, port):
    """LDNS buffer."""
    return _ldns.ldns_sockaddr_storage2rdf(sock, port)

def ldns_axfr_start(resolver, domain, c):
    """LDNS buffer."""
    return _ldns.ldns_axfr_start(resolver, domain, c)
LDNS_MAX_PACKETLEN = _ldns.LDNS_MAX_PACKETLEN
LDNS_QR = _ldns.LDNS_QR
LDNS_AA = _ldns.LDNS_AA
LDNS_TC = _ldns.LDNS_TC
LDNS_RD = _ldns.LDNS_RD
LDNS_CD = _ldns.LDNS_CD
LDNS_RA = _ldns.LDNS_RA
LDNS_AD = _ldns.LDNS_AD
LDNS_PACKET_QUERY = _ldns.LDNS_PACKET_QUERY
LDNS_PACKET_IQUERY = _ldns.LDNS_PACKET_IQUERY
LDNS_PACKET_STATUS = _ldns.LDNS_PACKET_STATUS
LDNS_PACKET_NOTIFY = _ldns.LDNS_PACKET_NOTIFY
LDNS_PACKET_UPDATE = _ldns.LDNS_PACKET_UPDATE
LDNS_RCODE_NOERROR = _ldns.LDNS_RCODE_NOERROR
LDNS_RCODE_FORMERR = _ldns.LDNS_RCODE_FORMERR
LDNS_RCODE_SERVFAIL = _ldns.LDNS_RCODE_SERVFAIL
LDNS_RCODE_NXDOMAIN = _ldns.LDNS_RCODE_NXDOMAIN
LDNS_RCODE_NOTIMPL = _ldns.LDNS_RCODE_NOTIMPL
LDNS_RCODE_REFUSED = _ldns.LDNS_RCODE_REFUSED
LDNS_RCODE_YXDOMAIN = _ldns.LDNS_RCODE_YXDOMAIN
LDNS_RCODE_YXRRSET = _ldns.LDNS_RCODE_YXRRSET
LDNS_RCODE_NXRRSET = _ldns.LDNS_RCODE_NXRRSET
LDNS_RCODE_NOTAUTH = _ldns.LDNS_RCODE_NOTAUTH
LDNS_RCODE_NOTZONE = _ldns.LDNS_RCODE_NOTZONE
class ldns_struct_hdr(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_hdr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_hdr, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_id"] = _ldns.ldns_struct_hdr__id_set
    __swig_getmethods__["_id"] = _ldns.ldns_struct_hdr__id_get
    if _newclass:
        _id = _swig_property(_ldns.ldns_struct_hdr__id_get, _ldns.ldns_struct_hdr__id_set)
    __swig_setmethods__["_qr"] = _ldns.ldns_struct_hdr__qr_set
    __swig_getmethods__["_qr"] = _ldns.ldns_struct_hdr__qr_get
    if _newclass:
        _qr = _swig_property(_ldns.ldns_struct_hdr__qr_get, _ldns.ldns_struct_hdr__qr_set)
    __swig_setmethods__["_aa"] = _ldns.ldns_struct_hdr__aa_set
    __swig_getmethods__["_aa"] = _ldns.ldns_struct_hdr__aa_get
    if _newclass:
        _aa = _swig_property(_ldns.ldns_struct_hdr__aa_get, _ldns.ldns_struct_hdr__aa_set)
    __swig_setmethods__["_tc"] = _ldns.ldns_struct_hdr__tc_set
    __swig_getmethods__["_tc"] = _ldns.ldns_struct_hdr__tc_get
    if _newclass:
        _tc = _swig_property(_ldns.ldns_struct_hdr__tc_get, _ldns.ldns_struct_hdr__tc_set)
    __swig_setmethods__["_rd"] = _ldns.ldns_struct_hdr__rd_set
    __swig_getmethods__["_rd"] = _ldns.ldns_struct_hdr__rd_get
    if _newclass:
        _rd = _swig_property(_ldns.ldns_struct_hdr__rd_get, _ldns.ldns_struct_hdr__rd_set)
    __swig_setmethods__["_cd"] = _ldns.ldns_struct_hdr__cd_set
    __swig_getmethods__["_cd"] = _ldns.ldns_struct_hdr__cd_get
    if _newclass:
        _cd = _swig_property(_ldns.ldns_struct_hdr__cd_get, _ldns.ldns_struct_hdr__cd_set)
    __swig_setmethods__["_ra"] = _ldns.ldns_struct_hdr__ra_set
    __swig_getmethods__["_ra"] = _ldns.ldns_struct_hdr__ra_get
    if _newclass:
        _ra = _swig_property(_ldns.ldns_struct_hdr__ra_get, _ldns.ldns_struct_hdr__ra_set)
    __swig_setmethods__["_ad"] = _ldns.ldns_struct_hdr__ad_set
    __swig_getmethods__["_ad"] = _ldns.ldns_struct_hdr__ad_get
    if _newclass:
        _ad = _swig_property(_ldns.ldns_struct_hdr__ad_get, _ldns.ldns_struct_hdr__ad_set)
    __swig_setmethods__["_opcode"] = _ldns.ldns_struct_hdr__opcode_set
    __swig_getmethods__["_opcode"] = _ldns.ldns_struct_hdr__opcode_get
    if _newclass:
        _opcode = _swig_property(_ldns.ldns_struct_hdr__opcode_get, _ldns.ldns_struct_hdr__opcode_set)
    __swig_setmethods__["_rcode"] = _ldns.ldns_struct_hdr__rcode_set
    __swig_getmethods__["_rcode"] = _ldns.ldns_struct_hdr__rcode_get
    if _newclass:
        _rcode = _swig_property(_ldns.ldns_struct_hdr__rcode_get, _ldns.ldns_struct_hdr__rcode_set)
    __swig_setmethods__["_qdcount"] = _ldns.ldns_struct_hdr__qdcount_set
    __swig_getmethods__["_qdcount"] = _ldns.ldns_struct_hdr__qdcount_get
    if _newclass:
        _qdcount = _swig_property(_ldns.ldns_struct_hdr__qdcount_get, _ldns.ldns_struct_hdr__qdcount_set)
    __swig_setmethods__["_ancount"] = _ldns.ldns_struct_hdr__ancount_set
    __swig_getmethods__["_ancount"] = _ldns.ldns_struct_hdr__ancount_get
    if _newclass:
        _ancount = _swig_property(_ldns.ldns_struct_hdr__ancount_get, _ldns.ldns_struct_hdr__ancount_set)
    __swig_setmethods__["_nscount"] = _ldns.ldns_struct_hdr__nscount_set
    __swig_getmethods__["_nscount"] = _ldns.ldns_struct_hdr__nscount_get
    if _newclass:
        _nscount = _swig_property(_ldns.ldns_struct_hdr__nscount_get, _ldns.ldns_struct_hdr__nscount_set)
    __swig_setmethods__["_arcount"] = _ldns.ldns_struct_hdr__arcount_set
    __swig_getmethods__["_arcount"] = _ldns.ldns_struct_hdr__arcount_get
    if _newclass:
        _arcount = _swig_property(_ldns.ldns_struct_hdr__arcount_get, _ldns.ldns_struct_hdr__arcount_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_hdr()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_hdr
    __del__ = lambda self: None
ldns_struct_hdr_swigregister = _ldns.ldns_struct_hdr_swigregister
ldns_struct_hdr_swigregister(ldns_struct_hdr)

class ldns_pkt(_object):
    """
    LDNS packet object. 

    The :class:`ldns_pkt` object contains DNS packed (either a query or an answer).
    It is the complete representation of what you actually send to a name server,
    and what you get back (see :class:`ldns.ldns_resolver`).

    **Usage**

    >>> import ldns
    >>> resolver = ldns.ldns_resolver.new_frm_file("/etc/resolv.conf")
    >>> pkt = resolver.query("nic.cz", ldns.LDNS_RR_TYPE_NS,ldns.LDNS_RR_CLASS_IN)
    >>> print pkt
    ;; ->>HEADER<<- opcode: QUERY, rcode: NOERROR, id: 63004
    ;; flags: qr rd ra ; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0 
    ;; QUESTION SECTION:
    ;; nic.cz.	IN	NS
    ;; ANSWER SECTION:
    nic.cz.	758	IN	NS	a.ns.nic.cz.
    nic.cz.	758	IN	NS	c.ns.nic.cz.
    nic.cz.	758	IN	NS	e.ns.nic.cz.
    ;; AUTHORITY SECTION:
    ;; ADDITIONAL SECTION:
    ;; Query time: 8 msec
    ;; SERVER: 82.100.38.2
    ;; WHEN: Thu Jan 11 12:54:33 2009
    ;; MSG SIZE  rcvd: 75

    This simple example instances a resolver in order to resolve NS for nic.cz.
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_pkt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_pkt, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_header"] = _ldns.ldns_pkt__header_set
    __swig_getmethods__["_header"] = _ldns.ldns_pkt__header_get
    if _newclass:
        _header = _swig_property(_ldns.ldns_pkt__header_get, _ldns.ldns_pkt__header_set)
    __swig_setmethods__["_answerfrom"] = _ldns.ldns_pkt__answerfrom_set
    __swig_getmethods__["_answerfrom"] = _ldns.ldns_pkt__answerfrom_get
    if _newclass:
        _answerfrom = _swig_property(_ldns.ldns_pkt__answerfrom_get, _ldns.ldns_pkt__answerfrom_set)
    __swig_setmethods__["timestamp"] = _ldns.ldns_pkt_timestamp_set
    __swig_getmethods__["timestamp"] = _ldns.ldns_pkt_timestamp_get
    if _newclass:
        timestamp = _swig_property(_ldns.ldns_pkt_timestamp_get, _ldns.ldns_pkt_timestamp_set)
    __swig_setmethods__["_querytime"] = _ldns.ldns_pkt__querytime_set
    __swig_getmethods__["_querytime"] = _ldns.ldns_pkt__querytime_get
    if _newclass:
        _querytime = _swig_property(_ldns.ldns_pkt__querytime_get, _ldns.ldns_pkt__querytime_set)
    __swig_setmethods__["_size"] = _ldns.ldns_pkt__size_set
    __swig_getmethods__["_size"] = _ldns.ldns_pkt__size_get
    if _newclass:
        _size = _swig_property(_ldns.ldns_pkt__size_get, _ldns.ldns_pkt__size_set)
    __swig_setmethods__["_tsig_rr"] = _ldns.ldns_pkt__tsig_rr_set
    __swig_getmethods__["_tsig_rr"] = _ldns.ldns_pkt__tsig_rr_get
    if _newclass:
        _tsig_rr = _swig_property(_ldns.ldns_pkt__tsig_rr_get, _ldns.ldns_pkt__tsig_rr_set)
    __swig_setmethods__["_edns_udp_size"] = _ldns.ldns_pkt__edns_udp_size_set
    __swig_getmethods__["_edns_udp_size"] = _ldns.ldns_pkt__edns_udp_size_get
    if _newclass:
        _edns_udp_size = _swig_property(_ldns.ldns_pkt__edns_udp_size_get, _ldns.ldns_pkt__edns_udp_size_set)
    __swig_setmethods__["_edns_extended_rcode"] = _ldns.ldns_pkt__edns_extended_rcode_set
    __swig_getmethods__["_edns_extended_rcode"] = _ldns.ldns_pkt__edns_extended_rcode_get
    if _newclass:
        _edns_extended_rcode = _swig_property(_ldns.ldns_pkt__edns_extended_rcode_get, _ldns.ldns_pkt__edns_extended_rcode_set)
    __swig_setmethods__["_edns_version"] = _ldns.ldns_pkt__edns_version_set
    __swig_getmethods__["_edns_version"] = _ldns.ldns_pkt__edns_version_get
    if _newclass:
        _edns_version = _swig_property(_ldns.ldns_pkt__edns_version_get, _ldns.ldns_pkt__edns_version_set)
    __swig_setmethods__["_edns_present"] = _ldns.ldns_pkt__edns_present_set
    __swig_getmethods__["_edns_present"] = _ldns.ldns_pkt__edns_present_get
    if _newclass:
        _edns_present = _swig_property(_ldns.ldns_pkt__edns_present_get, _ldns.ldns_pkt__edns_present_set)
    __swig_setmethods__["_edns_z"] = _ldns.ldns_pkt__edns_z_set
    __swig_getmethods__["_edns_z"] = _ldns.ldns_pkt__edns_z_get
    if _newclass:
        _edns_z = _swig_property(_ldns.ldns_pkt__edns_z_get, _ldns.ldns_pkt__edns_z_set)
    __swig_setmethods__["_edns_data"] = _ldns.ldns_pkt__edns_data_set
    __swig_getmethods__["_edns_data"] = _ldns.ldns_pkt__edns_data_get
    if _newclass:
        _edns_data = _swig_property(_ldns.ldns_pkt__edns_data_get, _ldns.ldns_pkt__edns_data_set)
    __swig_setmethods__["_question"] = _ldns.ldns_pkt__question_set
    __swig_getmethods__["_question"] = _ldns.ldns_pkt__question_get
    if _newclass:
        _question = _swig_property(_ldns.ldns_pkt__question_get, _ldns.ldns_pkt__question_set)
    __swig_setmethods__["_answer"] = _ldns.ldns_pkt__answer_set
    __swig_getmethods__["_answer"] = _ldns.ldns_pkt__answer_get
    if _newclass:
        _answer = _swig_property(_ldns.ldns_pkt__answer_get, _ldns.ldns_pkt__answer_set)
    __swig_setmethods__["_authority"] = _ldns.ldns_pkt__authority_set
    __swig_getmethods__["_authority"] = _ldns.ldns_pkt__authority_get
    if _newclass:
        _authority = _swig_property(_ldns.ldns_pkt__authority_get, _ldns.ldns_pkt__authority_set)
    __swig_setmethods__["_additional"] = _ldns.ldns_pkt__additional_set
    __swig_getmethods__["_additional"] = _ldns.ldns_pkt__additional_get
    if _newclass:
        _additional = _swig_property(_ldns.ldns_pkt__additional_get, _ldns.ldns_pkt__additional_set)

    def __init__(self):
        """
           Cannot be created directly from Python.
        """
        raise Exception("This class can't be created directly. " +
            "Please use: ldns_pkt_new, ldns_pkt_query_new " +
            "or ldns_pkt_query_new_frm_str")

    __swig_destroy__ = _ldns._ldns_pkt_free

    #
    # LDNS_PKT_CONSTRUCTORS_
    #

    @staticmethod
    def new():
        """
           Creates new empty packet structure.

           :return: (:class:`ldns_pkt` ) New empty packet.
        """
        return _ldns.ldns_pkt_new()

    @staticmethod
    def new_query(rr_name, rr_type, rr_class, flags):
        """
           Creates a packet with a query in it for the given name,
           type and class.

           :param rr_name: The name to query for.
           :type rr_name: :class:`ldns_dname`
           :param rr_type: The type to query for.
           :type rr_type: ldns_rr_type
           :param rr_class: The class to query for.
           :type rr_class: ldns_rr_class
           :param flags: Packet flags.
           :type flags: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_pkt`) New object.

           .. note::
               The type checking of parameter `rr_name` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(rr_name, ldns_dname)) and \
           isinstance(rr_name, ldns_rdf) and \
           rr_name.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_pkt.new_query() method will" +
                " drop the possibility to accept ldns_rdf." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(rr_name, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (rr_name.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns._ldns_pkt_query_new(rr_name, rr_type, rr_class, flags)

    @staticmethod
    def new_query_frm_str(rr_name, rr_type, rr_class, flags, raiseException = True):
        """
           Creates a query packet for the given name, type, class.

           :param rr_name: The name to query for.
           :type rr_name: str
           :param rr_type: The type to query for.
           :type rr_type: ldns_rr_type
           :param rr_class: The class to query for.
           :type rr_class: ldns_rr_class
           :param flags: Packet flags.
           :type flags: uint16_t
           :param raiseException: If True, an exception occurs in case a
               packet object can't be created.
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When raiseException set and packet couldn't
               be created.
           :return: (:class:`ldns_pkt`) Query packet object or None.
               If the object can't be created and raiseException is True,
               an exception occurs.


           **Usage**

           >>> pkt = ldns.ldns_pkt.new_query_frm_str("test.nic.cz",ldns.LDNS_RR_TYPE_ANY, ldns.LDNS_RR_CLASS_IN, ldns.LDNS_QR | ldns.LDNS_AA)
           >>> rra = ldns.ldns_rr.new_frm_str("test.nic.cz. IN A 192.168.1.1",300)
           >>> list = ldns.ldns_rr_list()
           >>> if (rra): list.push_rr(rra)
           >>> pkt.push_rr_list(ldns.LDNS_SECTION_ANSWER, list)
           >>> print pkt
           ;; ->>HEADER<<- opcode: QUERY, rcode: NOERROR, id: 0
           ;; flags: qr aa ; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 
           ;; QUESTION SECTION:
           ;; test.nic.cz.	IN	ANY
           ;; ANSWER SECTION:
           test.nic.cz.	300	IN	A	192.168.1.1
           ;; AUTHORITY SECTION:
           ;; ADDITIONAL SECTION:
           ;; Query time: 0 msec
           ;; WHEN: Thu Jan  1 01:00:00 1970
           ;; MSG SIZE  rcvd: 0
        """
        status, pkt = _ldns.ldns_pkt_query_new_frm_str(rr_name, rr_type, rr_class, flags)
        if status != LDNS_STATUS_OK:
            if (raiseException): raise Exception("Can't create query packet, error: %d" % status)
            return None
        return pkt

    #
    # _LDNS_PKT_CONSTRUCTORS
    #

    def __str__(self):
        """
           Converts the data in the DNS packet to presentation format.

           :return: (str)
        """
        return _ldns.ldns_pkt2str(self)

    def opcode2str(self):
        """
           Converts a packet opcode to its mnemonic and returns that as an
           allocated null-terminated string.

           :return: (str)
        """
        return _ldns.ldns_pkt_opcode2str(self.get_opcode())

    def rcode2str(self):
        """
           Converts a packet rcode to its mnemonic and returns that as an
           allocated null-terminated string.

           :return: (str)
        """
        return _ldns.ldns_pkt_rcode2str(self.get_rcode())

    def print_to_file(self, output):
        """
           Prints the data in the DNS packet to the given file stream
           (in presentation format).

           :param output: Opened file to write to.
           :type output: file
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_print(output, self)
    #parameters: FILE *,const ldns_pkt *,

    def write_to_buffer(self, buffer):
        """
           Copies the packet data to the buffer in wire format.

           :param buffer: Buffer to append the result to.
           :type buffer: :class:`ldns_buffer`
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_pkt2buffer_wire(buffer, self)
    #parameters: ldns_buffer *,const ldns_pkt *,
    #retvals: ldns_status

    @staticmethod
    def algorithm2str(alg):
        """
           Converts a signing algorithms to its mnemonic and returns that
           as an allocated null-terminated string.

           :param alg: The algorithm to convert to text.
           :type alg: ldns_algorithm
           :return: (str)
        """
        return _ldns.ldns_pkt_algorithm2str(alg)
    #parameters: ldns_algorithm,

    @staticmethod
    def cert_algorithm2str(alg):
        """
           Converts a cert algorithm to its mnemonic and returns that as an
           allocated null-terminated string.

           :param alg: Cert algorithm to convert to text.
           :type alg: ldns_cert_algorithm
           :return: (str)
        """
        return _ldns.ldns_pkt_cert_algorithm2str(alg)
    #parameters: ldns_algorithm,

    #
    # LDNS_PKT_METHODS_
    #

    def aa(self):
        """
           Read the packet's aa bit.

           :return: (bool) Value of the bit.
        """
        return _ldns.ldns_pkt_aa(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def ad(self):
        """
           Read the packet's ad bit.

           :return: (bool) Value of the bit.
        """
        return _ldns.ldns_pkt_ad(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def additional(self):
        """
           Return the packet's additional section.

           :return: (:class:`ldns_rr_list`) The additional section.
        """
        return _ldns._ldns_pkt_additional(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr_list *

    def all(self):
        """
           Return the packet's question, answer, authority and additional
           sections concatenated.

           :return: (:class:`ldns_rr_list`) Concatenated sections.
        """
        return _ldns.ldns_pkt_all(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr_list *

    def all_noquestion(self):
        """
           Return the packet's answer, authority and additional sections
           concatenated.
           Like :meth:`all` but without the questions.

           :return: (:class:`ldns_rr_list`) Concatenated sections except
               questions.
        """
        return _ldns.ldns_pkt_all_noquestion(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr_list *

    def ancount(self):
        """
           Return the packet's an count.

           :return: (int) The an count.
        """
        return _ldns.ldns_pkt_ancount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def answer(self):
        """
           Return the packet's answer section.

           :return: (:class:`ldns_rr_list`) The answer section.
        """
        return _ldns._ldns_pkt_answer(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr_list *

    def answerfrom(self):
        """
           Return the packet's answerfrom.

           :return: (:class:`ldns_rdf`) The name of the server.
        """
        return _ldns._ldns_pkt_answerfrom(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rdf *

    def arcount(self):
        """
           Return the packet's ar count.

           :return: (int) The ar count.
        """
        return _ldns.ldns_pkt_arcount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def authority(self):
        """
           Return the packet's authority section.

           :return: (:class:`ldns_rr_list`) The authority section.
        """
        return _ldns._ldns_pkt_authority(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr_list *

    def cd(self):
        """
           Read the packet's cd bit.

           :return: (bool) Value of the bit.
        """
        return _ldns.ldns_pkt_cd(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def clone(self):
        """
           Clones the packet, creating a fully allocated copy.

           :return: (:class:`ldns_pkt`) New packet clone.
        """
        return _ldns.ldns_pkt_clone(self)
    #parameters: ldns_pkt *,
    #retvals: ldns_pkt *

    def edns(self):
        """
           Returns True if this packet needs and EDNS rr to be sent.

           At the moment the only reason is an expected packet size larger
           than 512 bytes, but for instance DNSSEC would be a good reason
           too.

           :return: (bool) True if packet needs EDNS rr.
        """
        return _ldns.ldns_pkt_edns(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def edns_data(self):
        """
           Return the packet's edns data.

           :return: (:class:`ldns_rdf`) The ensd data.
        """
        return _ldns._ldns_pkt_edns_data(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rdf *

    def edns_do(self):
        """
           Return the packet's edns do bit

           :return: (bool) The bit's value.
        """
        return _ldns.ldns_pkt_edns_do(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def edns_extended_rcode(self):
        """
           Return the packet's edns extended rcode.

           :return: (uint8_t) The rcode.
        """
        return _ldns.ldns_pkt_edns_extended_rcode(self)
    #parameters: const ldns_pkt *,
    #retvals: uint8_t

    def edns_udp_size(self):
        """
           Return the packet's edns udp size.

           :return: (uint16_t) The udp size.
        """
        return _ldns.ldns_pkt_edns_udp_size(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def edns_version(self):
        """
           Return the packet's edns version.

           :return: (uint8_t) The edns version.
        """
        return _ldns.ldns_pkt_edns_version(self)
    #parameters: const ldns_pkt *,
    #retvals: uint8_t

    def edns_z(self):
        """
           Return the packet's edns z value.

           :return: (uint16_t) The z value.
        """
        return _ldns.ldns_pkt_edns_z(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def empty(self):
        """
           Check if a packet is empty.

           :return: (bool) True: empty, False: not empty
        """
        return _ldns.ldns_pkt_empty(self)
    #parameters: ldns_pkt *,
    #retvals: bool

    def get_opcode(self):
        """
           Read the packet's code.

           :return: (ldns_pkt_opcode) the opcode
        """
        return _ldns.ldns_pkt_get_opcode(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_pkt_opcode

    def get_rcode(self):
        """
           Return the packet's response code.

           :return: (ldns_pkt_rcode) The response code.
        """
        return _ldns.ldns_pkt_get_rcode(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_pkt_rcode

    def get_section_clone(self, s):
        """
           Return the selected rr_list's in the packet.

           :param s: What section(s) to return.
           :type s: ldns_pkt_section
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) RR list with the rr's or None
               if none were found.
        """
        return _ldns.ldns_pkt_get_section_clone(self, s)
    #parameters: const ldns_pkt *,ldns_pkt_section,
    #retvals: ldns_rr_list *

    def id(self):
        """
           Read the packet id.

           :return: (uint16_t) The packet id.
        """
        return _ldns.ldns_pkt_id(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def nscount(self):
        """
           Return the packet's ns count.

           :return: (uint16_t) The ns count.
        """
        return _ldns.ldns_pkt_nscount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def push_rr(self, section, rr):
        """
           Push an rr on a packet.

           :param section: Where to put it.
           :type section: ldns_pkt_section
           :param rr: RR to push.
           :type rr: :class:`ldns_rr`
           :throws TypeError: When arguments of inappropriate types.
           :return: (bool) A boolean which is True when the rr was added.
        """
        return _ldns._ldns_pkt_push_rr(self,section,rr)
    #parameters: ldns_pkt *,ldns_pkt_section,ldns_rr *,
    #retvals: bool

    def push_rr_list(self, section, list):
        """
           Push a rr_list on a packet.

           :param section: Where to put it.
           :type section: ldns_pkt_section
           :param list: The rr_list to push.
           :type list: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
           :return: (bool) A boolean which is True when the rr was added.
        """
        return _ldns._ldns_pkt_push_rr_list(self,section,list)
    #parameters: ldns_pkt *,ldns_pkt_section,ldns_rr_list *,
    #retvals: bool

    def qdcount(self):
        """
           Return the packet's qd count.

           :return: (uint16_t) The qd count.
        """
        return _ldns.ldns_pkt_qdcount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def qr(self):
        """
           Read the packet's qr bit.

           :return: (bool) value of the bit
        """
        return _ldns.ldns_pkt_qr(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def querytime(self):
        """
           Return the packet's query time.

           :return: (uint32_t) The query time.
        """
        return _ldns.ldns_pkt_querytime(self)
    #parameters: const ldns_pkt *,
    #retvals: uint32_t

    def question(self):
        """
           Return the packet's question section.

           :return: (:class:`ldns_rr_list`) The question section.
        """
        return _ldns._ldns_pkt_question(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr_list *

    def ra(self):
        """
           Read the packet's ra bit.

           :return: (bool) Value of the bit.
        """
        return _ldns.ldns_pkt_ra(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def rd(self):
        """
           Read the packet's rd bit.

           :return: (bool) Value of the bit.
        """
        return _ldns.ldns_pkt_rd(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def reply_type(self):
        """
           Looks inside the packet to determine what kind of packet it is,
           AUTH, NXDOMAIN, REFERRAL, etc.

           :return: (ldns_pkt_type) The type of packet.
        """
        return _ldns.ldns_pkt_reply_type(self)
    #parameters: ldns_pkt *,
    #retvals: ldns_pkt_type

    def rr(self, sec, rr):
        """
           Check to see if an rr exist in the packet.

           :param sec: In which section to look.
           :type sec: ldns_pkt_section
           :param rr: The rr to look for.
           :type rr: :class:`ldns_rr`
           :throws TypeError: When arguments of inappropriate types.
           :return: (bool) Return True is exists.
        """
        return _ldns.ldns_pkt_rr(self, sec, rr)
    #parameters: ldns_pkt *,ldns_pkt_section,ldns_rr *,
    #retvals: bool

    def rr_list_by_name(self, r, s):
        """
           Return all the rr with a specific name from a packet.

           :param r: The name.
           :type r: :class:`ldns_rdf`
           :param s: The packet's section.
           :type s: ldns_pkt_section
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) A list with the rr's or None
               if none were found.
        """
        return _ldns.ldns_pkt_rr_list_by_name(self,r,s)
    #parameters: ldns_pkt *,ldns_rdf *,ldns_pkt_section,
    #retvals: ldns_rr_list *

    def rr_list_by_name_and_type(self, ownername, atype, sec):
        """
           Return all the rr with a specific type and type from a packet.

           :param ownername: The name.
           :type ownername: :class:`ldns_rdf`
           :param atype: The type.
           :type atype: ldns_rr_type
           :param sec: The packet's section.
           :type sec: ldns_pkt_section
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) A list with the rr's or None
               if none were found.
        """
        return _ldns.ldns_pkt_rr_list_by_name_and_type(self, ownername, atype, sec)
    #parameters: const ldns_pkt *,const ldns_rdf *,ldns_rr_type,ldns_pkt_section,
    #retvals: ldns_rr_list *

    def rr_list_by_type(self, t, s):
        """
           Return all the rr with a specific type from a packet.

           :param t: The type.
           :type t: ldns_rr_type
           :param s: The packet's section.
           :type s: ldns_pkt_section
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) A list with the rr's or None
               if none were found.
        """
        return _ldns.ldns_pkt_rr_list_by_type(self, t, s)
    #parameters: const ldns_pkt *,ldns_rr_type,ldns_pkt_section,
    #retvals: ldns_rr_list *

    def safe_push_rr(self, sec, rr):
        """
           Push an rr on a packet, provided the RR is not there.

           :param sec: Where to put it.
           :type sec: ldns_pkt_section
           :param rr: RR to push.
           :type rr: :class:`ldns_rr`
           :throws TypeError: When arguments of inappropriate types.
           :return: (bool) A boolean which is True when the rr was added.
        """
        return _ldns._ldns_pkt_safe_push_rr(self,sec,rr)
    #parameters: ldns_pkt *,ldns_pkt_section,ldns_rr *,
    #retvals: bool

    def safe_push_rr_list(self, sec, list):
        """
           Push an rr_list to a packet, provided the RRs are not already
           there.

           :param sec: Where to put it.
           :type sec: ldns_pkt_section
           :param list: The rr_list to push.
           :type list: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
           :return: (bool) A boolean which is True when the list was added.
        """
        return _ldns._ldns_pkt_safe_push_rr_list(self, sec, list)
    #parameters: ldns_pkt *,ldns_pkt_section,ldns_rr_list *,
    #retvals: bool

    def set_aa(self, b):
        """
           Set the packet's aa bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_aa(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_ad(self, b):
        """
           Set the packet's ad bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_ad(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_additional(self, rr):
        """
           Directly set the additional section.

           :param rr: The rr list to set.
           :type rr: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_additional(self, rr)
    #parameters: ldns_pkt *,ldns_rr_list *,
    #retvals: 

    def set_ancount(self, c):
        """
           Set the packet's an count.

           :param c: The count.
           :type c: int
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_ancount(self, c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_answer(self, rr):
        """
           Directly set the answer section.

           :param rr: The rr list to set.
           :type rr: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_answer(self, rr)
    #parameters: ldns_pkt *,ldns_rr_list *,
    #retvals: 

    def set_answerfrom(self, r):
        """
           Set the packet's answering server.

           :param r: The address.
           :type r: :class:`ldns_rdf`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_answerfrom(self, r)
    #parameters: ldns_pkt *,ldns_rdf *,
    #retvals: 

    def set_arcount(self, c):
        """
           Set the packet's arcount.

           :param c: The count.
           :type c: int
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_arcount(self,c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_authority(self, rr):
        """
           Directly set the authority section.

           :param rr: The rr list to set.
           :type rr: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_authority(self, rr)
    #parameters: ldns_pkt *,ldns_rr_list *,
    #retvals: 

    def set_cd(self, b):
        """
           Set the packet's cd bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_cd(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_edns_data(self, data):
        """
           Set the packet's edns data.

           :param data: The data.
           :type data: :class:`ldns_rdf`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_edns_data(self, data)
    #parameters: ldns_pkt *,ldns_rdf *,
    #retvals: 

    def set_edns_do(self, value):
        """
           Set the packet's edns do bit.

           :param value: The bit's new value.
           :type value: bool
        """
        _ldns.ldns_pkt_set_edns_do(self, value)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_edns_extended_rcode(self, c):
        """
           Set the packet's edns extended rcode.

           :param c: The code.
           :type c: uint8_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_edns_extended_rcode(self, c)
    #parameters: ldns_pkt *,uint8_t,
    #retvals: 

    def set_edns_udp_size(self, s):
        """
           Set the packet's edns udp size.

           :param s: The size.
           :type s: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_edns_udp_size(self, s)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_edns_version(self, v):
        """
           Set the packet's edns version.

           :param v: The version.
           :type v: uint8_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_edns_version(self, v)
    #parameters: ldns_pkt *,uint8_t,
    #retvals: 

    def set_edns_z(self, z):
        """
           Set the packet's edns z value.

           :param z: The value.
           :type z: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_edns_z(self, z)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_flags(self, flags):
        """
           Sets the flags in a packet.

           :param flags: ORed values: LDNS_QR| LDNS_AR for instance.
           :type flags: int
           :throws TypeError: When arguments of inappropriate types.
           :return: (bool) True on success, False otherwise.
        """
        return _ldns.ldns_pkt_set_flags(self, flags)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: bool

    def set_id(self, id):
        """
           Set the packet's id.

           :param id: The id to set.
           :type id: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_id(self, id)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_nscount(self, c):
        """
           Set the packet's ns count.

           :param c: The count.
           :type c: int
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_nscount(self, c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_opcode(self, c):
        """
           Set the packet's opcode.

           :param c: The opcode.
           :type c: ldns_pkt_opcode
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_opcode(self, c)
    #parameters: ldns_pkt *,ldns_pkt_opcode,
    #retvals: 

    def set_qdcount(self, c):
        """
           Set the packet's qd count.

           :param c: The count.
           :type c: int
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_qdcount(self, c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def set_qr(self, b):
        """
           Set the packet's qr bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_qr(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_querytime(self, t):
        """
           Set the packet's query time.

           :param t: The query time in msec.
           :type t: uint32_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_querytime(self, t)
    #parameters: ldns_pkt *,uint32_t,
    #retvals: 

    def set_question(self, rr):
        """
           Directly set the question section.

           :param rr: The rr list to set.
           :type rr: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_question(self, rr)
    #parameters: ldns_pkt *,ldns_rr_list *,
    #retvals: 

    def set_ra(self, b):
        """
           Set the packet's ra bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_ra(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_random_id(self):
        """
           Set the packet's id to a random value.
        """
        _ldns.ldns_pkt_set_random_id(self)
    #parameters: ldns_pkt *,
    #retvals: 

    def set_rcode(self, c):
        """
           Set the packet's respons code.

           :param c: The rcode.
           :type c: uint8_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_rcode(self, c)
    #parameters: ldns_pkt *,uint8_t,
    #retvals: 

    def set_rd(self, b):
        """
           Set the packet's rd bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_rd(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_section_count(self, s, x):
        """
           Set a packet's section count to x.

           :param s: The section.
           :type s: ldns_pkt_section
           :param x: The section count.
           :type x: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_section_count(self, s, x)
    #parameters: ldns_pkt *,ldns_pkt_section,uint16_t,
    #retvals: 

    def set_size(self, s):
        """
           Set the packet's size.

           :param s: The size.
           :type s: int
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_size(self,s)
    #parameters: ldns_pkt *,size_t,
    #retvals: 

    def set_tc(self, b):
        """
           Set the packet's tc bit.

           :param b: The value to set.
           :type b: bool
        """
        _ldns.ldns_pkt_set_tc(self, b)
    #parameters: ldns_pkt *,bool,
    #retvals: 

    def set_timestamp(self, timeval):
        """
           Set the packet's time stamp.

           :param timestamp: The time stamp.
           :type timestamp: struct timeval
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_pkt_set_timestamp(self, timeval)
    #parameters: ldns_pkt *,struct timeval,
    #retvals: 

    def set_tsig(self, t):
        """
           Set the packet's tsig rr.

           :param t: The tsig rr.
           :type t: :class:`ldns_rr`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_pkt_set_tsig(self, t)
    #parameters: ldns_pkt *,ldns_rr *,
    #retvals: 

    def size(self):
        """
           Return the packet's size in bytes.

           :return: (size_t) The size.
        """
        return _ldns.ldns_pkt_size(self)
    #parameters: const ldns_pkt *,
    #retvals: size_t

    def tc(self):
        """
           Read the packet's tc bit.

           :return: (bool) Value of the bit.
        """
        return _ldns.ldns_pkt_tc(self)
    #parameters: const ldns_pkt *,
    #retvals: bool

    def timestamp(self):
        """
           Return the packet's time stamp.

           :return: (struct timeval) The time stamp.
        """
        return _ldns.ldns_pkt_timestamp(self)
    #parameters: const ldns_pkt *,
    #retvals: struct timeval

    def tsig(self):
        """
           Return the packet's tsig pseudo rr's.

           :return: (:class:`ldns_rr`) The tsig rr.
        """
        return _ldns._ldns_pkt_tsig(self)
    #parameters: const ldns_pkt *,
    #retvals: ldns_rr *

    #
    # _LDNS_PKT_METHODS#
    #

    #
    # LDNS update methods
    #

    #
    # LDNS_METHODS_
    #

    def update_ad(self):
        """
           Get the ad count.

           :return: (uint16_t) The ad count.
        """
        return _ldns.ldns_update_ad(self)
    #parameters: ldns_pkt *
    #retvals: uint16_t

    def update_pkt_tsig_add(self, r):
        """
           Add tsig credentials to a packet from a resolver.

           :param r: Resolver to copy from.
           :type r: :class:`ldns_resolver`
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) Status whether successful or not.
        """
        return _ldns.ldns_update_pkt_tsig_add(self, r)
    #parameters: ldns_pkt *,ldns_resolver *,
    #retvals: ldns_status

    def update_prcount(self):
        """
           Get the pr count.

           :return: (uint16_t) The pr count.
        """
        return _ldns.ldns_update_prcount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def update_set_adcount(self, c):
        """
           Set the ad count.

           :param c: The ad count to set.
           :type c: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_update_set_adcount(self, c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def update_set_prcount(self, c):
        """
           Set the pr count.

           :param c: The pr count to set.
           :type c: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_update_set_prcount(self, c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def update_set_upcount(self, c):
        """
           Set the up count.

           :param c: The up count to set.
           :type c: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_update_set_upcount(self,c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def update_set_zo(self, c):
        """
           Set the zo count.

           :param c: The zo count to set.
           :type c: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_update_set_zo(self, c)
    #parameters: ldns_pkt *,uint16_t,
    #retvals: 

    def update_upcount(self):
        """
           Get the up count.

           :return: (uint16_t) The up count.
        """
        return _ldns.ldns_update_upcount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    def update_zocount(self):
        """
           Get the zo count.

           :return: (uint16_t) The zo count.
        """
        return _ldns.ldns_update_zocount(self)
    #parameters: const ldns_pkt *,
    #retvals: uint16_t

    #
    # _LDNS_METHODS
    #

ldns_pkt_swigregister = _ldns.ldns_pkt_swigregister
ldns_pkt_swigregister(ldns_pkt)

LDNS_SECTION_QUESTION = _ldns.LDNS_SECTION_QUESTION
LDNS_SECTION_ANSWER = _ldns.LDNS_SECTION_ANSWER
LDNS_SECTION_AUTHORITY = _ldns.LDNS_SECTION_AUTHORITY
LDNS_SECTION_ADDITIONAL = _ldns.LDNS_SECTION_ADDITIONAL
LDNS_SECTION_ANY = _ldns.LDNS_SECTION_ANY
LDNS_SECTION_ANY_NOQUESTION = _ldns.LDNS_SECTION_ANY_NOQUESTION
LDNS_PACKET_QUESTION = _ldns.LDNS_PACKET_QUESTION
LDNS_PACKET_REFERRAL = _ldns.LDNS_PACKET_REFERRAL
LDNS_PACKET_ANSWER = _ldns.LDNS_PACKET_ANSWER
LDNS_PACKET_NXDOMAIN = _ldns.LDNS_PACKET_NXDOMAIN
LDNS_PACKET_NODATA = _ldns.LDNS_PACKET_NODATA
LDNS_PACKET_UNKNOWN = _ldns.LDNS_PACKET_UNKNOWN

def ldns_pkt_id(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_id(p)

def ldns_pkt_qr(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_qr(p)

def ldns_pkt_aa(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_aa(p)

def ldns_pkt_tc(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_tc(p)

def ldns_pkt_rd(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rd(p)

def ldns_pkt_cd(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_cd(p)

def ldns_pkt_ra(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_ra(p)

def ldns_pkt_ad(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_ad(p)

def ldns_pkt_get_opcode(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_get_opcode(p)

def ldns_pkt_get_rcode(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_get_rcode(p)

def ldns_pkt_qdcount(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_qdcount(p)

def ldns_pkt_ancount(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_ancount(p)

def ldns_pkt_nscount(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_nscount(p)

def ldns_pkt_arcount(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_arcount(p)

def __ldns_pkt_answerfrom(p):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_answerfrom(p)

def ldns_pkt_timestamp(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_timestamp(p)

def ldns_pkt_querytime(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_querytime(p)

def ldns_pkt_size(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_size(p)

def ldns_pkt_section_count(p, s):
    """LDNS buffer."""
    return _ldns.ldns_pkt_section_count(p, s)

def __ldns_pkt_tsig(p):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_tsig(p)

def __ldns_pkt_question(p):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_question(p)

def __ldns_pkt_answer(p):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_answer(p)

def __ldns_pkt_authority(p):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_authority(p)

def __ldns_pkt_additional(p):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_additional(p)

def ldns_pkt_all(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_all(p)

def ldns_pkt_all_noquestion(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_all_noquestion(p)

def ldns_pkt_get_section_clone(p, s):
    """LDNS buffer."""
    return _ldns.ldns_pkt_get_section_clone(p, s)

def ldns_pkt_rr_list_by_name(p, r, s):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rr_list_by_name(p, r, s)

def ldns_pkt_rr_list_by_type(p, t, s):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rr_list_by_type(p, t, s)

def ldns_pkt_rr_list_by_name_and_type(packet, ownername, type, sec):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rr_list_by_name_and_type(packet, ownername, type, sec)

def ldns_pkt_rr(pkt, sec, rr):
    """LDNS buffer."""
    return _ldns.ldns_pkt_rr(pkt, sec, rr)

def ldns_pkt_set_flags(pkt, flags):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_flags(pkt, flags)

def ldns_pkt_set_id(p, id):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_id(p, id)

def ldns_pkt_set_random_id(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_random_id(p)

def ldns_pkt_set_qr(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_qr(p, b)

def ldns_pkt_set_aa(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_aa(p, b)

def ldns_pkt_set_tc(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_tc(p, b)

def ldns_pkt_set_rd(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_rd(p, b)

def ldns_pkt_set_cd(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_cd(p, b)

def ldns_pkt_set_ra(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_ra(p, b)

def ldns_pkt_set_ad(p, b):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_ad(p, b)

def ldns_pkt_set_opcode(p, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_opcode(p, c)

def ldns_pkt_set_rcode(p, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_rcode(p, c)

def ldns_pkt_set_qdcount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_qdcount(p, c)

def ldns_pkt_set_ancount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_ancount(p, c)

def ldns_pkt_set_nscount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_nscount(p, c)

def ldns_pkt_set_arcount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_arcount(p, c)

def __ldns_pkt_set_answerfrom(p, r):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_answerfrom(p, r)

def ldns_pkt_set_querytime(p, t):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_querytime(p, t)

def ldns_pkt_set_size(p, s):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_size(p, s)

def ldns_pkt_set_timestamp(p, timeval):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_timestamp(p, timeval)

def ldns_pkt_set_section_count(p, s, x):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_section_count(p, s, x)

def __ldns_pkt_set_tsig(p, t):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_tsig(p, t)

def ldns_pkt_reply_type(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_reply_type(p)

def ldns_pkt_edns_udp_size(packet):
    """LDNS buffer."""
    return _ldns.ldns_pkt_edns_udp_size(packet)

def ldns_pkt_edns_extended_rcode(packet):
    """LDNS buffer."""
    return _ldns.ldns_pkt_edns_extended_rcode(packet)

def ldns_pkt_edns_version(packet):
    """LDNS buffer."""
    return _ldns.ldns_pkt_edns_version(packet)

def ldns_pkt_edns_z(packet):
    """LDNS buffer."""
    return _ldns.ldns_pkt_edns_z(packet)

def __ldns_pkt_edns_data(packet):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_edns_data(packet)

def ldns_pkt_edns_do(packet):
    """LDNS buffer."""
    return _ldns.ldns_pkt_edns_do(packet)

def ldns_pkt_set_edns_do(packet, value):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_edns_do(packet, value)

def ldns_pkt_edns(packet):
    """LDNS buffer."""
    return _ldns.ldns_pkt_edns(packet)

def ldns_pkt_set_edns_udp_size(packet, s):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_edns_udp_size(packet, s)

def ldns_pkt_set_edns_extended_rcode(packet, c):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_edns_extended_rcode(packet, c)

def ldns_pkt_set_edns_version(packet, v):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_edns_version(packet, v)

def ldns_pkt_set_edns_z(packet, z):
    """LDNS buffer."""
    return _ldns.ldns_pkt_set_edns_z(packet, z)

def __ldns_pkt_set_edns_data(packet, data):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_edns_data(packet, data)

def ldns_pkt_new():
    """LDNS buffer."""
    return _ldns.ldns_pkt_new()

def _ldns_pkt_free(packet):
    """LDNS buffer."""
    return _ldns._ldns_pkt_free(packet)

def ldns_pkt_query_new_frm_str(rr_name, rr_type, rr_class, flags):
    """LDNS buffer."""
    return _ldns.ldns_pkt_query_new_frm_str(rr_name, rr_type, rr_class, flags)

def ldns_pkt_ixfr_request_new_frm_str(rr_name, rr_class, flags, soa):
    """LDNS buffer."""
    return _ldns.ldns_pkt_ixfr_request_new_frm_str(rr_name, rr_class, flags, soa)

def __ldns_pkt_query_new(rr_name, rr_type, rr_class, flags):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_query_new(rr_name, rr_type, rr_class, flags)

def ldns_pkt_ixfr_request_new(rr_name, rr_class, flags, soa):
    """LDNS buffer."""
    return _ldns.ldns_pkt_ixfr_request_new(rr_name, rr_class, flags, soa)

def ldns_pkt_clone(pkt):
    """LDNS buffer."""
    return _ldns.ldns_pkt_clone(pkt)

def __ldns_pkt_set_additional(p, rr):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_additional(p, rr)

def __ldns_pkt_set_answer(p, rr):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_answer(p, rr)

def __ldns_pkt_set_question(p, rr):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_question(p, rr)

def __ldns_pkt_set_authority(p, rr):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_set_authority(p, rr)

def __ldns_pkt_push_rr(packet, section, rr):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_push_rr(packet, section, rr)

def __ldns_pkt_safe_push_rr(pkt, sec, rr):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_safe_push_rr(pkt, sec, rr)

def __ldns_pkt_push_rr_list(packet, section, list):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_push_rr_list(packet, section, list)

def __ldns_pkt_safe_push_rr_list(pkt, sec, list):
    """LDNS buffer."""
    return _ldns.__ldns_pkt_safe_push_rr_list(pkt, sec, list)

def ldns_pkt_empty(p):
    """LDNS buffer."""
    return _ldns.ldns_pkt_empty(p)
LDNS_MAX_RDFLEN = _ldns.LDNS_MAX_RDFLEN
LDNS_RDF_SIZE_BYTE = _ldns.LDNS_RDF_SIZE_BYTE
LDNS_RDF_SIZE_WORD = _ldns.LDNS_RDF_SIZE_WORD
LDNS_RDF_SIZE_DOUBLEWORD = _ldns.LDNS_RDF_SIZE_DOUBLEWORD
LDNS_RDF_SIZE_6BYTES = _ldns.LDNS_RDF_SIZE_6BYTES
LDNS_RDF_SIZE_8BYTES = _ldns.LDNS_RDF_SIZE_8BYTES
LDNS_RDF_SIZE_16BYTES = _ldns.LDNS_RDF_SIZE_16BYTES
LDNS_NSEC3_VARS_OPTOUT_MASK = _ldns.LDNS_NSEC3_VARS_OPTOUT_MASK
LDNS_RDF_TYPE_NONE = _ldns.LDNS_RDF_TYPE_NONE
LDNS_RDF_TYPE_DNAME = _ldns.LDNS_RDF_TYPE_DNAME
LDNS_RDF_TYPE_INT8 = _ldns.LDNS_RDF_TYPE_INT8
LDNS_RDF_TYPE_INT16 = _ldns.LDNS_RDF_TYPE_INT16
LDNS_RDF_TYPE_INT32 = _ldns.LDNS_RDF_TYPE_INT32
LDNS_RDF_TYPE_A = _ldns.LDNS_RDF_TYPE_A
LDNS_RDF_TYPE_AAAA = _ldns.LDNS_RDF_TYPE_AAAA
LDNS_RDF_TYPE_STR = _ldns.LDNS_RDF_TYPE_STR
LDNS_RDF_TYPE_APL = _ldns.LDNS_RDF_TYPE_APL
LDNS_RDF_TYPE_B32_EXT = _ldns.LDNS_RDF_TYPE_B32_EXT
LDNS_RDF_TYPE_B64 = _ldns.LDNS_RDF_TYPE_B64
LDNS_RDF_TYPE_HEX = _ldns.LDNS_RDF_TYPE_HEX
LDNS_RDF_TYPE_NSEC = _ldns.LDNS_RDF_TYPE_NSEC
LDNS_RDF_TYPE_TYPE = _ldns.LDNS_RDF_TYPE_TYPE
LDNS_RDF_TYPE_CLASS = _ldns.LDNS_RDF_TYPE_CLASS
LDNS_RDF_TYPE_CERT_ALG = _ldns.LDNS_RDF_TYPE_CERT_ALG
LDNS_RDF_TYPE_ALG = _ldns.LDNS_RDF_TYPE_ALG
LDNS_RDF_TYPE_UNKNOWN = _ldns.LDNS_RDF_TYPE_UNKNOWN
LDNS_RDF_TYPE_TIME = _ldns.LDNS_RDF_TYPE_TIME
LDNS_RDF_TYPE_PERIOD = _ldns.LDNS_RDF_TYPE_PERIOD
LDNS_RDF_TYPE_TSIGTIME = _ldns.LDNS_RDF_TYPE_TSIGTIME
LDNS_RDF_TYPE_HIP = _ldns.LDNS_RDF_TYPE_HIP
LDNS_RDF_TYPE_INT16_DATA = _ldns.LDNS_RDF_TYPE_INT16_DATA
LDNS_RDF_TYPE_SERVICE = _ldns.LDNS_RDF_TYPE_SERVICE
LDNS_RDF_TYPE_LOC = _ldns.LDNS_RDF_TYPE_LOC
LDNS_RDF_TYPE_WKS = _ldns.LDNS_RDF_TYPE_WKS
LDNS_RDF_TYPE_NSAP = _ldns.LDNS_RDF_TYPE_NSAP
LDNS_RDF_TYPE_ATMA = _ldns.LDNS_RDF_TYPE_ATMA
LDNS_RDF_TYPE_IPSECKEY = _ldns.LDNS_RDF_TYPE_IPSECKEY
LDNS_RDF_TYPE_NSEC3_SALT = _ldns.LDNS_RDF_TYPE_NSEC3_SALT
LDNS_RDF_TYPE_NSEC3_NEXT_OWNER = _ldns.LDNS_RDF_TYPE_NSEC3_NEXT_OWNER
LDNS_RDF_TYPE_ILNP64 = _ldns.LDNS_RDF_TYPE_ILNP64
LDNS_RDF_TYPE_EUI48 = _ldns.LDNS_RDF_TYPE_EUI48
LDNS_RDF_TYPE_EUI64 = _ldns.LDNS_RDF_TYPE_EUI64
LDNS_RDF_TYPE_TAG = _ldns.LDNS_RDF_TYPE_TAG
LDNS_RDF_TYPE_LONG_STR = _ldns.LDNS_RDF_TYPE_LONG_STR
LDNS_RDF_TYPE_CERTIFICATE_USAGE = _ldns.LDNS_RDF_TYPE_CERTIFICATE_USAGE
LDNS_RDF_TYPE_SELECTOR = _ldns.LDNS_RDF_TYPE_SELECTOR
LDNS_RDF_TYPE_MATCHING_TYPE = _ldns.LDNS_RDF_TYPE_MATCHING_TYPE
LDNS_RDF_TYPE_BITMAP = _ldns.LDNS_RDF_TYPE_BITMAP
LDNS_CERT_PKIX = _ldns.LDNS_CERT_PKIX
LDNS_CERT_SPKI = _ldns.LDNS_CERT_SPKI
LDNS_CERT_PGP = _ldns.LDNS_CERT_PGP
LDNS_CERT_IPKIX = _ldns.LDNS_CERT_IPKIX
LDNS_CERT_ISPKI = _ldns.LDNS_CERT_ISPKI
LDNS_CERT_IPGP = _ldns.LDNS_CERT_IPGP
LDNS_CERT_ACPKIX = _ldns.LDNS_CERT_ACPKIX
LDNS_CERT_IACPKIX = _ldns.LDNS_CERT_IACPKIX
LDNS_CERT_URI = _ldns.LDNS_CERT_URI
LDNS_CERT_OID = _ldns.LDNS_CERT_OID
class ldns_rdf(_object):
    """
    Resource record data field.

    The data is a network ordered array of bytes, which size is specified
    by the (16-bit) size field. To correctly parse it, use the type
    specified in the (16-bit) type field with a value from ldns_rdf_type.
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_rdf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_rdf, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_size"] = _ldns.ldns_rdf__size_set
    __swig_getmethods__["_size"] = _ldns.ldns_rdf__size_get
    if _newclass:
        _size = _swig_property(_ldns.ldns_rdf__size_get, _ldns.ldns_rdf__size_set)
    __swig_setmethods__["_type"] = _ldns.ldns_rdf__type_set
    __swig_getmethods__["_type"] = _ldns.ldns_rdf__type_get
    if _newclass:
        _type = _swig_property(_ldns.ldns_rdf__type_get, _ldns.ldns_rdf__type_set)
    __swig_setmethods__["_data"] = _ldns.ldns_rdf__data_set
    __swig_getmethods__["_data"] = _ldns.ldns_rdf__data_get
    if _newclass:
        _data = _swig_property(_ldns.ldns_rdf__data_get, _ldns.ldns_rdf__data_set)

    def __init__(self):
        """
           Cannot be created directly from Python.
        """
        raise Exception("This class can't be created directly. " +
            "Please use: ldns_rdf_new, ldns_rdf_new_frm_data, " +
            "ldns_rdf_new_frm_str, ldns_rdf_new_frm_fp, " +
            "ldns_rdf_new_frm_fp_l")

    __swig_destroy__ = _ldns._ldns_rdf_deep_free

    #
    # LDNS_RDF_CONSTRUCTORS_
    #

    @staticmethod
    def new_frm_str(string, rr_type, raiseException = True):
        """
           Creates a new rdf from a string of a given type.

           :param string: string to use
           :type string: string
           :param rr_type: The type of the rdf. See predefined `RDF_TYPE_`
               constants.
           :type rr_type: integer
           :param raiseException: If True, an exception occurs in case
               a RDF object can't be created.
           :type raiseException: bool
           :throws TypeError: When parameters of mismatching types.
           :throws Exception: When raiseException set and rdf couldn't
               be created.
           :return: :class:`ldns_rdf` object or None. If the object
               can't be created and `raiseException` is True,
               an exception occurs.

           **Usage**

               >>> rdf = ldns.ldns_rdf.new_frm_str("74.125.43.99", ldns.LDNS_RDF_TYPE_A)
               >>> print rdf, rdf.get_type_str()
               A 74.125.43.99
               >>> name = ldns.ldns_resolver.new_frm_file().get_name_by_addr(rdf)
               >>> if (name): print name
               99.43.125.74.in-addr.arpa.	85277	IN	PTR	bw-in-f99.google.com.
        """
        rr = _ldns.ldns_rdf_new_frm_str(rr_type, string)
        if (not rr) and raiseException:
            raise Exception("Can't create query packet, " +
                "error: %d" % status)
        return rr

    #
    # _LDNS_RDF_CONSTRUCTORS
    #

    def __str__(self):
        """
           Converts the rdata field to presentation format.
        """
        return _ldns.ldns_rdf2str(self)

    def __cmp__(self, other):
        """
           Compares two rdfs on their wire formats.

           (To order dnames according to rfc4034, use ldns_dname_compare.)

           :param other: The second one RDF.
           :type other: :class:`ldns_rdf`
           :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
           :return: (int) -1, 0 or 1 if self comes before other,
               is equal or self comes after other respectively.
        """
        return _ldns.ldns_rdf_compare(self, other)

    def __lt__(self, other):
        """
            Compares two rdfs on their formats.

            :param other: The socond one RDF.
            :type other: :class:`ldns_rdf`
            :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
            :return: (bool) True when `self` is less than 'other'.
        """
        return _ldns.ldns_rdf_compare(self, other) == -1

    def __le__(self, other):
        """
            Compares two rdfs on their formats.

            :param other: The socond one RDF.
            :type other: :class:`ldns_rdf`
            :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
            :return: (bool) True when `self` is less than or equal to
                'other'.
        """
        return _ldns.ldns_rdf_compare(self, other) != 1

    def __eq__(self, other):
        """
            Compares two rdfs on their formats.

            :param other: The socond one RDF.
            :type other: :class:`ldns_rdf`
            :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
            :return: (bool) True when `self` is equal to 'other'.
        """
        return _ldns.ldns_rdf_compare(self, other) == 0

    def __ne__(self, other):
        """
            Compares two rdfs on their formats.

            :param other: The socond one RDF.
            :type other: :class:`ldns_rdf`
            :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
            :return: (bool) True when `self` is not equal to 'other'.
        """
        return _ldns.ldns_rdf_compare(self, other) != 0

    def __gt__(self, other):
        """
            Compares two rdfs on their formats.

            :param other: The socond one RDF.
            :type other: :class:`ldns_rdf`
            :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
            :return: (bool) True when `self` is greater than 'other'.
        """
        return _ldns.ldns_rdf_compare(self, other) == 1

    def __ge__(self, other):
        """
            Compares two rdfs on their formats.

            :param other: The socond one RDF.
            :type other: :class:`ldns_rdf`
            :throws TypeError: When `other` of non-:class:`ldns_rdf` type.
            :return: (bool) True when `self` is greater than or equal to
                'other'.
        """
        return _ldns.ldns_rdf_compare(self, other) != -1

    def print_to_file(self, output):
        """
           Prints the data in the rdata field to the given `output` file
           stream (in presentation format).
        """
        _ldns.ldns_rdf_print(output, self)

    def get_type_str(self):
        """
           Returns the type of the rdf as a human readable string.

           :return: String containing rdf type.
        """
        return ldns_rdf_type2str(self)

    def write_to_buffer(self, buffer):
        """
           Copies the rdata data to the buffer in wire format.

           :param buffer: Buffer to append the rdf to.
           :type param: :class:`ldns_buffer`
           :throws TypeError: When `buffer` of non-:class:`ldns_buffer`
               type.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rdf2buffer_wire(buffer, self)
    #parameters: ldns_buffer *, const ldns_rdf *,
    #retvals: ldns_status

    def write_to_buffer_canonical(self, buffer):
        """
           Copies the rdata data to the buffer in wire format.
           If the rdata is a dname, the letters will be converted
           to lower case during the conversion.

           :param buffer: LDNS buffer.
           :type buffer: :class:`ldns_buffer`
           :throws TypeError: When `buffer` of non-:class:`ldns_buffer`
               type.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_rdf2buffer_wire_canonical(buffer, self)
    #parameters: ldns_buffer *, const ldns_rdf *,
    #retvals: ldns_status

    #
    # LDNS_RDF_METHODS_
    #

    def address_reverse(self):
        """
           Reverses an rdf, only actually useful for AAAA and A records.

           The returned rdf has the type LDNS_RDF_TYPE_DNAME!

           :return: (:class:`ldns_rdf`) The reversed rdf
               (a newly created rdf).
        """
        return _ldns.ldns_rdf_address_reverse(self)
    #parameters: ldns_rdf *,
    #retvals: ldns_rdf *

    def clone(self):
        """
           Clones a rdf structure.

           The data are copied.

           :return: (:class:`ldns_rdf`) A new rdf structure.
        """
        return _ldns.ldns_rdf_clone(self)
    #parameters: const ldns_rdf *,
    #retvals: ldns_rdf *

    def data(self):
        """
           Returns the data of the rdf.

           :return: (uint8_t \*) uint8_t* pointer to the rdf's data.
        """
        return _ldns.ldns_rdf_data(self)
    #parameters: const ldns_rdf *,
    #retvals: uint8_t *

    def data_as_bytearray(self):
        """
           Returns the data of the rdf as a bytearray.

           :return: (bytearray) Bytearray containing the rdf data.
        """
        return _ldns.ldns_rdf_data_as_bytearray(self)
    #parameters: const ldns_rdf *,
    #retvals: bytearray

    def get_type(self):
        """
           Returns the type of the rdf.

           We need to prepend the prefix get_ here to prevent conflict
           with the rdf_type TYPE.

           :return: (ldns_rdf_type) Identifier of the type.
        """
        return _ldns.ldns_rdf_get_type(self)
    #parameters: const ldns_rdf *,
    #retvals: ldns_rdf_type

    def set_data(self, data):
        """
           Sets the data portion of the rdf.

           The data are not copied, but are assigned to the rdf,
           `data` are decoupled from the Python engine.

           :param data: Data to be set.
           :type data: void \*
        """
        _ldns.ldns_rdf_set_data(self, data)
    #parameters: ldns_rdf *, void *,
    #retvals: 

    def set_size(self, size):
        """
           Sets the size of the rdf.

           :param size: The new size.
           :type size: integer
           :throws TypeError: When size of non-integer type.
        """
        _ldns.ldns_rdf_set_size(self,size)
    #parameters: ldns_rdf *,size_t,
    #retvals: 

    def set_type(self, atype):
        """
           Sets the type of the rdf.

           :param atype: rdf type
           :type atype: integer
           :throws TypeError: When atype of non-integer type.
        """
        _ldns.ldns_rdf_set_type(self, atype)
    #parameters: ldns_rdf *, ldns_rdf_type,
    #retvals: 

    def size(self):
        """
           Returns the size of the rdf.

           :return: (size_t) uint16_t with the size.
        """
        return _ldns.ldns_rdf_size(self)
    #parameters: const ldns_rdf *,
    #retvals: size_t

    @staticmethod
    def dname_new_frm_str(string):
        """
           Creates a new dname rdf instance from a given string.

           This static method is equivalent to using of default
           :class:`ldns_rdf` constructor.

           :parameter string: String to use.
           :type string: string
           :throws TypeError: When not a string used.
           :return: :class:`ldns_rdf` or None if error.

           .. warning::

               It is scheduled to be deprecated and removed. Use
               :class:`ldns_dname` constructor instead.
        """
        warnings.warn("The ldns_rdf.dname_new_frm_str() method is" +
            " scheduled to be deprecated in future releases." +
            " Use ldsn_dname constructor instead.",
            PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_new_frm_str(string)

    def absolute(self):
        """
           Checks whether the given dname string is absolute
           (i.e., ends with a '.').

           :return: (bool) True or False

           .. note::

               This method was malfunctioning in ldns-1.3.16 and also
               possibly earlier.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname` to use the method.
        """
        warnings.warn("The ldns_rdf.absolute() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        if self.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            string = self.__str__()
            return _ldns.ldns_dname_str_absolute(string) != 0
        else:
            return False

    def make_canonical(self):
        """
           Put a dname into canonical format (i.e., convert to lower case).

           Performs no action if not a dname.

           .. warning::

               This method is scheduled to be deprecated and removed.
               Convert :class:`ldns_rdf` to :class:`ldns_dname` to use
               the method.
        """
        warnings.warn("The ldns_rdf.make_canonical() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        _ldns.ldns_dname2canonical(self)

    def dname_compare(self, other):
        """
           Compares two dname rdf according to the algorithm
           for ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_rdf`
           :throws TypeError: When not a :class:`ldns_rdf` used.
           :throws Exception: When not dnames compared.
           :return: (int) -1, 0 or 1 if `self` comes before `other`,
               `self` is equal or `self` comes after `other` respectively.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.dname_compare() method is" +
            " scheduled to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
    #
    # The wrapped function generates asserts instead of setting
    # error status. They cannot be caught from Python so a check
    # is necessary. 
    #
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (self.get_type() != _ldns.LDNS_RDF_TYPE_DNAME) or \
           (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Both operands must be dname rdfs.")
        return _ldns.ldns_dname_compare(self, other)

    def cat(self, rd2):
        """
           Concatenates `rd2` after `this` dname (`rd2` is copied,
           `this` dname is modified).

           :param rd2: The right-hand side.
           :type rd2: :class:`ldns_rdf`
           :throws TypeError: When `rd2` of non-:class:`ldns_rdf` or
               non-:class:`ldns_dname` type.
           :return: (ldns_status) LDNS_STATUS_OK on success.

           .. warning::

              It is scheduled to be deprecated and removed. Convert
              :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.cat() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_cat(self, rd2)
    #parameters: ldns_rdf *, ldns_rdf *,
    #retvals: ldns_status

    def cat_clone(self, rd2):
        """
           Concatenates two dnames together.

           :param rd2: The right-hand side.
           :type rd2: :class:`ldns_rdf`
           :throws TypeError: When `rd2` of non-:class:`ldns_rdf` or
               non-:class:`ldns_dname` type.
           :return: (:class:`ldns_rdf`) A new rdf with
               left-hand side + right-hand side content None when
               error.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.cat_clone() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_cat_clone(self, rd2)
    #parameters: const ldns_rdf *, const ldns_rdf *,
    #retvals: ldns_rdf *

    def interval(self, middle, next):
        """
           Check whether the `middle` lays in the interval defined by
           `this` and `next` (`this` <= `middle` < `next`).

           This method is useful for nsec checking

           :param middle: The dname to check.
           :type middle: :class:`ldns_rdf`
           :param next: The boundary.
           :type next: :class:`ldns_rdf`
           :throws TypeError: When `middle` or `next` of
               non-:class:`ldns_rdf` type.
           :throws Exception: When non-dname rdfs compared.
           :return: (int) 0 on error or unknown,
               -1 when middle is in the interval, 1 when not.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.interval() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
    #
    # The wrapped function generates asserts instead of setting
    # error status. They cannot be caught from Python so a check
    # is necessary. 
    #
        if (not isinstance(middle, ldns_rdf)) or \
           (not isinstance(next, ldns_rdf)):
            raise TypeError("Parameters must be derived from ldns_rdf.")
        if (self.get_type() != _ldns.LDNS_RDF_TYPE_DNAME) or \
           (middle.get_type() != _ldns.LDNS_RDF_TYPE_DNAME) or \
           (next.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("All operands must be dname rdfs.")
        return _ldns.ldns_dname_interval(self, middle, next)
    #parameters: const ldns_rdf *, const ldns_rdf *, const ldns_rdf *,
    #retvals: int

    def is_subdomain(self, parent):
        """
           Tests whether the name of the given instance falls under
           `parent` (i.e., is a sub-domain of `parent`).

           This function will return False if the given dnames
           are equal.

           :param parent: The parent's name.
           :type parent: :class:`ldns_rdf`
           :throws TypeError: When `parent` of non-:class:`ldns_rdf` type.
           :return: (bool) True if `this` falls under `parent`, otherwise
               False.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.is_subdomain() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_is_subdomain(self, parent)
    #parameters: const ldns_rdf *, const ldns_rdf *,
    #retvals: bool

    def label(self, labelpos):
        """
           Look inside the rdf and if it is an LDNS_RDF_TYPE_DNAME try
           and retrieve a specific label.

           The labels are numbered starting from 0 (left most).

           :param labelpos: Index of the label. (Labels are numbered
               0, which is the left most.)
           :type labelpos: integer
           :throws TypeError: When `labelpos` of non-integer type.
           :return: (:class:`ldns_rdf`) A new rdf with the label
               as name or None on error.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.label() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_label(self, labelpos)
    #parameters: const ldns_rdf *, uint8_t,
    #retvals: ldns_rdf *

    def label_count(self):
        """
           Count the number of labels inside a LDNS_RDF_DNAME type rdf.

           :return: (uint8_t) The number of labels. Will return 0 if
               not a dname.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.label_count() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_label_count(self)
    #parameters: const ldns_rdf *,
    #retvals: uint8_t

    def left_chop(self):
        """
           Chop one label off the left side of a dname.

           (e.g., wwww.nlnetlabs.nl, becomes nlnetlabs.nl)

           :return: (:class:`ldns_rdf`) The remaining dname or None when
               error.

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.left_chop() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_left_chop(self)
    #parameters: const ldns_rdf *,
    #retvals: ldns_rdf *

    def reverse(self):
        """
           Returns a clone of the given dname with the labels reversed.

           When reversing non-dnames a "." (root name) dname is returned.

           :throws Exception: When used on non-dname rdfs.
           :return: (:class:`ldns_rdf`) Clone of the dname with the labels
               reversed or ".".

           .. warning::

               It is scheduled to be deprecated and removed. Convert
               :class:`ldns_rdf` to :class:`ldns_dname`.
        """
        warnings.warn("The ldns_rdf.reverse() method is scheduled" +
            " to be deprecated in future releases." +
            " Convert the ldns_rdf to ldsn_dname and the use its" +
            " methods.", PendingDeprecationWarning, stacklevel=2)
        if self.get_type() != _ldns.LDNS_RDF_TYPE_DNAME:
            raise Exception("Operand must be a dname rdf.")
        return _ldns.ldns_dname_reverse(self)
    #parameters: const ldns_rdf *,
    #retvals: ldns_rdf *

    #
    # _LDNS_RDF_METHODS
    #

ldns_rdf_swigregister = _ldns.ldns_rdf_swigregister
ldns_rdf_swigregister(ldns_rdf)


def ldns_rdf_set_size(rd, size):
    """LDNS buffer."""
    return _ldns.ldns_rdf_set_size(rd, size)

def ldns_rdf_set_type(rd, type):
    """LDNS buffer."""
    return _ldns.ldns_rdf_set_type(rd, type)

def ldns_rdf_set_data(rd, data):
    """LDNS buffer."""
    return _ldns.ldns_rdf_set_data(rd, data)

def ldns_rdf_size(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf_size(rd)

def ldns_rdf_get_type(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf_get_type(rd)

def ldns_rdf_data(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf_data(rd)

def ldns_rdf_new(type, size, data):
    """LDNS buffer."""
    return _ldns.ldns_rdf_new(type, size, data)

def ldns_rdf_new_frm_data(type, size, data):
    """LDNS buffer."""
    return _ldns.ldns_rdf_new_frm_data(type, size, data)

def ldns_rdf_new_frm_str(type, str):
    """LDNS buffer."""
    return _ldns.ldns_rdf_new_frm_str(type, str)

def ldns_rdf_new_frm_fp(type, fp):
    """LDNS buffer."""
    return _ldns.ldns_rdf_new_frm_fp(type, fp)

def ldns_rdf_new_frm_fp_l(type, fp):
    """LDNS buffer."""
    return _ldns.ldns_rdf_new_frm_fp_l(type, fp)

def _ldns_rdf_free(rd):
    """LDNS buffer."""
    return _ldns._ldns_rdf_free(rd)

def _ldns_rdf_deep_free(rd):
    """LDNS buffer."""
    return _ldns._ldns_rdf_deep_free(rd)

def ldns_native2rdf_int8(type, value):
    """LDNS buffer."""
    return _ldns.ldns_native2rdf_int8(type, value)

def ldns_native2rdf_int16(type, value):
    """LDNS buffer."""
    return _ldns.ldns_native2rdf_int16(type, value)

def ldns_native2rdf_int32(type, value):
    """LDNS buffer."""
    return _ldns.ldns_native2rdf_int32(type, value)

def ldns_native2rdf_int16_data(size, data):
    """LDNS buffer."""
    return _ldns.ldns_native2rdf_int16_data(size, data)

def ldns_rdf_address_reverse(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf_address_reverse(rd)

def ldns_rdf2native_int8(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf2native_int8(rd)

def ldns_rdf2native_int16(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf2native_int16(rd)

def ldns_rdf2native_int32(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf2native_int32(rd)

def ldns_rdf2native_time_t(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf2native_time_t(rd)

def ldns_str2period(nptr, endptr):
    """LDNS buffer."""
    return _ldns.ldns_str2period(nptr, endptr)

def ldns_octet(word, length):
    """LDNS buffer."""
    return _ldns.ldns_octet(word, length)

def ldns_rdf_clone(rd):
    """LDNS buffer."""
    return _ldns.ldns_rdf_clone(rd)

def ldns_rdf_compare(rd1, rd2):
    """LDNS buffer."""
    return _ldns.ldns_rdf_compare(rd1, rd2)

def ldns_rdf_hip_get_alg_hit_pk(rdf, alg, hit_size, hit, pk_size, pk):
    """LDNS buffer."""
    return _ldns.ldns_rdf_hip_get_alg_hit_pk(rdf, alg, hit_size, hit, pk_size, pk)

def ldns_rdf_hip_new_frm_alg_hit_pk(alg, hit_size, hit, pk_size, pk):
    """LDNS buffer."""
    return _ldns.ldns_rdf_hip_new_frm_alg_hit_pk(alg, hit_size, hit, pk_size, pk)
LDNS_RESOLV_CONF = _ldns.LDNS_RESOLV_CONF
LDNS_RESOLV_HOSTS = _ldns.LDNS_RESOLV_HOSTS
LDNS_RESOLV_KEYWORD = _ldns.LDNS_RESOLV_KEYWORD
LDNS_RESOLV_DEFDOMAIN = _ldns.LDNS_RESOLV_DEFDOMAIN
LDNS_RESOLV_NAMESERVER = _ldns.LDNS_RESOLV_NAMESERVER
LDNS_RESOLV_SEARCH = _ldns.LDNS_RESOLV_SEARCH
LDNS_RESOLV_SORTLIST = _ldns.LDNS_RESOLV_SORTLIST
LDNS_RESOLV_OPTIONS = _ldns.LDNS_RESOLV_OPTIONS
LDNS_RESOLV_ANCHOR = _ldns.LDNS_RESOLV_ANCHOR
LDNS_RESOLV_KEYWORDS = _ldns.LDNS_RESOLV_KEYWORDS
LDNS_RESOLV_INETANY = _ldns.LDNS_RESOLV_INETANY
LDNS_RESOLV_INET = _ldns.LDNS_RESOLV_INET
LDNS_RESOLV_INET6 = _ldns.LDNS_RESOLV_INET6
LDNS_RESOLV_RTT_INF = _ldns.LDNS_RESOLV_RTT_INF
LDNS_RESOLV_RTT_MIN = _ldns.LDNS_RESOLV_RTT_MIN
class ldns_resolver(_object):
    """
    LDNS resolver object. 

    The :class:`ldns_resolver` object keeps a list of name servers and can perform
    queries.

    **Usage**

    >>> import ldns
    >>> resolver = ldns.ldns_resolver.new_frm_file("/etc/resolv.conf")
    >>> pkt = resolver.query("www.nic.cz", ldns.LDNS_RR_TYPE_A,ldns.LDNS_RR_CLASS_IN)
    >>> if (pkt) and (pkt.answer()): 
    >>>    print pkt.answer()
    www.nic.cz.	1757	IN	A	217.31.205.50

    This simple example instances a resolver in order to resolve www.nic.cz A type
    record.
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_resolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_resolver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_port"] = _ldns.ldns_resolver__port_set
    __swig_getmethods__["_port"] = _ldns.ldns_resolver__port_get
    if _newclass:
        _port = _swig_property(_ldns.ldns_resolver__port_get, _ldns.ldns_resolver__port_set)
    __swig_setmethods__["_nameserver_count"] = _ldns.ldns_resolver__nameserver_count_set
    __swig_getmethods__["_nameserver_count"] = _ldns.ldns_resolver__nameserver_count_get
    if _newclass:
        _nameserver_count = _swig_property(_ldns.ldns_resolver__nameserver_count_get, _ldns.ldns_resolver__nameserver_count_set)
    __swig_setmethods__["_rtt"] = _ldns.ldns_resolver__rtt_set
    __swig_getmethods__["_rtt"] = _ldns.ldns_resolver__rtt_get
    if _newclass:
        _rtt = _swig_property(_ldns.ldns_resolver__rtt_get, _ldns.ldns_resolver__rtt_set)
    __swig_setmethods__["_recursive"] = _ldns.ldns_resolver__recursive_set
    __swig_getmethods__["_recursive"] = _ldns.ldns_resolver__recursive_get
    if _newclass:
        _recursive = _swig_property(_ldns.ldns_resolver__recursive_get, _ldns.ldns_resolver__recursive_set)
    __swig_setmethods__["_debug"] = _ldns.ldns_resolver__debug_set
    __swig_getmethods__["_debug"] = _ldns.ldns_resolver__debug_get
    if _newclass:
        _debug = _swig_property(_ldns.ldns_resolver__debug_get, _ldns.ldns_resolver__debug_set)
    __swig_setmethods__["_domain"] = _ldns.ldns_resolver__domain_set
    __swig_getmethods__["_domain"] = _ldns.ldns_resolver__domain_get
    if _newclass:
        _domain = _swig_property(_ldns.ldns_resolver__domain_get, _ldns.ldns_resolver__domain_set)
    __swig_setmethods__["_searchlist_count"] = _ldns.ldns_resolver__searchlist_count_set
    __swig_getmethods__["_searchlist_count"] = _ldns.ldns_resolver__searchlist_count_get
    if _newclass:
        _searchlist_count = _swig_property(_ldns.ldns_resolver__searchlist_count_get, _ldns.ldns_resolver__searchlist_count_set)
    __swig_setmethods__["_retry"] = _ldns.ldns_resolver__retry_set
    __swig_getmethods__["_retry"] = _ldns.ldns_resolver__retry_get
    if _newclass:
        _retry = _swig_property(_ldns.ldns_resolver__retry_get, _ldns.ldns_resolver__retry_set)
    __swig_setmethods__["_retrans"] = _ldns.ldns_resolver__retrans_set
    __swig_getmethods__["_retrans"] = _ldns.ldns_resolver__retrans_get
    if _newclass:
        _retrans = _swig_property(_ldns.ldns_resolver__retrans_get, _ldns.ldns_resolver__retrans_set)
    __swig_setmethods__["_fallback"] = _ldns.ldns_resolver__fallback_set
    __swig_getmethods__["_fallback"] = _ldns.ldns_resolver__fallback_get
    if _newclass:
        _fallback = _swig_property(_ldns.ldns_resolver__fallback_get, _ldns.ldns_resolver__fallback_set)
    __swig_setmethods__["_dnssec"] = _ldns.ldns_resolver__dnssec_set
    __swig_getmethods__["_dnssec"] = _ldns.ldns_resolver__dnssec_get
    if _newclass:
        _dnssec = _swig_property(_ldns.ldns_resolver__dnssec_get, _ldns.ldns_resolver__dnssec_set)
    __swig_setmethods__["_dnssec_cd"] = _ldns.ldns_resolver__dnssec_cd_set
    __swig_getmethods__["_dnssec_cd"] = _ldns.ldns_resolver__dnssec_cd_get
    if _newclass:
        _dnssec_cd = _swig_property(_ldns.ldns_resolver__dnssec_cd_get, _ldns.ldns_resolver__dnssec_cd_set)
    __swig_setmethods__["_dnssec_anchors"] = _ldns.ldns_resolver__dnssec_anchors_set
    __swig_getmethods__["_dnssec_anchors"] = _ldns.ldns_resolver__dnssec_anchors_get
    if _newclass:
        _dnssec_anchors = _swig_property(_ldns.ldns_resolver__dnssec_anchors_get, _ldns.ldns_resolver__dnssec_anchors_set)
    __swig_setmethods__["_usevc"] = _ldns.ldns_resolver__usevc_set
    __swig_getmethods__["_usevc"] = _ldns.ldns_resolver__usevc_get
    if _newclass:
        _usevc = _swig_property(_ldns.ldns_resolver__usevc_get, _ldns.ldns_resolver__usevc_set)
    __swig_setmethods__["_igntc"] = _ldns.ldns_resolver__igntc_set
    __swig_getmethods__["_igntc"] = _ldns.ldns_resolver__igntc_get
    if _newclass:
        _igntc = _swig_property(_ldns.ldns_resolver__igntc_get, _ldns.ldns_resolver__igntc_set)
    __swig_setmethods__["_ip6"] = _ldns.ldns_resolver__ip6_set
    __swig_getmethods__["_ip6"] = _ldns.ldns_resolver__ip6_get
    if _newclass:
        _ip6 = _swig_property(_ldns.ldns_resolver__ip6_get, _ldns.ldns_resolver__ip6_set)
    __swig_setmethods__["_defnames"] = _ldns.ldns_resolver__defnames_set
    __swig_getmethods__["_defnames"] = _ldns.ldns_resolver__defnames_get
    if _newclass:
        _defnames = _swig_property(_ldns.ldns_resolver__defnames_get, _ldns.ldns_resolver__defnames_set)
    __swig_setmethods__["_dnsrch"] = _ldns.ldns_resolver__dnsrch_set
    __swig_getmethods__["_dnsrch"] = _ldns.ldns_resolver__dnsrch_get
    if _newclass:
        _dnsrch = _swig_property(_ldns.ldns_resolver__dnsrch_get, _ldns.ldns_resolver__dnsrch_set)
    __swig_setmethods__["_timeout"] = _ldns.ldns_resolver__timeout_set
    __swig_getmethods__["_timeout"] = _ldns.ldns_resolver__timeout_get
    if _newclass:
        _timeout = _swig_property(_ldns.ldns_resolver__timeout_get, _ldns.ldns_resolver__timeout_set)
    __swig_setmethods__["_fail"] = _ldns.ldns_resolver__fail_set
    __swig_getmethods__["_fail"] = _ldns.ldns_resolver__fail_get
    if _newclass:
        _fail = _swig_property(_ldns.ldns_resolver__fail_get, _ldns.ldns_resolver__fail_set)
    __swig_setmethods__["_random"] = _ldns.ldns_resolver__random_set
    __swig_getmethods__["_random"] = _ldns.ldns_resolver__random_get
    if _newclass:
        _random = _swig_property(_ldns.ldns_resolver__random_get, _ldns.ldns_resolver__random_set)
    __swig_setmethods__["_socket"] = _ldns.ldns_resolver__socket_set
    __swig_getmethods__["_socket"] = _ldns.ldns_resolver__socket_get
    if _newclass:
        _socket = _swig_property(_ldns.ldns_resolver__socket_get, _ldns.ldns_resolver__socket_set)
    __swig_setmethods__["_axfr_soa_count"] = _ldns.ldns_resolver__axfr_soa_count_set
    __swig_getmethods__["_axfr_soa_count"] = _ldns.ldns_resolver__axfr_soa_count_get
    if _newclass:
        _axfr_soa_count = _swig_property(_ldns.ldns_resolver__axfr_soa_count_get, _ldns.ldns_resolver__axfr_soa_count_set)
    __swig_setmethods__["_cur_axfr_pkt"] = _ldns.ldns_resolver__cur_axfr_pkt_set
    __swig_getmethods__["_cur_axfr_pkt"] = _ldns.ldns_resolver__cur_axfr_pkt_get
    if _newclass:
        _cur_axfr_pkt = _swig_property(_ldns.ldns_resolver__cur_axfr_pkt_get, _ldns.ldns_resolver__cur_axfr_pkt_set)
    __swig_setmethods__["_axfr_i"] = _ldns.ldns_resolver__axfr_i_set
    __swig_getmethods__["_axfr_i"] = _ldns.ldns_resolver__axfr_i_get
    if _newclass:
        _axfr_i = _swig_property(_ldns.ldns_resolver__axfr_i_get, _ldns.ldns_resolver__axfr_i_set)
    __swig_setmethods__["_edns_udp_size"] = _ldns.ldns_resolver__edns_udp_size_set
    __swig_getmethods__["_edns_udp_size"] = _ldns.ldns_resolver__edns_udp_size_get
    if _newclass:
        _edns_udp_size = _swig_property(_ldns.ldns_resolver__edns_udp_size_get, _ldns.ldns_resolver__edns_udp_size_set)
    __swig_setmethods__["_serial"] = _ldns.ldns_resolver__serial_set
    __swig_getmethods__["_serial"] = _ldns.ldns_resolver__serial_get
    if _newclass:
        _serial = _swig_property(_ldns.ldns_resolver__serial_get, _ldns.ldns_resolver__serial_set)
    __swig_setmethods__["_tsig_keyname"] = _ldns.ldns_resolver__tsig_keyname_set
    __swig_getmethods__["_tsig_keyname"] = _ldns.ldns_resolver__tsig_keyname_get
    if _newclass:
        _tsig_keyname = _swig_property(_ldns.ldns_resolver__tsig_keyname_get, _ldns.ldns_resolver__tsig_keyname_set)
    __swig_setmethods__["_tsig_keydata"] = _ldns.ldns_resolver__tsig_keydata_set
    __swig_getmethods__["_tsig_keydata"] = _ldns.ldns_resolver__tsig_keydata_get
    if _newclass:
        _tsig_keydata = _swig_property(_ldns.ldns_resolver__tsig_keydata_get, _ldns.ldns_resolver__tsig_keydata_set)
    __swig_setmethods__["_tsig_algorithm"] = _ldns.ldns_resolver__tsig_algorithm_set
    __swig_getmethods__["_tsig_algorithm"] = _ldns.ldns_resolver__tsig_algorithm_get
    if _newclass:
        _tsig_algorithm = _swig_property(_ldns.ldns_resolver__tsig_algorithm_get, _ldns.ldns_resolver__tsig_algorithm_set)
    __swig_setmethods__["_source"] = _ldns.ldns_resolver__source_set
    __swig_getmethods__["_source"] = _ldns.ldns_resolver__source_get
    if _newclass:
        _source = _swig_property(_ldns.ldns_resolver__source_get, _ldns.ldns_resolver__source_set)

    def __init__(self):
        """
           Cannot be created directly from Python.
        """
        raise Exception("This class can't be created directly. " +
            "Please use: new_frm_file(filename), new_frm_fp(file) " +
            "or new_frm_fp_l(file, line)")

    __swig_destroy__ = _ldns._ldns_resolver_deep_free

    #
    # LDNS_RESOLVER_CONSTRUCTORS_
    #

    @staticmethod
    def new():
        """
           Creates a new resolver object.

           :return: (:class:`ldns_resolver`) New resolver object or None.

           .. note::
               The returned resolver object is unusable unless some
               name servers are added.

           **Usage**
             >>> resolver = ldns.ldns_resolver.new()
             >>> ns_addr = ldns.ldns_rdf.new_frm_str("8.8.8.8", ldns.LDNS_RDF_TYPE_A)
             >>> if not ns_addr: raise Exception("Can't create resolver address.")
             >>> status = resolver.push_nameserver(ns_addr)
             >>> if status != ldns.LDNS_STATUS_OK: raise Exception("Can't push resolver address.")
             >>> pkt = resolver.query("www.nic.cz.", ldns.LDNS_RR_TYPE_A, ldns.LDNS_RR_CLASS_IN, ldns.LDNS_RD)
             >>> if (pkt) and (pkt.answer()):
             >>>     print pkt.answer()
             www.nic.cz.     1265    IN      A       217.31.205.50
        """
        return _ldns.ldns_resolver_new()

    @staticmethod
    def new_frm_file(filename = "/etc/resolv.conf", raiseException=True):
        """
           Creates a resolver object from given file name

           :param filename: Name of file which contains resolver
               informations (usually /etc/resolv.conf).
           :type filename: str
           :param raiseException: If True, an exception occurs in case a
               resolver object can't be created.
           :type raiseException: bool
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When `raiseException` set and resolver
               couldn't be created.
           :return: (:class:`ldns_resolver`) Resolver object or None.
               An exception occurs if the object can't be created and
               'raiseException' is True.
        """
        status, resolver = _ldns.ldns_resolver_new_frm_file(filename)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create resolver, error: %d" % status)
            return None
        return resolver

    @staticmethod
    def new_frm_fp(file, raiseException=True):
        """
           Creates a resolver object from file

           :param file: A file object.
           :type file: file
           :param raiseException: If True, an exception occurs in case a
               resolver object can't be created.
           :type raiseException: bool
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When `raiseException` set and resolver
               couldn't be created.
           :return: (:class:`ldns_resolver`) Resolver object or None.
               An exception occurs if the object can't be created and
               `raiseException` is True.
        """
        status, resolver = _ldns.ldns_resolver_new_frm_fp(file)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create resolver, error: %d" % status)
            return None
        return resolver

    @staticmethod
    def new_frm_fp_l(file, raiseException=True):
        """
           Creates a resolver object from file

           :param file: A file object.
           :type file: file
           :param raiseException: If True, an exception occurs in case a
               resolver instance can't be created.
           :type raiseException: bool
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When `raiseException` set and resolver
               couldn't be created.
           :return: 
              * (:class:`ldns_resolver`) Resolver instance or None.
                  An exception occurs if an instance can't be created and
                  `raiseException` is True.

              * (int) - The line number. (e.g., for debugging)
        """
        status, resolver, line = _ldns.ldns_resolver_new_frm_fp_l(file)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create resolver, error: %d" % status)
            return None
        return resolver, line

    #
    # _LDNS_RESOLVER_CONSTRUCTORS
    #

    # High level functions

    def get_addr_by_name(self, name, aclass = _ldns.LDNS_RR_CLASS_IN, flags = _ldns.LDNS_RD):
        """
           Ask the resolver about name and return all address records.

           :param name: The name to look for. String is automatically
               converrted to dname.
           :type name: :class:`ldns_dname` or str
           :param aclass: The class to use.
           :type aclass: ldns_rr_class
           :param flags: Give some optional flags to the query.
           :type flags: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) RR List object or None.

           **Usage**
             >>> addr = resolver.get_addr_by_name("www.google.com", ldns.LDNS_RR_CLASS_IN, ldns.LDNS_RD)
             >>> if (not addr): raise Exception("Can't retrieve server address")
             >>> for rr in addr.rrs():
             >>>     print rr
             www.l.google.com.	300	IN	A	74.125.43.99
             www.l.google.com.	300	IN	A	74.125.43.103
             www.l.google.com.	300	IN	A	74.125.43.104
             www.l.google.com.	300	IN	A	74.125.43.147
        """
        rdf = name
        if isinstance(name, str):
            rdf =  _ldns.ldns_dname_new_frm_str(name)
        return _ldns.ldns_get_rr_list_addr_by_name(self, rdf, aclass, flags)

    def get_name_by_addr(self, addr, aclass = _ldns.LDNS_RR_CLASS_IN, flags = _ldns.LDNS_RD):
        """
           Ask the resolver about the address and return the name.

           :param name: (ldns_rdf of A or AAAA type) the addr to look for.
               If a string is given, A or AAAA type is identified
               automatically.
           :type name: :class:`ldns_rdf` of A or AAAA type
           :param aclass: The class to use.
           :type aclass: ldns_rr_class
           :param flags: Give some optional flags to the query.
           :type flags: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) RR List object or None.

           **Usage**
             >>> addr = resolver.get_name_by_addr("74.125.43.99", ldns.LDNS_RR_CLASS_IN, ldns.LDNS_RD)
             >>> if (not addr): raise Exception("Can't retrieve server address")
             >>> for rr in addr.rrs():
             >>>     print rr
             99.43.125.74.in-addr.arpa.	85641	IN	PTR	bw-in-f99.google.com.

        """
        rdf = addr
        if isinstance(addr, str):
            if (addr.find("::") >= 0): #IPv6
                rdf = _ldns.ldns_rdf_new_frm_str(_ldns.LDNS_RDF_TYPE_AAAA, addr)
            else:
                rdf = _ldns.ldns_rdf_new_frm_str(_ldns.LDNS_RDF_TYPE_A, addr)
        return _ldns.ldns_get_rr_list_name_by_addr(self, rdf, aclass, flags)

    def print_to_file(self,output):
        """Print a resolver (in so far that is possible) state to output."""
        _ldns.ldns_resolver_print(output,self)

    def axfr_complete(self):
        """
           Returns True if the axfr transfer has completed
           (i.e., 2 SOA RRs and no errors were encountered).

           :return: (bool)
        """
        return _ldns.ldns_axfr_complete(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def axfr_last_pkt(self):
        """
           Returns a last packet that was sent by the server in the AXFR
           transfer (usable for instance to get the error code on failure).

           :return: (:class:`ldns_pkt`) Last packet of the AXFR transfer.
        """
        return _ldns._ldns_axfr_last_pkt(self)
    #parameters: const ldns_resolver *,
    #retvals: ldns_pkt *

    def axfr_next(self):
        """
           Get the next stream of RRs in a AXFR.

           :return: (:class:`ldns_rr`) The next RR from the AXFR stream.
        """
        return _ldns.ldns_axfr_next(self)
    #parameters: ldns_resolver *,
    #retvals: ldns_rr *

    def axfr_start(self, domain, aclass):
        """
           Prepares the resolver for an axfr query. The query is sent and
           the answers can be read with :meth:`axfr_next`.

           :param domain: Domain to axfr.
           :type domain: :class:`dlsn_dname`
           :param aclass: The class to use.
           :type aclass: ldns_rr_class
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) The status of the transfer.

           .. note::
               The type checking of parameter `domain` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.

           **Usage**
           ::

              status = resolver.axfr_start("nic.cz", ldns.LDNS_RR_CLASS_IN)
              if (status != ldns.LDNS_STATUS_OK):
                  raise Exception("Can't start AXFR, error: %s" % ldns.ldns_get_errorstr_by_id(status))
    #Print the results
              while True:
                   rr = resolver.axfr_next()
                   if not rr: 
                      break

                   print rr
        """
    # TODO -- Add checking for ldns_rdf and ldns_dname.
        rdf = domain
        if isinstance(domain, str):
            rdf = _ldns.ldns_dname_new_frm_str(domain)
        return _ldns.ldns_axfr_start(self, rdf, aclass)
    #parameters: ldns_resolver *resolver, ldns_rdf *domain, ldns_rr_class c
    #retvals: int

    #
    # LDNS_RESOLVER_METHODS_
    #

    def debug(self):
        """
           Get the debug status of the resolver.

           :return: (bool) True if so, otherwise False.
        """
        return _ldns.ldns_resolver_debug(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def dec_nameserver_count(self):
        """
           Decrement the resolver's name server count.
        """
        _ldns.ldns_resolver_dec_nameserver_count(self)
    #parameters: ldns_resolver *,
    #retvals: 

    def defnames(self):
        """
           Does the resolver apply default domain name.

           :return: (bool)
        """
        return _ldns.ldns_resolver_defnames(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def dnsrch(self):
        """
           Does the resolver apply search list.

           :return: (bool)
        """
        return _ldns.ldns_resolver_dnsrch(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def dnssec(self):
        """
           Does the resolver do DNSSEC.

           :return: (bool) True: yes, False: no.
        """
        return _ldns.ldns_resolver_dnssec(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def dnssec_anchors(self):
        """
           Get the resolver's DNSSEC anchors.

           :return: (:class:`ldns_rr_list`) An rr list containing trusted
               DNSSEC anchors.
        """
        return _ldns._ldns_resolver_dnssec_anchors(self)
    #parameters: const ldns_resolver *,
    #retvals: ldns_rr_list *

    def dnssec_cd(self):
        """
           Does the resolver set the CD bit.

           :return: (bool) True: yes, False: no.
        """
        return _ldns.ldns_resolver_dnssec_cd(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def domain(self):
        """
           What is the default dname to add to relative queries.

           :return: (:class:`ldns_dname`) The dname which is added.
        """
        dname = _ldns._ldns_resolver_domain(self)
        if dname != None:
            return ldns_dname(_ldns._ldns_resolver_domain(self), clone=False)
        else:
            return dname
    #parameters: const ldns_resolver *,
    #retvals: ldns_rdf *

    def edns_udp_size(self):
        """
           Get the resolver's udp size.

           :return: (uint16_t) The udp mesg size.
        """
        return _ldns.ldns_resolver_edns_udp_size(self)
    #parameters: const ldns_resolver *,
    #retvals: uint16_t

    def fail(self):
        """
           Does the resolver only try the first name server.

           :return: (bool) True: yes, fail, False: no, try the others.
        """
        return _ldns.ldns_resolver_fail(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def fallback(self):
        """
           Get the truncation fall-back status.

           :return: (bool) Whether the truncation fall*back mechanism
               is used.
        """
        return _ldns.ldns_resolver_fallback(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def igntc(self):
        """
           Does the resolver ignore the TC bit (truncated).

           :return: (bool) True: yes, False: no.
        """
        return _ldns.ldns_resolver_igntc(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def incr_nameserver_count(self):
        """
           Increment the resolver's name server count.
        """
        _ldns.ldns_resolver_incr_nameserver_count(self)
    #parameters: ldns_resolver *,
    #retvals: 

    def ip6(self):
        """
           Does the resolver use ip6 or ip4.

           :return: (uint8_t) 0: both, 1: ip4, 2:ip6
        """
        return _ldns.ldns_resolver_ip6(self)
    #parameters: const ldns_resolver *,
    #retvals: uint8_t

    def nameserver_count(self):
        """
           How many name server are configured in the resolver.

           :return: (size_t) Number of name servers.
        """
        return _ldns.ldns_resolver_nameserver_count(self)
    #parameters: const ldns_resolver *,
    #retvals: size_t

    def nameserver_rtt(self, pos):
        """
           Return the used round trip time for a specific name server.

           :param pos: The index to the name server.
           :type pos: size_t
           :throws TypeError: When arguments of inappropriate types.
           :return: (size_t) The rrt, 0: infinite,
               >0: undefined (as of * yet).
        """
        return _ldns.ldns_resolver_nameserver_rtt(self, pos)
    #parameters: const ldns_resolver *,size_t,
    #retvals: size_t

    def nameservers(self):
        """
           Return the configured name server ip address.

           :return: (ldns_rdf \*\*) A ldns_rdf pointer to a list of the
               addresses.
        """
    # TODO -- Convert to list of ldns_rdf.
        return _ldns.ldns_resolver_nameservers(self)
    #parameters: const ldns_resolver *,
    #retvals: ldns_rdf **

    def nameservers_randomize(self):
        """
           Randomize the name server list in the resolver.
        """
        _ldns.ldns_resolver_nameservers_randomize(self)
    #parameters: ldns_resolver *,
    #retvals: 

    def pop_nameserver(self):
        """
           Pop the last name server from the resolver.

           :return: (:class:`ldns_rdf`) The popped address or None if empty.
        """
        return _ldns.ldns_resolver_pop_nameserver(self)
    #parameters: ldns_resolver *,
    #retvals: ldns_rdf *

    def port(self):
        """
           Get the port the resolver should use.

           :return: (uint16_t) The port number.
        """
        return _ldns.ldns_resolver_port(self)
    #parameters: const ldns_resolver *,
    #retvals: uint16_t

    def prepare_query_pkt(self, name, t, c, f, raiseException=True):
        """
           Form a query packet from a resolver and name/type/class combo.

           :param name: Query for this name.
           :type name: :class:`ldns_dname` or str
           :param t: Query for this type (may be 0, defaults to A).
           :type t: ldns_rr_type
           :param c: Query for this class (may be 0, default to IN).
           :type c: ldns_rr_class
           :param f: The query flags.
           :type f: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When `raiseException` set and answer
               couldn't be resolved.
           :return: (:class:`ldns_pkt`) Query packet or None.
               An exception occurs if the object can't be created and
               'raiseException' is True.
        """
        rdf = name
        if isinstance(name, str):
            rdf = _ldns.ldns_dname_new_frm_str(name)
        status, pkt = _ldns.ldns_resolver_prepare_query_pkt(self, rdf, t, c, f)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create resolver, error: %d" % status)
            return None
        return pkt
    #parameters: ldns_resolver *,const ldns_rdf *,ldns_rr_type,ldns_rr_class,uint16_t,
    #retvals: ldns_status,ldns_pkt **

    def push_dnssec_anchor(self, rr):
        """
           Push a new trust anchor to the resolver.
           It must be a DS or DNSKEY rr.

           :param rr: The RR to add as a trust anchor.
           :type rr: DS of DNSKEY :class:`ldns_rr`
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) A status.
        """
        return _ldns.ldns_resolver_push_dnssec_anchor(self, rr)
    #parameters: ldns_resolver *,ldns_rr *,
    #retvals: ldns_status

    def push_nameserver(self, n):
        """
           Push a new name server to the resolver.
           It must be an IP address v4 or v6.

           :param n: The ip address.
           :type n: :class:`ldns_rdf` of A or AAAA type.
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) A status.
        """
        return _ldns.ldns_resolver_push_nameserver(self, n)
    #parameters: ldns_resolver *,ldns_rdf *,
    #retvals: ldns_status

    def push_nameserver_rr(self, rr):
        """
           Push a new name server to the resolver.
           It must be an A or AAAA RR record type.

           :param rr: The resource record.
           :type rr: :class:`ldns_rr` of A or AAAA type.
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) A status.
        """
        return _ldns.ldns_resolver_push_nameserver_rr(self, rr)
    #parameters: ldns_resolver *,ldns_rr *,
    #retvals: ldns_status

    def push_nameserver_rr_list(self, rrlist):
        """
           Push a new name server rr_list to the resolver.

           :param rrlist: The rr list to push.
           :type rrlist: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
           :return: (ldns_status) A status.
        """
        return _ldns.ldns_resolver_push_nameserver_rr_list(self, rrlist)
    #parameters: ldns_resolver *,ldns_rr_list *,
    #retvals: ldns_status

    def push_searchlist(self, rd):
        """
           Push a new rd to the resolver's search-list.

           :param rd: To push.
           :param rd: :class:`ldns_dname` or str
           :throws TypeError: When arguments of inappropriate types.

           .. note:
               The function does not return any return status,
               so the caller must ensure the correctness of the passed
               values.
        """
        rdf = rd
        if isinstance(rd, str):
            rdf = _ldns.ldns_dname_new_frm_str(rd)
        _ldns.ldns_resolver_push_searchlist(self, rdf)
    #parameters: ldns_resolver *,ldns_rdf *,
    #retvals: 

    def query(self,name,atype=_ldns.LDNS_RR_TYPE_A,aclass=_ldns.LDNS_RR_CLASS_IN,flags=_ldns.LDNS_RD):
        """
           Send a query to a name server.

           :param name: The name to look for.
           :type name: :class:`ldns_dname` or str
           :param atype: The RR type to use.
           :type atype: ldns_rr_type
           :param aclass: The RR class to use.
           :type aclass: ldns_rr_class
           :param flags: Give some optional flags to the query.
           :type flags: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_pkt`) A packet with the reply from the
               name server if _defnames is true the default domain will
               be added.
        """
    # Explicit conversion from string to ldns_rdf prevents memory leaks.
    # TODO -- Find out why.
        dname = name
        if isinstance(name, str):
            dname = _ldns.ldns_dname_new_frm_str(name)
        return _ldns.ldns_resolver_query(self, dname, atype, aclass, flags)
    #parameters: const ldns_resolver *,const ldns_rdf *,ldns_rr_type,ldns_rr_class,uint16_t,
    #retvals: ldns_pkt *

    def random(self):
        """
           Does the resolver randomize the name server before usage?

           :return: (bool) True: yes, False: no.
        """
        return _ldns.ldns_resolver_random(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def recursive(self):
        """
           Is the resolver set to recurse?

           :return: (bool) True if so, otherwise False.
        """
        return _ldns.ldns_resolver_recursive(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    def retrans(self):
        """
           Get the retransmit interval.

           :return: (uint8_t) The retransmit interval.
        """
        return _ldns.ldns_resolver_retrans(self)
    #parameters: const ldns_resolver *,
    #retvals: uint8_t

    def retry(self):
        """
           Get the number of retries.

           :return: (uint8_t) The number of retries.
        """
        return _ldns.ldns_resolver_retry(self)
    #parameters: const ldns_resolver *,
    #retvals: uint8_t

    def rtt(self):
        """
           Return the used round trip times for the name servers.

           :return: (size_t \*) a size_t* pointer to the list. yet)
        """
        return _ldns.ldns_resolver_rtt(self)
    #parameters: const ldns_resolver *,
    #retvals: size_t *

    def search(self, name, atype=_ldns.LDNS_RR_TYPE_A, aclass=_ldns.LDNS_RR_CLASS_IN, flags=_ldns.LDNS_RD):
        """
           Send the query for using the resolver and take the search list
           into account The search algorithm is as follows: If the name is
           absolute, try it as-is, otherwise apply the search list.

           :param name: The name to look for.
           :type name: :class:`ldns_dname` or str
           :param atype: The RR type to use.
           :type atype: ldns_rr_type
           :param aclass: The RR class to use.
           :type aclass: ldns_rr_class
           :param flags: Give some optional flags to the query.
           :type flags: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_pkt`) A packet with the reply from the
               name server.
        """
    # Explicit conversion from string to ldns_rdf prevents memory leaks.
    # TODO -- Find out why.
        dname = name
        if isinstance(name, str):
            dname = _ldns.ldns_dname_new_frm_str(name)
        return _ldns.ldns_resolver_search(self, dname, atype, aclass, flags)
    #parameters: const ldns_resolver *,const ldns_rdf *,ldns_rr_type,ldns_rr_class,uint16_t,
    #retvals: ldns_pkt *

    def searchlist(self):
        """
           What is the search-list as used by the resolver.

           :return: (ldns_rdf \*\*) A ldns_rdf pointer to a list of the addresses.
        """
        return _ldns.ldns_resolver_searchlist(self)
    #parameters: const ldns_resolver *,
    #retvals: ldns_rdf \*\*

    def searchlist_count(self):
        """
           Return the resolver's search-list count.

           :return: (size_t) The search-list count.
        """
        return _ldns.ldns_resolver_searchlist_count(self)
    #parameters: const ldns_resolver *,
    #retvals: size_t

    def send(self, name, atype, aclass, flags, raiseException=True):
        """
           Send the query for name as-is.

           :param name: The name to look for.
           :type name: :class:`ldns_dname` or str
           :param atype: The RR type to use.
           :type atype: ldns_rr_type
           :param aclass: The RR class to use.
           :type aclass: ldns_rr_class
           :param flags: Give some optional flags to the query.
           :type flags: uint16_t
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When `raiseException` set and answer
               couldn't be resolved.
           :return: (:class:`ldns_pkt`) A packet with the reply from the
               name server.
        """
    # Explicit conversion from string to ldns_rdf prevents memory leaks.
    # TODO -- Find out why.
        dname = name
        if isinstance(name, str):
            dname = _ldns.ldns_dname_new_frm_str(name)
        status, pkt = _ldns.ldns_resolver_send(self, dname, atype, aclass, flags)
        if status != LDNS_STATUS_OK:
            if (raiseException):
                raise Exception("Can't create resolver, error: %d" % status)
            return None
        return pkt
    #parameters: ldns_resolver *,const ldns_rdf *,ldns_rr_type,ldns_rr_class,uint16_t,
    #retvals: ldns_status,ldns_pkt **

    def send_pkt(self, query_pkt):
        """
           Send the given packet to a name server.

           :param query_pkt: Query packet.
           :type query_pkt: :class:`ldns_pkt`
           :throws TypeError: When arguments of inappropriate types.
           :return: * (ldns_status) Return status.
                    * (:class:`ldns_pkt`) Response packet if returns status ok.
        """
        status, answer = _ldns.ldns_resolver_send_pkt(self, query_pkt)
        return _ldns.ldns_resolver_send_pkt(self,query_pkt)
    #parameters: ldns_resolver *,ldns_pkt *,
    #retvals: ldns_status,ldns_pkt **

    def set_debug(self, b):
        """
           Set the resolver debugging.

           :param b: True: debug on, False: debug off.
           :type b: bool
        """
        _ldns.ldns_resolver_set_debug(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_defnames(self, b):
        """
           Whether the resolver uses the name set with _set_domain.

           :param b: True: use the defaults, False: don't use them.
           :type b: bool
        """
        _ldns.ldns_resolver_set_defnames(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_dnsrch(self, b):
        """
           Whether the resolver uses the search list.

           :param b: True: use the list, False: don't use the list.
           :type b: bool
        """
        _ldns.ldns_resolver_set_dnsrch(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_dnssec(self, b):
        """
           Whether the resolver uses DNSSEC.

           :param b: True: use DNSSEC, False: don't use DNSSEC.
           :type b: bool
        """
        _ldns.ldns_resolver_set_dnssec(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_dnssec_anchors(self, l):
        """
           Set the resolver's DNSSEC anchor list directly.
           RRs should be of type DS or DNSKEY.

           :param l: The list of RRs to use as trust anchors.
           :type l: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns._ldns_resolver_set_dnssec_anchors(self, l)
    #parameters: ldns_resolver *,ldns_rr_list *,
    #retvals: 

    def set_dnssec_cd(self, b):
        """
           Whether the resolver uses the checking disable bit.

           :param b: True: enable, False: disable.
           :type b: bool
        """
        _ldns.ldns_resolver_set_dnssec_cd(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_domain(self, rd):
        """
           Set the resolver's default domain.
           This gets appended when no absolute name is given.

           :param rd: The name to append.
           :type rd: :class:`ldns_dname` or str
           :throws TypeError: When arguments of inappropriate types.
           :throws Exception: When `rd` a non dname rdf.

           .. note::
               The type checking of parameter `rd` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
    # Also has to be able to pass None or dame string.
        if isinstance(rd, str):
            dname = _ldns.ldns_dname_new_frm_str(rd)
        elif (not isinstance(rd, ldns_dname)) and \
           isinstance(rd, ldns_rdf) and \
           rd.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_resolver.set_domain() method" +
                " will drop the possibility to accept ldns_rdf." +
                " Convert argument to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
            dname = rd
        else:
            dname = rd
        if (not isinstance(dname, ldns_rdf)) and (dname != None):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (isinstance(dname, ldns_rdf)) and \
           (dname.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        _ldns._ldns_resolver_set_domain(self, dname)
    #parameters: ldns_resolver *,ldns_rdf *,
    #retvals: 

    def set_edns_udp_size(self, s):
        """
           Set maximum udp size.

           :param s: The udp max size.
           :type s: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_edns_udp_size(self,s)
    #parameters: ldns_resolver *,uint16_t,
    #retvals: 

    def set_fail(self, b):
        """
           Whether or not to fail after one failed query.

           :param b: True: yes fail, False: continue with next name server.
           :type b: bool
        """
        _ldns.ldns_resolver_set_fail(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_fallback(self, fallback):
        """
           Set whether the resolvers truncation fall-back mechanism is used
           when :meth:`query` is called.

           :param fallback: Whether to use the fall-back mechanism.
           :type fallback: bool
        """
        _ldns.ldns_resolver_set_fallback(self, fallback)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_igntc(self, b):
        """
           Whether or not to ignore the TC bit.

           :param b: True: yes ignore, False: don't ignore.
           :type b: bool
        """
        _ldns.ldns_resolver_set_igntc(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_ip6(self, i):
        """
           Whether the resolver uses ip6.

           :param i: 0: no pref, 1: ip4, 2: ip6
           :type i: uint8_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_ip6(self, i)
    #parameters: ldns_resolver *,uint8_t,
    #retvals: 

    def set_nameserver_count(self, c):
        """
           Set the resolver's name server count directly.

           :param c: The name server count.
           :type c: size_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_nameserver_count(self, c)
    #parameters: ldns_resolver *,size_t,
    #retvals: 

    def set_nameserver_rtt(self, pos, value):
        """
           Set round trip time for a specific name server.
           Note this currently differentiates between: unreachable and
           reachable.

           :param pos: The name server position.
           :type pos: size_t
           :param value: The rtt.
           :type value: size_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_nameserver_rtt(self, pos, value)
    #parameters: ldns_resolver *,size_t,size_t,
    #retvals: 

    def set_nameservers(self, rd):
        """
           Set the resolver's name server count directly by using an
           rdf list.

           :param rd: The resolver addresses.
           :type rd: ldns_rdf \*\*
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_nameservers(self, rd)
    #parameters: ldns_resolver *,ldns_rdf **,
    #retvals: 

    def set_port(self, p):
        """
           Set the port the resolver should use.

           :param p: The port number.
           :type p: uint16_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_port(self, p)
    #parameters: ldns_resolver *,uint16_t,
    #retvals: 

    def set_random(self, b):
        """
           Should the name server list be randomized before each use.

           :param b: True: randomize, False: don't.
           :type b: bool
        """
        _ldns.ldns_resolver_set_random(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_recursive(self, b):
        """
           Set the resolver recursion.

           :param b: True: set to recurse, False: unset.
           :type b: bool
        """
        _ldns.ldns_resolver_set_recursive(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def set_retrans(self, re):
        """
           Set the resolver retrans time-out (in seconds).

           :param re: The retransmission interval in seconds.
           :type re: uint8_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_retrans(self, re)
    #parameters: ldns_resolver *,uint8_t,
    #retvals: 

    def set_retry(self, re):
        """
           Set the resolver retry interval (in seconds).

           :param re: The retry interval.
           :type re: uint8_t
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_retry(self,re)
    #parameters: ldns_resolver *,uint8_t,
    #retvals: 

    def set_rtt(self, rtt):
        """
           Set round trip time for all name servers.
           Note this currently differentiates between: unreachable and reachable.

           :param rtt: A list with the times.
           :type rtt: size \*
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_rtt(self, rtt)
    #parameters: ldns_resolver *,size_t *,
    #retvals: 

    def set_timeout(self, timeout):
        """
           Set the resolver's socket time out when talking to remote hosts.

           :param timeout: The time-out to use.
           :param timeout: struct timeval
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_timeout(self,timeout)
    #parameters: ldns_resolver *,struct timeval,
    #retvals: 

    def set_tsig_algorithm(self, tsig_algorithm):
        """
           Set the tsig algorithm.

           :param tsig_algorithm: The tsig algorithm.
           :param tsig_algorithm: str
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_tsig_algorithm(self, tsig_algorithm)
    #parameters: ldns_resolver *,char *,
    #retvals: 

    def set_tsig_keydata(self, tsig_keydata):
        """
           Set the tsig key data.

           :param tsig_keydata: The key data.
           :type tsig_keydata: str
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_tsig_keydata(self, tsig_keydata)
    #parameters: ldns_resolver *,char *,
    #retvals: 

    def set_tsig_keyname(self, tsig_keyname):
        """
           Set the tsig key name.

           :param tsig_keyname: The tsig key name.
           :type tsig_keyname: str
           :throws TypeError: When arguments of inappropriate types.
        """
        _ldns.ldns_resolver_set_tsig_keyname(self, tsig_keyname)
    #parameters: ldns_resolver *,char *,
    #retvals: 

    def set_usevc(self, b):
        """
           Whether the resolver uses a virtual circuit (TCP).

           :param b: True: use TCP, False: don't use TCP.
           :type b: bool
        """
        _ldns.ldns_resolver_set_usevc(self, b)
    #parameters: ldns_resolver *,bool,
    #retvals: 

    def timeout(self):
        """
           What is the time-out on socket connections.

           :return: (struct timeval) The time-out.
        """
        return _ldns.ldns_resolver_timeout(self)
    #parameters: const ldns_resolver *,
    #retvals: struct timeval

    def trusted_key(self, keys):
        """
           Returns true if at least one of the provided keys is a trust
           anchor.

           :param keys: The key set to check.
           :type keys: :class:`ldns_rr_list`
           :throws TypeError: When arguments of inappropriate types.
           :return: (:class:`ldns_rr_list`) List of trusted keys if at
               least one of the provided keys is a configured trust anchor,
               None else.
        """
        return _ldns._replacement_ldns_resolver_trusted_key(self, keys)
    #parameters: const ldns_resolver *,ldns_rr_list *,ldns_rr_list *,
    #retvals: bool

    def tsig_algorithm(self):
        """
           Return the tsig algorithm as used by the name server.

           :return: (str) The algorithm used.
        """
        return _ldns._ldns_resolver_tsig_algorithm(self)
    #parameters: const ldns_resolver *,
    #retvals: char *

    def tsig_keydata(self):
        """
           Return the tsig key data as used by the name server.

           :return: (str) The key data used.
        """
        return _ldns._ldns_resolver_tsig_keydata(self)
    #parameters: const ldns_resolver *,
    #retvals: char *

    def tsig_keyname(self):
        """
           Return the tsig key name as used by the name server.

           :return: (str) The name used.
        """
        return _ldns._ldns_resolver_tsig_keyname(self)
    #parameters: const ldns_resolver *,
    #retvals: char *

    def usevc(self):
        """
           Does the resolver use tcp or udp.

           :return: (bool) True: tcp, False: udp.
        """
        return _ldns.ldns_resolver_usevc(self)
    #parameters: const ldns_resolver *,
    #retvals: bool

    #
    # _LDNS_RESOLVER_METHODS
    #

ldns_resolver_swigregister = _ldns.ldns_resolver_swigregister
ldns_resolver_swigregister(ldns_resolver)


def ldns_resolver_port(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_port(r)

def ldns_resolver_source(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_source(r)

def ldns_resolver_recursive(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_recursive(r)

def ldns_resolver_debug(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_debug(r)

def ldns_resolver_retry(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_retry(r)

def ldns_resolver_retrans(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_retrans(r)

def ldns_resolver_fallback(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_fallback(r)

def ldns_resolver_ip6(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_ip6(r)

def ldns_resolver_edns_udp_size(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_edns_udp_size(r)

def ldns_resolver_usevc(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_usevc(r)

def ldns_resolver_fail(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_fail(r)

def ldns_resolver_defnames(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_defnames(r)

def ldns_resolver_dnsrch(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_dnsrch(r)

def ldns_resolver_dnssec(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_dnssec(r)

def ldns_resolver_dnssec_cd(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_dnssec_cd(r)

def __ldns_resolver_dnssec_anchors(r):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_dnssec_anchors(r)

def ldns_resolver_igntc(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_igntc(r)

def ldns_resolver_random(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_random(r)

def ldns_resolver_nameserver_count(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_nameserver_count(r)

def __ldns_resolver_domain(r):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_domain(r)

def ldns_resolver_timeout(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_timeout(r)

def ldns_resolver_searchlist(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_searchlist(r)

def ldns_resolver_nameservers(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_nameservers(r)

def ldns_resolver_rtt(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_rtt(r)

def ldns_resolver_nameserver_rtt(r, pos):
    """LDNS buffer."""
    return _ldns.ldns_resolver_nameserver_rtt(r, pos)

def __ldns_resolver_tsig_keyname(r):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_tsig_keyname(r)

def __ldns_resolver_tsig_algorithm(r):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_tsig_algorithm(r)

def __ldns_resolver_tsig_keydata(r):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_tsig_keydata(r)

def ldns_resolver_pop_nameserver(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_pop_nameserver(r)

def ldns_resolver_searchlist_count(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_searchlist_count(r)

def ldns_resolver_set_port(r, p):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_port(r, p)

def ldns_resolver_set_source(r, s):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_source(r, s)

def ldns_resolver_set_recursive(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_recursive(r, b)

def ldns_resolver_set_debug(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_debug(r, b)

def ldns_resolver_incr_nameserver_count(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_incr_nameserver_count(r)

def ldns_resolver_dec_nameserver_count(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_dec_nameserver_count(r)

def ldns_resolver_set_nameserver_count(r, c):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_nameserver_count(r, c)

def __ldns_resolver_set_domain(r, rd):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_set_domain(r, rd)

def ldns_resolver_set_timeout(r, timeout):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_timeout(r, timeout)

def ldns_resolver_push_searchlist(r, rd):
    """LDNS buffer."""
    return _ldns.ldns_resolver_push_searchlist(r, rd)

def ldns_resolver_set_defnames(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_defnames(r, b)

def ldns_resolver_set_usevc(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_usevc(r, b)

def ldns_resolver_set_dnsrch(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_dnsrch(r, b)

def ldns_resolver_set_dnssec(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_dnssec(r, b)

def ldns_resolver_set_dnssec_cd(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_dnssec_cd(r, b)

def __ldns_resolver_set_dnssec_anchors(r, l):
    """LDNS buffer."""
    return _ldns.__ldns_resolver_set_dnssec_anchors(r, l)

def ldns_resolver_push_dnssec_anchor(r, rr):
    """LDNS buffer."""
    return _ldns.ldns_resolver_push_dnssec_anchor(r, rr)

def ldns_resolver_set_retrans(r, re):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_retrans(r, re)

def ldns_resolver_set_fallback(r, fallback):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_fallback(r, fallback)

def ldns_resolver_set_retry(r, re):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_retry(r, re)

def ldns_resolver_set_ip6(r, i):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_ip6(r, i)

def ldns_resolver_set_fail(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_fail(r, b)

def ldns_resolver_set_igntc(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_igntc(r, b)

def ldns_resolver_set_edns_udp_size(r, s):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_edns_udp_size(r, s)

def ldns_resolver_set_tsig_keyname(r, tsig_keyname):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_tsig_keyname(r, tsig_keyname)

def ldns_resolver_set_tsig_algorithm(r, tsig_algorithm):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_tsig_algorithm(r, tsig_algorithm)

def ldns_resolver_set_tsig_keydata(r, tsig_keydata):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_tsig_keydata(r, tsig_keydata)

def ldns_resolver_set_rtt(r, rtt):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_rtt(r, rtt)

def ldns_resolver_set_nameserver_rtt(r, pos, value):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_nameserver_rtt(r, pos, value)

def ldns_resolver_set_random(r, b):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_random(r, b)

def ldns_resolver_push_nameserver(r, n):
    """LDNS buffer."""
    return _ldns.ldns_resolver_push_nameserver(r, n)

def ldns_resolver_push_nameserver_rr(r, rr):
    """LDNS buffer."""
    return _ldns.ldns_resolver_push_nameserver_rr(r, rr)

def ldns_resolver_push_nameserver_rr_list(r, rrlist):
    """LDNS buffer."""
    return _ldns.ldns_resolver_push_nameserver_rr_list(r, rrlist)

def ldns_resolver_search(r, rdf, t, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_resolver_search(r, rdf, t, c, flags)

def ldns_resolver_search_status(r, rdf, t, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_resolver_search_status(r, rdf, t, c, flags)

def ldns_resolver_prepare_query_pkt(r, name, t, c, f):
    """LDNS buffer."""
    return _ldns.ldns_resolver_prepare_query_pkt(r, name, t, c, f)

def ldns_resolver_send(r, name, t, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_resolver_send(r, name, t, c, flags)

def ldns_resolver_send_pkt(r, query_pkt):
    """LDNS buffer."""
    return _ldns.ldns_resolver_send_pkt(r, query_pkt)

def ldns_resolver_query_status(r, name, t, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_resolver_query_status(r, name, t, c, flags)

def ldns_resolver_query(r, name, t, c, flags):
    """LDNS buffer."""
    return _ldns.ldns_resolver_query(r, name, t, c, flags)

def ldns_resolver_new():
    """LDNS buffer."""
    return _ldns.ldns_resolver_new()

def ldns_resolver_clone(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_clone(r)

def ldns_resolver_new_frm_fp(fp):
    """LDNS buffer."""
    return _ldns.ldns_resolver_new_frm_fp(fp)

def ldns_resolver_new_frm_fp_l(fp):
    """LDNS buffer."""
    return _ldns.ldns_resolver_new_frm_fp_l(fp)

def ldns_resolver_new_frm_file(filename):
    """LDNS buffer."""
    return _ldns.ldns_resolver_new_frm_file(filename)

def _ldns_resolver_free(res):
    """LDNS buffer."""
    return _ldns._ldns_resolver_free(res)

def _ldns_resolver_deep_free(res):
    """LDNS buffer."""
    return _ldns._ldns_resolver_deep_free(res)

def ldns_axfr_next(resolver):
    """LDNS buffer."""
    return _ldns.ldns_axfr_next(resolver)

def ldns_axfr_abort(resolver):
    """LDNS buffer."""
    return _ldns.ldns_axfr_abort(resolver)

def ldns_axfr_complete(resolver):
    """LDNS buffer."""
    return _ldns.ldns_axfr_complete(resolver)

def __ldns_axfr_last_pkt(res):
    """LDNS buffer."""
    return _ldns.__ldns_axfr_last_pkt(res)

def ldns_resolver_set_ixfr_serial(r, serial):
    """LDNS buffer."""
    return _ldns.ldns_resolver_set_ixfr_serial(r, serial)

def ldns_resolver_get_ixfr_serial(res):
    """LDNS buffer."""
    return _ldns.ldns_resolver_get_ixfr_serial(res)

def ldns_resolver_nameservers_randomize(r):
    """LDNS buffer."""
    return _ldns.ldns_resolver_nameservers_randomize(r)

def ldns_resolver_trusted_key(r, keys, trusted_keys):
    """LDNS buffer."""
    return _ldns.ldns_resolver_trusted_key(r, keys, trusted_keys)

def ldns_str2rdf_int8(bytestr):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_int8(bytestr)

def ldns_str2rdf_int16(shortstr):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_int16(shortstr)

def ldns_str2rdf_int32(longstr):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_int32(longstr)

def ldns_str2rdf_time(time):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_time(time)

def ldns_str2rdf_nsec3_salt(nsec3_salt):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_nsec3_salt(nsec3_salt)

def ldns_str2rdf_period(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_period(str)

def ldns_str2rdf_a(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_a(str)

def ldns_str2rdf_aaaa(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_aaaa(str)

def ldns_str2rdf_str(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_str(str)

def ldns_str2rdf_apl(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_apl(str)

def ldns_str2rdf_b64(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_b64(str)

def ldns_str2rdf_b32_ext(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_b32_ext(str)

def ldns_str2rdf_hex(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_hex(str)

def ldns_str2rdf_nsec(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_nsec(str)

def ldns_str2rdf_type(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_type(str)

def ldns_str2rdf_class(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_class(str)

def ldns_str2rdf_cert_alg(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_cert_alg(str)

def ldns_str2rdf_alg(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_alg(str)

def ldns_str2rdf_certificate_usage(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_certificate_usage(str)

def ldns_str2rdf_selector(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_selector(str)

def ldns_str2rdf_matching_type(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_matching_type(str)

def ldns_str2rdf_unknown(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_unknown(str)

def ldns_str2rdf_service(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_service(str)

def ldns_str2rdf_loc(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_loc(str)

def ldns_str2rdf_wks(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_wks(str)

def ldns_str2rdf_nsap(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_nsap(str)

def ldns_str2rdf_atma(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_atma(str)

def ldns_str2rdf_ipseckey(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_ipseckey(str)

def ldns_str2rdf_dname(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_dname(str)

def ldns_str2rdf_ilnp64(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_ilnp64(str)

def ldns_str2rdf_eui48(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_eui48(str)

def ldns_str2rdf_eui64(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_eui64(str)

def ldns_str2rdf_tag(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_tag(str)

def ldns_str2rdf_long_str(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_long_str(str)

def ldns_str2rdf_hip(str):
    """LDNS buffer."""
    return _ldns.ldns_str2rdf_hip(str)
class ldns_tsig_credentials(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_tsig_credentials, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_tsig_credentials, name)
    __repr__ = _swig_repr
    __swig_getmethods__["algorithm"] = _ldns.ldns_tsig_credentials_algorithm_get
    if _newclass:
        algorithm = _swig_property(_ldns.ldns_tsig_credentials_algorithm_get)
    __swig_getmethods__["keyname"] = _ldns.ldns_tsig_credentials_keyname_get
    if _newclass:
        keyname = _swig_property(_ldns.ldns_tsig_credentials_keyname_get)
    __swig_getmethods__["keydata"] = _ldns.ldns_tsig_credentials_keydata_get
    if _newclass:
        keydata = _swig_property(_ldns.ldns_tsig_credentials_keydata_get)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_tsig_credentials()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_tsig_credentials
    __del__ = lambda self: None
ldns_tsig_credentials_swigregister = _ldns.ldns_tsig_credentials_swigregister
ldns_tsig_credentials_swigregister(ldns_tsig_credentials)


def ldns_tsig_algorithm(arg1):
    """LDNS buffer."""
    return _ldns.ldns_tsig_algorithm(arg1)

def ldns_tsig_keyname(arg1):
    """LDNS buffer."""
    return _ldns.ldns_tsig_keyname(arg1)

def ldns_tsig_keydata(arg1):
    """LDNS buffer."""
    return _ldns.ldns_tsig_keydata(arg1)

def ldns_tsig_keyname_clone(arg1):
    """LDNS buffer."""
    return _ldns.ldns_tsig_keyname_clone(arg1)

def ldns_tsig_keydata_clone(arg1):
    """LDNS buffer."""
    return _ldns.ldns_tsig_keydata_clone(arg1)

def ldns_pkt_tsig_verify(pkt, wire, wire_size, key_name, key_data, mac):
    """LDNS buffer."""
    return _ldns.ldns_pkt_tsig_verify(pkt, wire, wire_size, key_name, key_data, mac)

def ldns_pkt_tsig_verify_next(pkt, wire, wire_size, key_name, key_data, mac, tsig_timers_only):
    """LDNS buffer."""
    return _ldns.ldns_pkt_tsig_verify_next(pkt, wire, wire_size, key_name, key_data, mac, tsig_timers_only)

def ldns_pkt_tsig_sign(pkt, key_name, key_data, fudge, algorithm_name, query_mac):
    """LDNS buffer."""
    return _ldns.ldns_pkt_tsig_sign(pkt, key_name, key_data, fudge, algorithm_name, query_mac)

def ldns_pkt_tsig_sign_next(pkt, key_name, key_data, fudge, algorithm_name, query_mac, tsig_timers_only):
    """LDNS buffer."""
    return _ldns.ldns_pkt_tsig_sign_next(pkt, key_name, key_data, fudge, algorithm_name, query_mac, tsig_timers_only)

def ldns_update_pkt_new(zone_rdf, clas, pr_rrlist, up_rrlist, ad_rrlist):
    """LDNS buffer."""
    return _ldns.ldns_update_pkt_new(zone_rdf, clas, pr_rrlist, up_rrlist, ad_rrlist)

def ldns_update_pkt_tsig_add(p, r):
    """LDNS buffer."""
    return _ldns.ldns_update_pkt_tsig_add(p, r)

def ldns_update_zocount(p):
    """LDNS buffer."""
    return _ldns.ldns_update_zocount(p)

def ldns_update_prcount(p):
    """LDNS buffer."""
    return _ldns.ldns_update_prcount(p)

def ldns_update_upcount(p):
    """LDNS buffer."""
    return _ldns.ldns_update_upcount(p)

def ldns_update_ad(p):
    """LDNS buffer."""
    return _ldns.ldns_update_ad(p)

def ldns_update_set_zo(p, c):
    """LDNS buffer."""
    return _ldns.ldns_update_set_zo(p, c)

def ldns_update_set_prcount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_update_set_prcount(p, c)

def ldns_update_set_upcount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_update_set_upcount(p, c)

def ldns_update_set_adcount(p, c):
    """LDNS buffer."""
    return _ldns.ldns_update_set_adcount(p, c)

def ldns_update_soa_mname(zone, r, c):
    """LDNS buffer."""
    return _ldns.ldns_update_soa_mname(zone, r, c)

def ldns_update_soa_zone_mname(fqdn, r, c):
    """LDNS buffer."""
    return _ldns.ldns_update_soa_zone_mname(fqdn, r, c)
LDNS_HEADER_SIZE = _ldns.LDNS_HEADER_SIZE
LDNS_RD_MASK = _ldns.LDNS_RD_MASK
LDNS_RD_SHIFT = _ldns.LDNS_RD_SHIFT
LDNS_TC_MASK = _ldns.LDNS_TC_MASK
LDNS_TC_SHIFT = _ldns.LDNS_TC_SHIFT
LDNS_AA_MASK = _ldns.LDNS_AA_MASK
LDNS_AA_SHIFT = _ldns.LDNS_AA_SHIFT
LDNS_OPCODE_MASK = _ldns.LDNS_OPCODE_MASK
LDNS_OPCODE_SHIFT = _ldns.LDNS_OPCODE_SHIFT
LDNS_QR_MASK = _ldns.LDNS_QR_MASK
LDNS_QR_SHIFT = _ldns.LDNS_QR_SHIFT
LDNS_RCODE_MASK = _ldns.LDNS_RCODE_MASK
LDNS_RCODE_SHIFT = _ldns.LDNS_RCODE_SHIFT
LDNS_CD_MASK = _ldns.LDNS_CD_MASK
LDNS_CD_SHIFT = _ldns.LDNS_CD_SHIFT
LDNS_AD_MASK = _ldns.LDNS_AD_MASK
LDNS_AD_SHIFT = _ldns.LDNS_AD_SHIFT
LDNS_Z_MASK = _ldns.LDNS_Z_MASK
LDNS_Z_SHIFT = _ldns.LDNS_Z_SHIFT
LDNS_RA_MASK = _ldns.LDNS_RA_MASK
LDNS_RA_SHIFT = _ldns.LDNS_RA_SHIFT
LDNS_QDCOUNT_OFF = _ldns.LDNS_QDCOUNT_OFF
LDNS_ANCOUNT_OFF = _ldns.LDNS_ANCOUNT_OFF
LDNS_NSCOUNT_OFF = _ldns.LDNS_NSCOUNT_OFF
LDNS_ARCOUNT_OFF = _ldns.LDNS_ARCOUNT_OFF

def ldns_wire2pkt(data, len):
    """LDNS buffer."""
    return _ldns.ldns_wire2pkt(data, len)

def ldns_buffer2pkt_wire(buffer):
    """LDNS buffer."""
    return _ldns.ldns_buffer2pkt_wire(buffer)

def ldns_wire2dname(wire, max, pos):
    """LDNS buffer."""
    return _ldns.ldns_wire2dname(wire, max, pos)

def ldns_wire2rdf(rr, wire, max, pos):
    """LDNS buffer."""
    return _ldns.ldns_wire2rdf(rr, wire, max, pos)

def ldns_wire2rr(wire, max, pos, section):
    """LDNS buffer."""
    return _ldns.ldns_wire2rr(wire, max, pos, section)

def __ldns_rr_a_address(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_a_address(r)

def __ldns_rr_a_set_address(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_a_set_address(r, f)

def __ldns_rr_ns_nsdname(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_ns_nsdname(r)

def __ldns_rr_mx_preference(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_mx_preference(r)

def __ldns_rr_mx_exchange(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_mx_exchange(r)

def __ldns_rr_rrsig_typecovered(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_typecovered(r)

def __ldns_rr_rrsig_set_typecovered(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_typecovered(r, f)

def __ldns_rr_rrsig_algorithm(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_algorithm(r)

def __ldns_rr_rrsig_set_algorithm(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_algorithm(r, f)

def __ldns_rr_rrsig_labels(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_labels(r)

def __ldns_rr_rrsig_set_labels(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_labels(r, f)

def __ldns_rr_rrsig_origttl(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_origttl(r)

def __ldns_rr_rrsig_set_origttl(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_origttl(r, f)

def __ldns_rr_rrsig_expiration(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_expiration(r)

def __ldns_rr_rrsig_set_expiration(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_expiration(r, f)

def __ldns_rr_rrsig_inception(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_inception(r)

def __ldns_rr_rrsig_set_inception(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_inception(r, f)

def __ldns_rr_rrsig_keytag(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_keytag(r)

def __ldns_rr_rrsig_set_keytag(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_keytag(r, f)

def __ldns_rr_rrsig_signame(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_signame(r)

def __ldns_rr_rrsig_set_signame(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_signame(r, f)

def __ldns_rr_rrsig_sig(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_sig(r)

def __ldns_rr_rrsig_set_sig(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_rrsig_set_sig(r, f)

def __ldns_rr_dnskey_flags(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_flags(r)

def __ldns_rr_dnskey_set_flags(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_set_flags(r, f)

def __ldns_rr_dnskey_protocol(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_protocol(r)

def __ldns_rr_dnskey_set_protocol(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_set_protocol(r, f)

def __ldns_rr_dnskey_algorithm(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_algorithm(r)

def __ldns_rr_dnskey_set_algorithm(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_set_algorithm(r, f)

def __ldns_rr_dnskey_key(r):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_key(r)

def __ldns_rr_dnskey_set_key(r, f):
    """LDNS buffer."""
    return _ldns.__ldns_rr_dnskey_set_key(r, f)

def ldns_rr_dnskey_key_size_raw(keydata, len, alg):
    """LDNS buffer."""
    return _ldns.ldns_rr_dnskey_key_size_raw(keydata, len, alg)

def ldns_rr_dnskey_key_size(key):
    """LDNS buffer."""
    return _ldns.ldns_rr_dnskey_key_size(key)

def ldns_soa_serial_identity(unused, data):
    """LDNS buffer."""
    return _ldns.ldns_soa_serial_identity(unused, data)

def ldns_soa_serial_increment(s, unused):
    """LDNS buffer."""
    return _ldns.ldns_soa_serial_increment(s, unused)

def ldns_soa_serial_increment_by(s, data):
    """LDNS buffer."""
    return _ldns.ldns_soa_serial_increment_by(s, data)

def ldns_soa_serial_unixtime(s, data):
    """LDNS buffer."""
    return _ldns.ldns_soa_serial_unixtime(s, data)

def ldns_soa_serial_datecounter(s, data):
    """LDNS buffer."""
    return _ldns.ldns_soa_serial_datecounter(s, data)

def ldns_rr_soa_increment(soa):
    """LDNS buffer."""
    return _ldns.ldns_rr_soa_increment(soa)

def ldns_rr_soa_increment_func(soa, f):
    """LDNS buffer."""
    return _ldns.ldns_rr_soa_increment_func(soa, f)

def ldns_rr_soa_increment_func_data(soa, f, data):
    """LDNS buffer."""
    return _ldns.ldns_rr_soa_increment_func_data(soa, f, data)

def ldns_rr_soa_increment_func_int(soa, f, data):
    """LDNS buffer."""
    return _ldns.ldns_rr_soa_increment_func_int(soa, f, data)
LDNS_KEY_ZONE_KEY = _ldns.LDNS_KEY_ZONE_KEY
LDNS_KEY_SEP_KEY = _ldns.LDNS_KEY_SEP_KEY
LDNS_KEY_REVOKE_KEY = _ldns.LDNS_KEY_REVOKE_KEY
LDNS_RSAMD5 = _ldns.LDNS_RSAMD5
LDNS_DH = _ldns.LDNS_DH
LDNS_DSA = _ldns.LDNS_DSA
LDNS_ECC = _ldns.LDNS_ECC
LDNS_RSASHA1 = _ldns.LDNS_RSASHA1
LDNS_DSA_NSEC3 = _ldns.LDNS_DSA_NSEC3
LDNS_RSASHA1_NSEC3 = _ldns.LDNS_RSASHA1_NSEC3
LDNS_RSASHA256 = _ldns.LDNS_RSASHA256
LDNS_RSASHA512 = _ldns.LDNS_RSASHA512
LDNS_ECC_GOST = _ldns.LDNS_ECC_GOST
LDNS_ECDSAP256SHA256 = _ldns.LDNS_ECDSAP256SHA256
LDNS_ECDSAP384SHA384 = _ldns.LDNS_ECDSAP384SHA384
LDNS_INDIRECT = _ldns.LDNS_INDIRECT
LDNS_PRIVATEDNS = _ldns.LDNS_PRIVATEDNS
LDNS_PRIVATEOID = _ldns.LDNS_PRIVATEOID
LDNS_SHA1 = _ldns.LDNS_SHA1
LDNS_SHA256 = _ldns.LDNS_SHA256
LDNS_HASH_GOST = _ldns.LDNS_HASH_GOST
LDNS_SHA384 = _ldns.LDNS_SHA384
LDNS_SIGN_RSAMD5 = _ldns.LDNS_SIGN_RSAMD5
LDNS_SIGN_RSASHA1 = _ldns.LDNS_SIGN_RSASHA1
LDNS_SIGN_DSA = _ldns.LDNS_SIGN_DSA
LDNS_SIGN_RSASHA1_NSEC3 = _ldns.LDNS_SIGN_RSASHA1_NSEC3
LDNS_SIGN_RSASHA256 = _ldns.LDNS_SIGN_RSASHA256
LDNS_SIGN_RSASHA512 = _ldns.LDNS_SIGN_RSASHA512
LDNS_SIGN_DSA_NSEC3 = _ldns.LDNS_SIGN_DSA_NSEC3
LDNS_SIGN_ECC_GOST = _ldns.LDNS_SIGN_ECC_GOST
LDNS_SIGN_ECDSAP256SHA256 = _ldns.LDNS_SIGN_ECDSAP256SHA256
LDNS_SIGN_ECDSAP384SHA384 = _ldns.LDNS_SIGN_ECDSAP384SHA384
LDNS_SIGN_HMACMD5 = _ldns.LDNS_SIGN_HMACMD5
LDNS_SIGN_HMACSHA1 = _ldns.LDNS_SIGN_HMACSHA1
LDNS_SIGN_HMACSHA256 = _ldns.LDNS_SIGN_HMACSHA256
LDNS_SIGN_HMACSHA224 = _ldns.LDNS_SIGN_HMACSHA224
LDNS_SIGN_HMACSHA384 = _ldns.LDNS_SIGN_HMACSHA384
LDNS_SIGN_HMACSHA512 = _ldns.LDNS_SIGN_HMACSHA512
class ldns_key(_object):
    """
    Key class

    This class can contains all types of keys that are used in DNSSEC. Mostly used to store private keys, since public keys can also be stored in a ldns_rr with type LDNS_RR_TYPE_DNSKEY. This class can also store some variables that influence the signatures generated by signing with this key, for instance the inception date.

    **Usage**

     >>> import ldns
     >>> ldns.ldns_init_random(open("/dev/random","rb"), 512/8)
     >>> key = ldns.ldns_key.new_frm_algorithm(ldns.LDNS_SIGN_DSA, 512) #generate new DSA key
     >>> print key
     Private-key-format: v1.2
     Algorithm: 3 (DSA)
     Prime(p): XXXXXXXXHRQBGRflHZQriSAoLI2g+LGvZz8BlEesO+ZQg65wrFGs9IC441y/mn3nFnXfCdtX6zbN5bQuabPdlQ==
     Subprime(q): XXXXXdnWs/cWsGDglhEyZRLEVA8=
     Base(g): XXXXXXXqrd+dm2bcxDBdCsZRzkXQ22FxCk2ycnjgevr+s2HfA57BPk3xwqCrHUwuOBVg3Fvq4bpldrCe0sT6Og==
     Private_value(x): XXXXXcVubZF33pj04z4ZoETsQW1Y=
     Public_value(y): XXXXXX8t6zfOxJHoy57qteIw9sOZ/Zu0yFiPO083sPm11NlFx3b4m7TJ2k41gYicHXHLUQK1p0xXFToeZEkPGQ==
     >>> fw = open("key.priv", "wb")
     >>> key.print_to_file(fw) #write priv key to file

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_key, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_key, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_alg"] = _ldns.ldns_key__alg_set
    __swig_getmethods__["_alg"] = _ldns.ldns_key__alg_get
    if _newclass:
        _alg = _swig_property(_ldns.ldns_key__alg_get, _ldns.ldns_key__alg_set)
    __swig_setmethods__["_use"] = _ldns.ldns_key__use_set
    __swig_getmethods__["_use"] = _ldns.ldns_key__use_get
    if _newclass:
        _use = _swig_property(_ldns.ldns_key__use_get, _ldns.ldns_key__use_set)
    __swig_getmethods__["_key"] = _ldns.ldns_key__key_get
    if _newclass:
        _key = _swig_property(_ldns.ldns_key__key_get)
    __swig_getmethods__["_extra"] = _ldns.ldns_key__extra_get
    if _newclass:
        _extra = _swig_property(_ldns.ldns_key__extra_get)
    __swig_setmethods__["_pubkey_owner"] = _ldns.ldns_key__pubkey_owner_set
    __swig_getmethods__["_pubkey_owner"] = _ldns.ldns_key__pubkey_owner_get
    if _newclass:
        _pubkey_owner = _swig_property(_ldns.ldns_key__pubkey_owner_get, _ldns.ldns_key__pubkey_owner_set)

    def __init__(self):
        self.this = _ldns.ldns_key_new()
        if not self.this:
            raise Exception("Can't create instance of this class")

    __swig_destroy__ = _ldns._ldns_key_free

    def __str__(self):
        """converts the data to presentation format"""
        return _ldns.ldns_key2str(self)


    def key_to_rr(self):
        """converts a ldns_key to a public key rr

           :returns: (ldns_rr \*) ldns_rr representation of the key
        """
        return _ldns.ldns_key2rr(self)
    #parameters: const ldns_key *,
    #retvals: ldns_rr *

    def print_to_file(self, file):
        """print a private key to the file output

           :param file: output file pointer
        """
        _ldns.ldns_key_print(file, self)
    #parameters: FILE *, const ldns_key *,
    #retvals: 

    #LDNS_KEY_CONSTRUCTORS_#
    @staticmethod
    def new_frm_fp(file, raiseException=True):
        """Creates a new priv key based on the contents of the file pointed by fp. 

           :param file: a file object
           :param raiseException: if True, an exception occurs in case a key instance can't be created
           :returns: key instance or None. If the object can't be created and raiseException is True, an exception occurs.
        """
        status, key = _ldns.ldns_key_new_frm_fp(file)
        if status != LDNS_STATUS_OK:
            if (raiseException): raise Exception("Can't create key, error: %s (%d)" % (_ldns.ldns_get_errorstr_by_id(status),status))
            return None
        return key

    @staticmethod
    def new_frm_fp_l(file, raiseException=True):
        """Creates a new private key based on the contents of the file pointed by fp. 

           :param file: a file object
           :param raiseException: if True, an exception occurs in case a key instance can't be created
           :returns: 
              * key - key instance or None. If an instance can't be created and raiseException is True, an exception occurs.

              * line - the line number (for debugging)
        """
        status, key, line = _ldns.ldns_key_new_frm_fp_l(file)
        if status != LDNS_STATUS_OK:
            if (raiseException): raise Exception("Can't create key, error: %d" % status)
            return None
        return key, line

    @staticmethod
    def new_frm_algorithm(algorithm, size, raiseException=True):
        """Creates a new key based on the algorithm. 

           :param algorithm: the algorithm to use
           :param size: the number of bytes for the keysize
           :param raiseException: if True, an exception occurs in case a key instance can't be created
           :returns: key instance or None. If the object can't be created and raiseException is True, an exception occurs.

           **Algorithms**
             LDNS_SIGN_RSAMD5, LDNS_SIGN_RSASHA1, LDNS_SIGN_DSA, LDNS_SIGN_RSASHA1_NSEC3, LDNS_SIGN_RSASHA256, LDNS_SIGN_RSASHA256_NSEC3, LDNS_SIGN_RSASHA512, LDNS_SIGN_RSASHA512_NSEC3, LDNS_SIGN_DSA_NSEC3, LDNS_SIGN_HMACMD5, LDNS_SIGN_HMACSHA1, LDNS_SIGN_HMACSHA256
        """
        key = _ldns.ldns_key_new_frm_algorithm(algorithm, size)
        if (not key) and (raiseException): raise Exception("Can't create key, error: %d" % status)
        return key
    #_LDNS_KEY_CONSTRUCTORS#

    #LDNS_KEY_METHODS_#
    def algorithm(self):
        """return the signing alg of the key

           :returns: (ldns_signing_algorithm) the algorithm
        """
        return _ldns.ldns_key_algorithm(self)
    #parameters: const ldns_key *,
    #retvals: ldns_signing_algorithm

    def dsa_key(self):
        """returns the (openssl) DSA struct contained in the key

           :returns: (DSA \*) 
        """
        return _ldns.ldns_key_dsa_key(self)
    #parameters: const ldns_key *,
    #retvals: DSA *

    def evp_key(self):
        """returns the (openssl) EVP struct contained in the key

           :returns: (EVP_PKEY \*) the RSA * structure in the key
        """
        return _ldns.ldns_key_evp_key(self)
    #parameters: const ldns_key *,
    #retvals: EVP_PKEY *

    def expiration(self):
        """return the key's expiration date

           :returns: (uint32_t) the experiration date
        """
        return _ldns.ldns_key_expiration(self)
    #parameters: const ldns_key *,
    #retvals: uint32_t

    def flags(self):
        """return the flag of the key

           :returns: (uint16_t) the flag
        """
        return _ldns.ldns_key_flags(self)
    #parameters: const ldns_key *,
    #retvals: uint16_t

    def hmac_key(self):
        """return the hmac key data

           :returns: (unsigned char \*) the hmac key data
        """
        return _ldns.ldns_key_hmac_key(self)
    #parameters: const ldns_key *,
    #retvals: unsigned char *

    def hmac_size(self):
        """return the hmac key size

           :returns: (size_t) the hmac key size
        """
        return _ldns.ldns_key_hmac_size(self)
    #parameters: const ldns_key *,
    #retvals: size_t

    def inception(self):
        """return the key's inception date

           :returns: (uint32_t) the inception date
        """
        return _ldns.ldns_key_inception(self)
    #parameters: const ldns_key *,
    #retvals: uint32_t

    def keytag(self):
        """return the keytag

           :returns: (uint16_t) the keytag
        """
        return _ldns.ldns_key_keytag(self)
    #parameters: const ldns_key *,
    #retvals: uint16_t

    def origttl(self):
        """return the original ttl of the key

           :returns: (uint32_t) the original ttl
        """
        return _ldns.ldns_key_origttl(self)
    #parameters: const ldns_key *,
    #retvals: uint32_t

    def pubkey_owner(self):
        """return the public key's owner

           :returns: (ldns_rdf \*) the owner
        """
        return _ldns.ldns_key_pubkey_owner(self)
    #parameters: const ldns_key *,
    #retvals: ldns_rdf *

    def rsa_key(self):
        """returns the (openssl) RSA struct contained in the key

           :returns: (RSA \*) the RSA * structure in the key
        """
        return _ldns.ldns_key_rsa_key(self)
    #parameters: const ldns_key *,
    #retvals: RSA *

    def set_algorithm(self,l):
        """Set the key's algorithm.

           :param l:
               the algorithm
        """
        _ldns.ldns_key_set_algorithm(self,l)
    #parameters: ldns_key *,ldns_signing_algorithm,
    #retvals: 

    def set_dsa_key(self,d):
        """Set the key's dsa data.

           :param d:
               the dsa data
        """
        _ldns.ldns_key_set_dsa_key(self,d)
    #parameters: ldns_key *,DSA *,
    #retvals: 

    def set_evp_key(self,e):
        """Set the key's evp key.

           :param e:
               the evp key
        """
        _ldns.ldns_key_set_evp_key(self,e)
    #parameters: ldns_key *,EVP_PKEY *,
    #retvals: 

    def set_expiration(self,e):
        """Set the key's expiration date (seconds after epoch).

           :param e:
               the expiration
        """
        _ldns.ldns_key_set_expiration(self,e)
    #parameters: ldns_key *,uint32_t,
    #retvals: 

    def set_flags(self,flags):
        """Set the key's flags.

           :param flags:
               the flags
        """
        _ldns.ldns_key_set_flags(self,flags)
    #parameters: ldns_key *,uint16_t,
    #retvals: 

    def set_hmac_key(self,hmac):
        """Set the key's hmac data.

           :param hmac:
               the raw key data
        """
        _ldns.ldns_key_set_hmac_key(self,hmac)
    #parameters: ldns_key *,unsigned char *,
    #retvals: 

    def set_hmac_size(self,hmac_size):
        """Set the key's hmac size.

           :param hmac_size:
               the size of the hmac data
        """
        _ldns.ldns_key_set_hmac_size(self,hmac_size)
    #parameters: ldns_key *,size_t,
    #retvals: 

    def set_inception(self,i):
        """Set the key's inception date (seconds after epoch).

           :param i:
               the inception
        """
        _ldns.ldns_key_set_inception(self,i)
    #parameters: ldns_key *,uint32_t,
    #retvals: 

    def set_keytag(self,tag):
        """Set the key's key tag.

           :param tag:
               the keytag
        """
        _ldns.ldns_key_set_keytag(self,tag)
    #parameters: ldns_key *,uint16_t,
    #retvals: 

    def set_origttl(self,t):
        """Set the key's original ttl.

           :param t:
               the ttl
        """
        _ldns.ldns_key_set_origttl(self,t)
    #parameters: ldns_key *,uint32_t,
    #retvals: 

    def set_pubkey_owner(self,r):
        """Set the key's pubkey owner.

           :param r:
               the owner
        """
        _ldns.ldns_key_set_pubkey_owner(self,r)
    #parameters: ldns_key *,ldns_rdf *,
    #retvals: 

    def set_rsa_key(self,r):
        """Set the key's rsa data.

           :param r:
               the rsa data
        """
        _ldns.ldns_key_set_rsa_key(self,r)
    #parameters: ldns_key *,RSA *,
    #retvals: 

    def set_use(self,v):
        """set the use flag

           :param v:
               the boolean value to set the _use field to
        """
        _ldns.ldns_key_set_use(self,v)
    #parameters: ldns_key *,bool,
    #retvals: 

    def use(self):
        """return the use flag

           :returns: (bool) the boolean value of the _use field
        """
        return _ldns.ldns_key_use(self)
    #parameters: const ldns_key *,
    #retvals: bool
    #_LDNS_KEY_METHODS#

ldns_key_swigregister = _ldns.ldns_key_swigregister
ldns_key_swigregister(ldns_key)
ldns_signing_algorithms = cvar.ldns_signing_algorithms

class ldns_struct_key__extra(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_key__extra, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_key__extra, name)
    __repr__ = _swig_repr
    __swig_getmethods__["dnssec"] = _ldns.ldns_struct_key__extra_dnssec_get
    if _newclass:
        dnssec = _swig_property(_ldns.ldns_struct_key__extra_dnssec_get)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_key__extra()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_key__extra
    __del__ = lambda self: None
ldns_struct_key__extra_swigregister = _ldns.ldns_struct_key__extra_swigregister
ldns_struct_key__extra_swigregister(ldns_struct_key__extra)

class ldns_struct_key__extra_dnssec(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_key__extra_dnssec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_key__extra_dnssec, name)
    __repr__ = _swig_repr
    __swig_setmethods__["orig_ttl"] = _ldns.ldns_struct_key__extra_dnssec_orig_ttl_set
    __swig_getmethods__["orig_ttl"] = _ldns.ldns_struct_key__extra_dnssec_orig_ttl_get
    if _newclass:
        orig_ttl = _swig_property(_ldns.ldns_struct_key__extra_dnssec_orig_ttl_get, _ldns.ldns_struct_key__extra_dnssec_orig_ttl_set)
    __swig_setmethods__["inception"] = _ldns.ldns_struct_key__extra_dnssec_inception_set
    __swig_getmethods__["inception"] = _ldns.ldns_struct_key__extra_dnssec_inception_get
    if _newclass:
        inception = _swig_property(_ldns.ldns_struct_key__extra_dnssec_inception_get, _ldns.ldns_struct_key__extra_dnssec_inception_set)
    __swig_setmethods__["expiration"] = _ldns.ldns_struct_key__extra_dnssec_expiration_set
    __swig_getmethods__["expiration"] = _ldns.ldns_struct_key__extra_dnssec_expiration_get
    if _newclass:
        expiration = _swig_property(_ldns.ldns_struct_key__extra_dnssec_expiration_get, _ldns.ldns_struct_key__extra_dnssec_expiration_set)
    __swig_setmethods__["keytag"] = _ldns.ldns_struct_key__extra_dnssec_keytag_set
    __swig_getmethods__["keytag"] = _ldns.ldns_struct_key__extra_dnssec_keytag_get
    if _newclass:
        keytag = _swig_property(_ldns.ldns_struct_key__extra_dnssec_keytag_get, _ldns.ldns_struct_key__extra_dnssec_keytag_set)
    __swig_setmethods__["flags"] = _ldns.ldns_struct_key__extra_dnssec_flags_set
    __swig_getmethods__["flags"] = _ldns.ldns_struct_key__extra_dnssec_flags_get
    if _newclass:
        flags = _swig_property(_ldns.ldns_struct_key__extra_dnssec_flags_get, _ldns.ldns_struct_key__extra_dnssec_flags_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_key__extra_dnssec()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_key__extra_dnssec
    __del__ = lambda self: None
ldns_struct_key__extra_dnssec_swigregister = _ldns.ldns_struct_key__extra_dnssec_swigregister
ldns_struct_key__extra_dnssec_swigregister(ldns_struct_key__extra_dnssec)

class ldns_struct_key__key(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_key__key, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_key__key, name)
    __repr__ = _swig_repr
    __swig_getmethods__["hmac"] = _ldns.ldns_struct_key__key_hmac_get
    if _newclass:
        hmac = _swig_property(_ldns.ldns_struct_key__key_hmac_get)
    __swig_setmethods__["external_key"] = _ldns.ldns_struct_key__key_external_key_set
    __swig_getmethods__["external_key"] = _ldns.ldns_struct_key__key_external_key_get
    if _newclass:
        external_key = _swig_property(_ldns.ldns_struct_key__key_external_key_get, _ldns.ldns_struct_key__key_external_key_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_key__key()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_key__key
    __del__ = lambda self: None
ldns_struct_key__key_swigregister = _ldns.ldns_struct_key__key_swigregister
ldns_struct_key__key_swigregister(ldns_struct_key__key)

class ldns_struct_key__key_hmac(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_key__key_hmac, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_key__key_hmac, name)
    __repr__ = _swig_repr
    __swig_setmethods__["key"] = _ldns.ldns_struct_key__key_hmac_key_set
    __swig_getmethods__["key"] = _ldns.ldns_struct_key__key_hmac_key_get
    if _newclass:
        key = _swig_property(_ldns.ldns_struct_key__key_hmac_key_get, _ldns.ldns_struct_key__key_hmac_key_set)
    __swig_setmethods__["size"] = _ldns.ldns_struct_key__key_hmac_size_set
    __swig_getmethods__["size"] = _ldns.ldns_struct_key__key_hmac_size_get
    if _newclass:
        size = _swig_property(_ldns.ldns_struct_key__key_hmac_size_get, _ldns.ldns_struct_key__key_hmac_size_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_key__key_hmac()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_key__key_hmac
    __del__ = lambda self: None
ldns_struct_key__key_hmac_swigregister = _ldns.ldns_struct_key__key_hmac_swigregister
ldns_struct_key__key_hmac_swigregister(ldns_struct_key__key_hmac)

class ldns_key_list(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_key_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_key_list, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_key_count"] = _ldns.ldns_key_list__key_count_set
    __swig_getmethods__["_key_count"] = _ldns.ldns_key_list__key_count_get
    if _newclass:
        _key_count = _swig_property(_ldns.ldns_key_list__key_count_get, _ldns.ldns_key_list__key_count_set)
    __swig_setmethods__["_keys"] = _ldns.ldns_key_list__keys_set
    __swig_getmethods__["_keys"] = _ldns.ldns_key_list__keys_get
    if _newclass:
        _keys = _swig_property(_ldns.ldns_key_list__keys_get, _ldns.ldns_key_list__keys_set)

    def __init__(self):
        self.this = _ldns.ldns_key_list_new()
        if not self.this:
            raise Exception("Can't create class")

    __swig_destroy__ = _ldns._ldns_key_list_free

    def keys(self):
        """Key list iterator"""
        for i in range(0, self.key_count()):
            yield self.key(i)

    def __str__(self):
        i = 0
        s = ""
        for k in self.keys():
            i += 1
            s += "key %d:\n   %s\n" % (i, str(k).replace("\n","\n   "))
        return s

    #LDNS_KEY_LIST_METHODS_#
    def key(self,nr):
        """returns a pointer to the key in the list at the given position

           :param nr:
               the position in the list
           :returns: (ldns_key \*) the key
        """
        return _ldns.ldns_key_list_key(self,nr)
    #parameters: const ldns_key_list *,size_t,
    #retvals: ldns_key *

    def key_count(self):
        """returns the number of keys in the key list

           :returns: (size_t) the numbers of keys in the list
        """
        return _ldns.ldns_key_list_key_count(self)
    #parameters: const ldns_key_list *,
    #retvals: size_t

    def pop_key(self):
        """pops the last rr from a keylist

           :returns: (ldns_key \*) NULL if nothing to pop. Otherwise the popped RR
        """
        return _ldns.ldns_key_list_pop_key(self)
    #parameters: ldns_key_list *,
    #retvals: ldns_key *

    def push_key(self,key):
        """pushes a key to a keylist

           :param key:
               the key to push
           :returns: (bool) false on error, otherwise true
        """
        return _ldns.ldns_key_list_push_key(self,key)
    #parameters: ldns_key_list *,ldns_key *,
    #retvals: bool

    def set_key_count(self,count):
        """Set the keylist's key count to count.

           :param count:
               the cuont
        """
        _ldns.ldns_key_list_set_key_count(self,count)
    #parameters: ldns_key_list *,size_t,
    #retvals: 

    def set_use(self,v):
        """Set the 'use' flag for all keys in the list.

           :param v:
               The value to set the use flags to
        """
        _ldns.ldns_key_list_set_use(self,v)
    #parameters: ldns_key_list *,bool,
    #retvals: 

    #_LDNS_KEY_LIST_METHODS#

ldns_key_list_swigregister = _ldns.ldns_key_list_swigregister
ldns_key_list_swigregister(ldns_key_list)


def ldns_key_list_new():
    """LDNS buffer."""
    return _ldns.ldns_key_list_new()

def ldns_key_new():
    """LDNS buffer."""
    return _ldns.ldns_key_new()

def ldns_key_new_frm_algorithm(a, size):
    """LDNS buffer."""
    return _ldns.ldns_key_new_frm_algorithm(a, size)

def ldns_key_new_frm_fp(fp):
    """LDNS buffer."""
    return _ldns.ldns_key_new_frm_fp(fp)

def ldns_key_new_frm_fp_l(fp):
    """LDNS buffer."""
    return _ldns.ldns_key_new_frm_fp_l(fp)

def ldns_key_set_algorithm(k, l):
    """LDNS buffer."""
    return _ldns.ldns_key_set_algorithm(k, l)

def ldns_key_set_hmac_key(k, hmac):
    """LDNS buffer."""
    return _ldns.ldns_key_set_hmac_key(k, hmac)

def ldns_key_set_external_key(key, external_key):
    """LDNS buffer."""
    return _ldns.ldns_key_set_external_key(key, external_key)

def ldns_key_set_hmac_size(k, hmac_size):
    """LDNS buffer."""
    return _ldns.ldns_key_set_hmac_size(k, hmac_size)

def ldns_key_set_origttl(k, t):
    """LDNS buffer."""
    return _ldns.ldns_key_set_origttl(k, t)

def ldns_key_set_inception(k, i):
    """LDNS buffer."""
    return _ldns.ldns_key_set_inception(k, i)

def ldns_key_set_expiration(k, e):
    """LDNS buffer."""
    return _ldns.ldns_key_set_expiration(k, e)

def ldns_key_set_pubkey_owner(k, r):
    """LDNS buffer."""
    return _ldns.ldns_key_set_pubkey_owner(k, r)

def ldns_key_set_keytag(k, tag):
    """LDNS buffer."""
    return _ldns.ldns_key_set_keytag(k, tag)

def ldns_key_set_flags(k, flags):
    """LDNS buffer."""
    return _ldns.ldns_key_set_flags(k, flags)

def ldns_key_list_set_key_count(key, count):
    """LDNS buffer."""
    return _ldns.ldns_key_list_set_key_count(key, count)

def ldns_key_list_push_key(key_list, key):
    """LDNS buffer."""
    return _ldns.ldns_key_list_push_key(key_list, key)

def ldns_key_list_key_count(key_list):
    """LDNS buffer."""
    return _ldns.ldns_key_list_key_count(key_list)

def ldns_key_list_key(key, nr):
    """LDNS buffer."""
    return _ldns.ldns_key_list_key(key, nr)

def ldns_key_algorithm(k):
    """LDNS buffer."""
    return _ldns.ldns_key_algorithm(k)

def ldns_key_set_use(k, v):
    """LDNS buffer."""
    return _ldns.ldns_key_set_use(k, v)

def ldns_key_use(k):
    """LDNS buffer."""
    return _ldns.ldns_key_use(k)

def ldns_key_hmac_key(k):
    """LDNS buffer."""
    return _ldns.ldns_key_hmac_key(k)

def ldns_key_external_key(k):
    """LDNS buffer."""
    return _ldns.ldns_key_external_key(k)

def ldns_key_hmac_size(k):
    """LDNS buffer."""
    return _ldns.ldns_key_hmac_size(k)

def ldns_key_origttl(k):
    """LDNS buffer."""
    return _ldns.ldns_key_origttl(k)

def ldns_key_inception(k):
    """LDNS buffer."""
    return _ldns.ldns_key_inception(k)

def ldns_key_expiration(k):
    """LDNS buffer."""
    return _ldns.ldns_key_expiration(k)

def ldns_key_keytag(k):
    """LDNS buffer."""
    return _ldns.ldns_key_keytag(k)

def ldns_key_pubkey_owner(k):
    """LDNS buffer."""
    return _ldns.ldns_key_pubkey_owner(k)

def ldns_key_list_set_use(keys, v):
    """LDNS buffer."""
    return _ldns.ldns_key_list_set_use(keys, v)

def ldns_key_flags(k):
    """LDNS buffer."""
    return _ldns.ldns_key_flags(k)

def ldns_key_list_pop_key(key_list):
    """LDNS buffer."""
    return _ldns.ldns_key_list_pop_key(key_list)

def ldns_key2rr(k):
    """LDNS buffer."""
    return _ldns.ldns_key2rr(k)

def ldns_key_print(output, k):
    """LDNS buffer."""
    return _ldns.ldns_key_print(output, k)

def __ldns_key_free(key):
    """LDNS buffer."""
    return _ldns.__ldns_key_free(key)

def _ldns_key_free(key):
    """LDNS buffer."""
    return _ldns._ldns_key_free(key)

def _ldns_key_list_free(key_list):
    """LDNS buffer."""
    return _ldns._ldns_key_list_free(key_list)

def ldns_read_anchor_file(filename):
    """LDNS buffer."""
    return _ldns.ldns_read_anchor_file(filename)

def ldns_key_get_file_base_name(key):
    """LDNS buffer."""
    return _ldns.ldns_key_get_file_base_name(key)

def ldns_key_algo_supported(algo):
    """LDNS buffer."""
    return _ldns.ldns_key_algo_supported(algo)

def ldns_get_signing_algorithm_by_name(name):
    """LDNS buffer."""
    return _ldns.ldns_get_signing_algorithm_by_name(name)
LDNS_PARSE_SKIP_SPACE = _ldns.LDNS_PARSE_SKIP_SPACE
LDNS_PARSE_NORMAL = _ldns.LDNS_PARSE_NORMAL
LDNS_PARSE_NO_NL = _ldns.LDNS_PARSE_NO_NL
LDNS_MAX_LINELEN = _ldns.LDNS_MAX_LINELEN
LDNS_MAX_KEYWORDLEN = _ldns.LDNS_MAX_KEYWORDLEN
LDNS_DIR_TTL = _ldns.LDNS_DIR_TTL
LDNS_DIR_ORIGIN = _ldns.LDNS_DIR_ORIGIN
LDNS_DIR_INCLUDE = _ldns.LDNS_DIR_INCLUDE

def ldns_fget_token(f, token, delim, limit):
    """LDNS buffer."""
    return _ldns.ldns_fget_token(f, token, delim, limit)

def ldns_fget_token_l(f, token, delim, limit):
    """LDNS buffer."""
    return _ldns.ldns_fget_token_l(f, token, delim, limit)

def ldns_bget_token(b, token, delim, limit):
    """LDNS buffer."""
    return _ldns.ldns_bget_token(b, token, delim, limit)

def ldns_fget_keyword_data(f, keyword, k_del, data, d_del, data_limit):
    """LDNS buffer."""
    return _ldns.ldns_fget_keyword_data(f, keyword, k_del, data, d_del, data_limit)

def ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del, data_limit):
    """LDNS buffer."""
    return _ldns.ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del, data_limit)

def ldns_bget_keyword_data(b, keyword, k_del, data, d_del, data_limit):
    """LDNS buffer."""
    return _ldns.ldns_bget_keyword_data(b, keyword, k_del, data, d_del, data_limit)

def ldns_bgetc(buffer):
    """LDNS buffer."""
    return _ldns.ldns_bgetc(buffer)

def ldns_bskipcs(buffer, s):
    """LDNS buffer."""
    return _ldns.ldns_bskipcs(buffer, s)

def ldns_fskipcs(fp, s):
    """LDNS buffer."""
    return _ldns.ldns_fskipcs(fp, s)

def ldns_fskipcs_l(fp, s):
    """LDNS buffer."""
    return _ldns.ldns_fskipcs_l(fp, s)
class ldns_zone(_object):
    """
    Zone definitions

    **Usage**

    This class is able to read and parse the content of zone file by doing:

    >>> import ldns
    >>> zone = ldns.ldns_zone.new_frm_fp(open("zone.txt","r"), None, 0, ldns.LDNS_RR_CLASS_IN)
    >>> print zone.soa()
    example.	600	IN	SOA	example. admin.example. 2008022501 28800 7200 604800 18000
    >>> print zone.rrs()
    example.	600	IN	MX	10 mail.example.
    example.	600	IN	NS	ns1.example.
    example.	600	IN	NS	ns2.example.
    example.	600	IN	A	192.168.1.1

    The ``zone.txt`` file contains the following records::

       $ORIGIN example.
       $TTL 600

       example.        IN SOA  example. admin.example. (
                                       2008022501 ; serial
                                       28800      ; refresh (8 hours)
                                       7200       ; retry (2 hours)
                                       604800     ; expire (1 week)
                                       18000      ; minimum (5 hours)
                                       )

       @       IN      MX      10 mail.example.
       @       IN      NS      ns1
       @       IN      NS      ns2
       @       IN      A       192.168.1.1

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_zone, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_zone, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __init__(self):
        self.this = _ldns.ldns_zone_new()
        if not self.this:
            raise Exception("Can't create zone.")

    __swig_destroy__ = _ldns._ldns_zone_free

    def __str__(self):
        return str(self.soa()) + "\n" + str(self.rrs())

    def print_to_file(self,output):
        """Prints the data in the zone to the given file stream (in presentation format)."""
        _ldns.ldns_zone_print(output,self)
    #parameters: FILE *,const ldns_zone *,

    #LDNS_ZONE_CONSTRUCTORS_#
    @staticmethod
    def new_frm_fp(file, origin, ttl, rr_class=_ldns.LDNS_RR_CLASS_IN, raiseException=True):
        """Creates a new zone object from given file pointer

           :param file: a file object
           :param origin: (ldns_rdf) the zones' origin
           :param ttl: default ttl to use
           :param rr_class: efault class to use (IN)
           :param raiseException: if True, an exception occurs in case a zone instance can't be created
           :returns: zone instance or None. If an instance can't be created and raiseException is True, an exception occurs.
        """
        status, zone = _ldns.ldns_zone_new_frm_fp(file, origin, ttl, rr_class)
        if status != LDNS_STATUS_OK:
            if (raiseException): raise Exception("Can't create zone, error: %s (%d)" % (_ldns.ldns_get_errorstr_by_id(status),status))
            return None
        return zone

    @staticmethod
    def new_frm_fp_l(file, origin, ttl, rr_class, raiseException=True):
        """Create a new zone from a file, keep track of the line numbering

           :param file: a file object
           :param origin: (ldns_rdf) the zones' origin
           :param ttl: default ttl to use
           :param rr_class: efault class to use (IN)
           :param raiseException: if True, an exception occurs in case a zone instance can't be created
           :returns: 
               * zone - zone instance or None. If an instance can't be created and raiseException is True, an exception occurs.

               * line - used for error msg, to get to the line number
        """
        status, zone = _ldns.ldns_zone_new_frm_fp_l(file, line)
        if status != LDNS_STATUS_OK:
            if (raiseException): raise Exception("Can't create zone, error: %d" % status)
            return None
        return zone
    #_LDNS_ZONE_CONSTRUCTORS#

    def sign(self,key_list):
        """Signs the zone, and returns a newly allocated signed zone.

           :param key_list:
               list of keys to sign with
           :returns: (ldns_zone \*) signed zone
        """
        return _ldns.ldns_zone_sign(self,key_list)
    #parameters: const ldns_zone *,ldns_key_list *,
    #retvals: ldns_zone *

    def sign_nsec3(self,key_list,algorithm,flags,iterations,salt_length,salt):
        """Signs the zone with NSEC3, and returns a newly allocated signed zone.

           :param key_list:
               list of keys to sign with
           :param algorithm:
               the NSEC3 hashing algorithm to use
           :param flags:
               NSEC3 flags
           :param iterations:
               the number of NSEC3 hash iterations to use
           :param salt_length:
               the length (in octets) of the NSEC3 salt
           :param salt:
               the NSEC3 salt data
           :returns: (ldns_zone \*) signed zone
        """
        return _ldns.ldns_zone_sign_nsec3(self,key_list,algorithm,flags,iterations,salt_length,salt)
    #parameters: ldns_zone *,ldns_key_list *,uint8_t,uint8_t,uint16_t,uint8_t,uint8_t *,
    #retvals: ldns_zone *

    #LDNS_ZONE_METHODS_#
    def glue_rr_list(self):
        """Retrieve all resource records from the zone that are glue records.

           The resulting list does are pointer references to the zone's data.

           Due to the current zone implementation (as a list of rr's), this function is extremely slow. Another (probably better) way to do this is to use an ldns_dnssec_zone structure and the mark_glue function

           :returns: (ldns_rr_list \*) the rr_list with the glue
        """
        return _ldns.ldns_zone_glue_rr_list(self)
    #parameters: const ldns_zone *,
    #retvals: ldns_rr_list *

    def push_rr(self,rr):
        """push an single rr to a zone structure.

           This function use pointer copying, so the rr_list structure inside z is modified!

           :param rr:
               the rr to add
           :returns: (bool) a true on succes otherwise falsed
        """
        return _ldns.ldns_zone_push_rr(self,rr)
    #parameters: ldns_zone *,ldns_rr *,
    #retvals: bool

    def push_rr_list(self,list):
        """push an rrlist to a zone structure.

           This function use pointer copying, so the rr_list structure inside z is modified!

           :param list:
               the list to add
           :returns: (bool) a true on succes otherwise falsed
        """
        return _ldns.ldns_zone_push_rr_list(self,list)
    #parameters: ldns_zone *,ldns_rr_list *,
    #retvals: bool

    def rr_count(self):
        """Returns the number of resource records in the zone, NOT counting the SOA record.

           :returns: (size_t) the number of rr's in the zone
        """
        return _ldns.ldns_zone_rr_count(self)
    #parameters: const ldns_zone *,
    #retvals: size_t

    def rrs(self):
        """Get a list of a zone's content.

           Note that the SOA isn't included in this list. You need to get the with ldns_zone_soa.

           :returns: (ldns_rr_list \*) the rrs from this zone
        """
        return _ldns.ldns_zone_rrs(self)
    #parameters: const ldns_zone *,
    #retvals: ldns_rr_list *

    def set_rrs(self,rrlist):
        """Set the zone's contents.

           :param rrlist:
               the rrlist to use
        """
        _ldns.ldns_zone_set_rrs(self,rrlist)
    #parameters: ldns_zone *,ldns_rr_list *,
    #retvals: 

    def set_soa(self,soa):
        """Set the zone's soa record.

           :param soa:
               the soa to set
        """
        _ldns.ldns_zone_set_soa(self,soa)
    #parameters: ldns_zone *,ldns_rr *,
    #retvals: 

    def soa(self):
        """Return the soa record of a zone.

           :returns: (ldns_rr \*) the soa record in the zone
        """
        return _ldns.ldns_zone_soa(self)
    #parameters: const ldns_zone *,
    #retvals: ldns_rr *

    def sort(self):
        """Sort the rrs in a zone, with the current impl.

           this is slow
        """
        _ldns.ldns_zone_sort(self)
    #parameters: ldns_zone *,
    #retvals: 

    #_LDNS_ZONE_METHODS#

ldns_zone_swigregister = _ldns.ldns_zone_swigregister
ldns_zone_swigregister(ldns_zone)


def ldns_zone_new():
    """LDNS buffer."""
    return _ldns.ldns_zone_new()

def ldns_zone_soa(z):
    """LDNS buffer."""
    return _ldns.ldns_zone_soa(z)

def ldns_zone_rr_count(z):
    """LDNS buffer."""
    return _ldns.ldns_zone_rr_count(z)

def ldns_zone_set_soa(z, soa):
    """LDNS buffer."""
    return _ldns.ldns_zone_set_soa(z, soa)

def ldns_zone_rrs(z):
    """LDNS buffer."""
    return _ldns.ldns_zone_rrs(z)

def ldns_zone_set_rrs(z, rrlist):
    """LDNS buffer."""
    return _ldns.ldns_zone_set_rrs(z, rrlist)

def ldns_zone_push_rr_list(z, list):
    """LDNS buffer."""
    return _ldns.ldns_zone_push_rr_list(z, list)

def ldns_zone_push_rr(z, rr):
    """LDNS buffer."""
    return _ldns.ldns_zone_push_rr(z, rr)

def ldns_zone_glue_rr_list(z):
    """LDNS buffer."""
    return _ldns.ldns_zone_glue_rr_list(z)

def ldns_zone_new_frm_fp(fp, origin, ttl, c):
    """LDNS buffer."""
    return _ldns.ldns_zone_new_frm_fp(fp, origin, ttl, c)

def ldns_zone_new_frm_fp_l(fp, origin, ttl, c):
    """LDNS buffer."""
    return _ldns.ldns_zone_new_frm_fp_l(fp, origin, ttl, c)

def __ldns_zone_free(zone):
    """LDNS buffer."""
    return _ldns.__ldns_zone_free(zone)

def _ldns_zone_free(zone):
    """LDNS buffer."""
    return _ldns._ldns_zone_free(zone)

def ldns_zone_sort(zone):
    """LDNS buffer."""
    return _ldns.ldns_zone_sort(zone)
class ldns_struct_dnssec_rrs(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_dnssec_rrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_dnssec_rrs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rr"] = _ldns.ldns_struct_dnssec_rrs_rr_set
    __swig_getmethods__["rr"] = _ldns.ldns_struct_dnssec_rrs_rr_get
    if _newclass:
        rr = _swig_property(_ldns.ldns_struct_dnssec_rrs_rr_get, _ldns.ldns_struct_dnssec_rrs_rr_set)
    __swig_setmethods__["next"] = _ldns.ldns_struct_dnssec_rrs_next_set
    __swig_getmethods__["next"] = _ldns.ldns_struct_dnssec_rrs_next_get
    if _newclass:
        next = _swig_property(_ldns.ldns_struct_dnssec_rrs_next_get, _ldns.ldns_struct_dnssec_rrs_next_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_dnssec_rrs()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_dnssec_rrs
    __del__ = lambda self: None
ldns_struct_dnssec_rrs_swigregister = _ldns.ldns_struct_dnssec_rrs_swigregister
ldns_struct_dnssec_rrs_swigregister(ldns_struct_dnssec_rrs)

class ldns_struct_dnssec_rrsets(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_dnssec_rrsets, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_dnssec_rrsets, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rrs"] = _ldns.ldns_struct_dnssec_rrsets_rrs_set
    __swig_getmethods__["rrs"] = _ldns.ldns_struct_dnssec_rrsets_rrs_get
    if _newclass:
        rrs = _swig_property(_ldns.ldns_struct_dnssec_rrsets_rrs_get, _ldns.ldns_struct_dnssec_rrsets_rrs_set)
    __swig_setmethods__["type"] = _ldns.ldns_struct_dnssec_rrsets_type_set
    __swig_getmethods__["type"] = _ldns.ldns_struct_dnssec_rrsets_type_get
    if _newclass:
        type = _swig_property(_ldns.ldns_struct_dnssec_rrsets_type_get, _ldns.ldns_struct_dnssec_rrsets_type_set)
    __swig_setmethods__["signatures"] = _ldns.ldns_struct_dnssec_rrsets_signatures_set
    __swig_getmethods__["signatures"] = _ldns.ldns_struct_dnssec_rrsets_signatures_get
    if _newclass:
        signatures = _swig_property(_ldns.ldns_struct_dnssec_rrsets_signatures_get, _ldns.ldns_struct_dnssec_rrsets_signatures_set)
    __swig_setmethods__["next"] = _ldns.ldns_struct_dnssec_rrsets_next_set
    __swig_getmethods__["next"] = _ldns.ldns_struct_dnssec_rrsets_next_get
    if _newclass:
        next = _swig_property(_ldns.ldns_struct_dnssec_rrsets_next_get, _ldns.ldns_struct_dnssec_rrsets_next_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_dnssec_rrsets()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_dnssec_rrsets
    __del__ = lambda self: None
ldns_struct_dnssec_rrsets_swigregister = _ldns.ldns_struct_dnssec_rrsets_swigregister
ldns_struct_dnssec_rrsets_swigregister(ldns_struct_dnssec_rrsets)

class ldns_struct_dnssec_name(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_dnssec_name, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_dnssec_name, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _ldns.ldns_struct_dnssec_name_name_set
    __swig_getmethods__["name"] = _ldns.ldns_struct_dnssec_name_name_get
    if _newclass:
        name = _swig_property(_ldns.ldns_struct_dnssec_name_name_get, _ldns.ldns_struct_dnssec_name_name_set)
    __swig_setmethods__["name_alloced"] = _ldns.ldns_struct_dnssec_name_name_alloced_set
    __swig_getmethods__["name_alloced"] = _ldns.ldns_struct_dnssec_name_name_alloced_get
    if _newclass:
        name_alloced = _swig_property(_ldns.ldns_struct_dnssec_name_name_alloced_get, _ldns.ldns_struct_dnssec_name_name_alloced_set)
    __swig_setmethods__["rrsets"] = _ldns.ldns_struct_dnssec_name_rrsets_set
    __swig_getmethods__["rrsets"] = _ldns.ldns_struct_dnssec_name_rrsets_get
    if _newclass:
        rrsets = _swig_property(_ldns.ldns_struct_dnssec_name_rrsets_get, _ldns.ldns_struct_dnssec_name_rrsets_set)
    __swig_setmethods__["nsec"] = _ldns.ldns_struct_dnssec_name_nsec_set
    __swig_getmethods__["nsec"] = _ldns.ldns_struct_dnssec_name_nsec_get
    if _newclass:
        nsec = _swig_property(_ldns.ldns_struct_dnssec_name_nsec_get, _ldns.ldns_struct_dnssec_name_nsec_set)
    __swig_setmethods__["nsec_signatures"] = _ldns.ldns_struct_dnssec_name_nsec_signatures_set
    __swig_getmethods__["nsec_signatures"] = _ldns.ldns_struct_dnssec_name_nsec_signatures_get
    if _newclass:
        nsec_signatures = _swig_property(_ldns.ldns_struct_dnssec_name_nsec_signatures_get, _ldns.ldns_struct_dnssec_name_nsec_signatures_set)
    __swig_setmethods__["is_glue"] = _ldns.ldns_struct_dnssec_name_is_glue_set
    __swig_getmethods__["is_glue"] = _ldns.ldns_struct_dnssec_name_is_glue_get
    if _newclass:
        is_glue = _swig_property(_ldns.ldns_struct_dnssec_name_is_glue_get, _ldns.ldns_struct_dnssec_name_is_glue_set)
    __swig_setmethods__["hashed_name"] = _ldns.ldns_struct_dnssec_name_hashed_name_set
    __swig_getmethods__["hashed_name"] = _ldns.ldns_struct_dnssec_name_hashed_name_get
    if _newclass:
        hashed_name = _swig_property(_ldns.ldns_struct_dnssec_name_hashed_name_get, _ldns.ldns_struct_dnssec_name_hashed_name_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_dnssec_name()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_dnssec_name
    __del__ = lambda self: None
ldns_struct_dnssec_name_swigregister = _ldns.ldns_struct_dnssec_name_swigregister
ldns_struct_dnssec_name_swigregister(ldns_struct_dnssec_name)

class ldns_struct_dnssec_zone(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_struct_dnssec_zone, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_struct_dnssec_zone, name)
    __repr__ = _swig_repr
    __swig_setmethods__["soa"] = _ldns.ldns_struct_dnssec_zone_soa_set
    __swig_getmethods__["soa"] = _ldns.ldns_struct_dnssec_zone_soa_get
    if _newclass:
        soa = _swig_property(_ldns.ldns_struct_dnssec_zone_soa_get, _ldns.ldns_struct_dnssec_zone_soa_set)
    __swig_setmethods__["names"] = _ldns.ldns_struct_dnssec_zone_names_set
    __swig_getmethods__["names"] = _ldns.ldns_struct_dnssec_zone_names_get
    if _newclass:
        names = _swig_property(_ldns.ldns_struct_dnssec_zone_names_get, _ldns.ldns_struct_dnssec_zone_names_set)
    __swig_setmethods__["hashed_names"] = _ldns.ldns_struct_dnssec_zone_hashed_names_set
    __swig_getmethods__["hashed_names"] = _ldns.ldns_struct_dnssec_zone_hashed_names_get
    if _newclass:
        hashed_names = _swig_property(_ldns.ldns_struct_dnssec_zone_hashed_names_get, _ldns.ldns_struct_dnssec_zone_hashed_names_set)
    __swig_setmethods__["_nsec3params"] = _ldns.ldns_struct_dnssec_zone__nsec3params_set
    __swig_getmethods__["_nsec3params"] = _ldns.ldns_struct_dnssec_zone__nsec3params_get
    if _newclass:
        _nsec3params = _swig_property(_ldns.ldns_struct_dnssec_zone__nsec3params_get, _ldns.ldns_struct_dnssec_zone__nsec3params_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_struct_dnssec_zone()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_struct_dnssec_zone
    __del__ = lambda self: None
ldns_struct_dnssec_zone_swigregister = _ldns.ldns_struct_dnssec_zone_swigregister
ldns_struct_dnssec_zone_swigregister(ldns_struct_dnssec_zone)


def ldns_dnssec_rrs_new():
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrs_new()

def ldns_dnssec_rrs_free(rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrs_free(rrs)

def ldns_dnssec_rrs_deep_free(rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrs_deep_free(rrs)

def ldns_dnssec_rrs_add_rr(rrs, rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrs_add_rr(rrs, rr)

def ldns_dnssec_rrs_print(out, rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrs_print(out, rrs)

def ldns_dnssec_rrs_print_fmt(out, fmt, rrs):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrs_print_fmt(out, fmt, rrs)

def ldns_dnssec_rrsets_new():
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_new()

def ldns_dnssec_rrsets_free(rrsets):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_free(rrsets)

def ldns_dnssec_rrsets_deep_free(rrsets):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_deep_free(rrsets)

def ldns_dnssec_rrsets_type(rrsets):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_type(rrsets)

def ldns_dnssec_rrsets_set_type(rrsets, type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_set_type(rrsets, type)

def ldns_dnssec_rrsets_add_rr(rrsets, rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_add_rr(rrsets, rr)

def ldns_dnssec_rrsets_print(out, rrsets, follow):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_print(out, rrsets, follow)

def ldns_dnssec_rrsets_print_fmt(out, fmt, rrsets, follow):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_rrsets_print_fmt(out, fmt, rrsets, follow)

def ldns_dnssec_name_new():
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_new()

def ldns_dnssec_name_new_frm_rr(rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_new_frm_rr(rr)

def ldns_dnssec_name_free(name):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_free(name)

def ldns_dnssec_name_deep_free(name):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_deep_free(name)

def ldns_dnssec_name_name(name):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_name(name)

def ldns_dnssec_name_set_name(name, dname):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_set_name(name, dname)

def ldns_dnssec_name_is_glue(name):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_is_glue(name)

def ldns_dnssec_name_set_nsec(name, nsec):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_set_nsec(name, nsec)

def ldns_dnssec_name_cmp(a, b):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_cmp(a, b)

def ldns_dnssec_name_add_rr(name, rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_add_rr(name, rr)

def ldns_dnssec_name_find_rrset(name, type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_find_rrset(name, type)

def ldns_dnssec_zone_find_rrset(zone, dname, type):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_find_rrset(zone, dname, type)

def ldns_dnssec_name_print(out, name):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_print(out, name)

def ldns_dnssec_name_print_fmt(out, fmt, name):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_name_print_fmt(out, fmt, name)

def ldns_dnssec_zone_new():
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_new()

def ldns_dnssec_zone_new_frm_fp(z, fp, origin, ttl, c):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_new_frm_fp(z, fp, origin, ttl, c)

def ldns_dnssec_zone_new_frm_fp_l(z, fp, origin, ttl, c):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_new_frm_fp_l(z, fp, origin, ttl, c)

def ldns_dnssec_zone_free(zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_free(zone)

def ldns_dnssec_zone_deep_free(zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_deep_free(zone)

def ldns_dnssec_zone_add_rr(zone, rr):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_add_rr(zone, rr)

def ldns_dnssec_zone_names_print(out, tree, print_soa):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_names_print(out, tree, print_soa)

def ldns_dnssec_zone_names_print_fmt(out, fmt, tree, print_soa):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_names_print_fmt(out, fmt, tree, print_soa)

def ldns_dnssec_zone_print(out, zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_print(out, zone)

def ldns_dnssec_zone_print_fmt(out, fmt, zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_print_fmt(out, fmt, zone)

def ldns_dnssec_zone_add_empty_nonterminals(zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_add_empty_nonterminals(zone)

def ldns_dnssec_zone_is_nsec3_optout(zone):
    """LDNS buffer."""
    return _ldns.ldns_dnssec_zone_is_nsec3_optout(zone)
class ldns_rbnode_t(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_rbnode_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_rbnode_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["parent"] = _ldns.ldns_rbnode_t_parent_set
    __swig_getmethods__["parent"] = _ldns.ldns_rbnode_t_parent_get
    if _newclass:
        parent = _swig_property(_ldns.ldns_rbnode_t_parent_get, _ldns.ldns_rbnode_t_parent_set)
    __swig_setmethods__["left"] = _ldns.ldns_rbnode_t_left_set
    __swig_getmethods__["left"] = _ldns.ldns_rbnode_t_left_get
    if _newclass:
        left = _swig_property(_ldns.ldns_rbnode_t_left_get, _ldns.ldns_rbnode_t_left_set)
    __swig_setmethods__["right"] = _ldns.ldns_rbnode_t_right_set
    __swig_getmethods__["right"] = _ldns.ldns_rbnode_t_right_get
    if _newclass:
        right = _swig_property(_ldns.ldns_rbnode_t_right_get, _ldns.ldns_rbnode_t_right_set)
    __swig_setmethods__["key"] = _ldns.ldns_rbnode_t_key_set
    __swig_getmethods__["key"] = _ldns.ldns_rbnode_t_key_get
    if _newclass:
        key = _swig_property(_ldns.ldns_rbnode_t_key_get, _ldns.ldns_rbnode_t_key_set)
    __swig_setmethods__["data"] = _ldns.ldns_rbnode_t_data_set
    __swig_getmethods__["data"] = _ldns.ldns_rbnode_t_data_get
    if _newclass:
        data = _swig_property(_ldns.ldns_rbnode_t_data_get, _ldns.ldns_rbnode_t_data_set)
    __swig_setmethods__["color"] = _ldns.ldns_rbnode_t_color_set
    __swig_getmethods__["color"] = _ldns.ldns_rbnode_t_color_get
    if _newclass:
        color = _swig_property(_ldns.ldns_rbnode_t_color_get, _ldns.ldns_rbnode_t_color_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_rbnode_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_rbnode_t
    __del__ = lambda self: None
ldns_rbnode_t_swigregister = _ldns.ldns_rbnode_t_swigregister
ldns_rbnode_t_swigregister(ldns_rbnode_t)

class ldns_rbtree_t(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_rbtree_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_rbtree_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["root"] = _ldns.ldns_rbtree_t_root_set
    __swig_getmethods__["root"] = _ldns.ldns_rbtree_t_root_get
    if _newclass:
        root = _swig_property(_ldns.ldns_rbtree_t_root_get, _ldns.ldns_rbtree_t_root_set)
    __swig_setmethods__["count"] = _ldns.ldns_rbtree_t_count_set
    __swig_getmethods__["count"] = _ldns.ldns_rbtree_t_count_get
    if _newclass:
        count = _swig_property(_ldns.ldns_rbtree_t_count_get, _ldns.ldns_rbtree_t_count_set)
    __swig_setmethods__["cmp"] = _ldns.ldns_rbtree_t_cmp_set
    __swig_getmethods__["cmp"] = _ldns.ldns_rbtree_t_cmp_get
    if _newclass:
        cmp = _swig_property(_ldns.ldns_rbtree_t_cmp_get, _ldns.ldns_rbtree_t_cmp_set)

    def __init__(self):
        """LDNS buffer."""
        this = _ldns.new_ldns_rbtree_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ldns.delete_ldns_rbtree_t
    __del__ = lambda self: None
ldns_rbtree_t_swigregister = _ldns.ldns_rbtree_t_swigregister
ldns_rbtree_t_swigregister(ldns_rbtree_t)


def ldns_rbtree_create(cmpf):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_create(cmpf)

def ldns_rbtree_free(rbtree):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_free(rbtree)

def ldns_rbtree_init(rbtree, cmpf):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_init(rbtree, cmpf)

def ldns_rbtree_insert(rbtree, data):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_insert(rbtree, data)

def ldns_rbtree_insert_vref(data, rbtree):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_insert_vref(data, rbtree)

def ldns_rbtree_delete(rbtree, key):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_delete(rbtree, key)

def ldns_rbtree_search(rbtree, key):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_search(rbtree, key)

def ldns_rbtree_find_less_equal(rbtree, key, result):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_find_less_equal(rbtree, key, result)

def ldns_rbtree_first(rbtree):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_first(rbtree)

def ldns_rbtree_last(rbtree):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_last(rbtree)

def ldns_rbtree_next(rbtree):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_next(rbtree)

def ldns_rbtree_previous(rbtree):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_previous(rbtree)

def ldns_rbtree_split(tree, elements):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_split(tree, elements)

def ldns_rbtree_join(tree1, tree2):
    """LDNS buffer."""
    return _ldns.ldns_rbtree_join(tree1, tree2)

def ldns_traverse_postorder(tree, func, arg):
    """LDNS buffer."""
    return _ldns.ldns_traverse_postorder(tree, func, arg)

def ldns_dname_cat_clone(rd1, rd2):
    """LDNS buffer."""
    return _ldns.ldns_dname_cat_clone(rd1, rd2)

def ldns_dname_cat(rd1, rd2):
    """LDNS buffer."""
    return _ldns.ldns_dname_cat(rd1, rd2)

def ldns_dname_reverse(d):
    """LDNS buffer."""
    return _ldns.ldns_dname_reverse(d)

def ldns_dname_clone_from(d, n):
    """LDNS buffer."""
    return _ldns.ldns_dname_clone_from(d, n)

def ldns_dname_left_chop(d):
    """LDNS buffer."""
    return _ldns.ldns_dname_left_chop(d)

def ldns_dname_label_count(r):
    """LDNS buffer."""
    return _ldns.ldns_dname_label_count(r)

def ldns_dname_new_frm_str(str):
    """LDNS buffer."""
    return _ldns.ldns_dname_new_frm_str(str)

def ldns_dname_new(s, data):
    """LDNS buffer."""
    return _ldns.ldns_dname_new(s, data)

def ldns_dname_new_frm_data(size, data):
    """LDNS buffer."""
    return _ldns.ldns_dname_new_frm_data(size, data)

def ldns_dname2canonical(rdf):
    """LDNS buffer."""
    return _ldns.ldns_dname2canonical(rdf)

def ldns_dname_is_subdomain(sub, parent):
    """LDNS buffer."""
    return _ldns.ldns_dname_is_subdomain(sub, parent)

def ldns_dname_compare(dname1, dname2):
    """LDNS buffer."""
    return _ldns.ldns_dname_compare(dname1, dname2)

def ldns_dname_compare_v(arg1, arg2):
    """LDNS buffer."""
    return _ldns.ldns_dname_compare_v(arg1, arg2)

def ldns_dname_match_wildcard(dname, wildcard):
    """LDNS buffer."""
    return _ldns.ldns_dname_match_wildcard(dname, wildcard)

def ldns_dname_interval(prev, middle, next):
    """LDNS buffer."""
    return _ldns.ldns_dname_interval(prev, middle, next)

def ldns_dname_str_absolute(dname_str):
    """LDNS buffer."""
    return _ldns.ldns_dname_str_absolute(dname_str)

def ldns_dname_absolute(dname):
    """LDNS buffer."""
    return _ldns.ldns_dname_absolute(dname)

def ldns_dname_label(rdf, labelpos):
    """LDNS buffer."""
    return _ldns.ldns_dname_label(rdf, labelpos)

def ldns_dname_is_wildcard(dname):
    """LDNS buffer."""
    return _ldns.ldns_dname_is_wildcard(dname)
class ldns_dnssec_name(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_dnssec_name, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_dnssec_name, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __init__(self):
        """Create a new instance of dnssec name."""
        self.this = _ldns.ldns_dnssec_name_new()
        if not self.this:
           raise Exception("Can't create dnssec name instance")

    __swig_destroy__ = _ldns.ldns_dnssec_name_free

    def print_to_file(self,file):
        """Prints the RRs in the dnssec name structure to the given file descriptor.

           :param file: file pointer
        """
        _ldns.ldns_dnssec_name_print(file, self)
    #parameters: FILE *,ldns_dnssec_name *,

    @staticmethod
    def new_frm_rr(raiseException=True):
        """Create a new instace of dnssec name for the given RR.

           :returns: (ldns_dnssec_name) instance
        """
        name = _ldns.ldns_dnssec_name_new_frm_rr(self)
        if (not name) and (raiseException): 
           raise Exception("Can't create dnssec name")
        return name

    #LDNS_DNSSEC_NAME_METHODS_#
    def add_rr(self,rr):
        """Inserts the given rr at the right place in the current dnssec_name No checking is done whether the name matches.

           :param rr:
               The RR to add
           :returns: (ldns_status) LDNS_STATUS_OK on success, error code otherwise
        """
        return _ldns.ldns_dnssec_name_add_rr(self,rr)
    #parameters: ldns_dnssec_name *,ldns_rr *,
    #retvals: ldns_status

    def find_rrset(self,atype):
        """Find the RRset with the given type in within this name structure.

           :param atype:
           :returns: (ldns_dnssec_rrsets \*) the RRset, or NULL if not present
        """
        return _ldns.ldns_dnssec_name_find_rrset(self,atype)
    #parameters: ldns_dnssec_name *,ldns_rr_type,
    #retvals: ldns_dnssec_rrsets *

    def name(self):
        """Returns the domain name of the given dnssec_name structure.

           :returns: (ldns_rdf \*) the domain name
        """
        return _ldns.ldns_dnssec_name_name(self)
    #parameters: ldns_dnssec_name *,
    #retvals: ldns_rdf *

    def set_name(self,dname):
        """Sets the domain name of the given dnssec_name structure.

           :param dname:
               the domain name to set it to. This data is *not* copied.
        """
        _ldns.ldns_dnssec_name_set_name(self,dname)
    #parameters: ldns_dnssec_name *,ldns_rdf *,
    #retvals: 

    def set_nsec(self,nsec):
        """Sets the NSEC(3) RR of the given dnssec_name structure.

           :param nsec:
               the nsec rr to set it to. This data is *not* copied.
        """
        _ldns.ldns_dnssec_name_set_nsec(self,nsec)
    #parameters: ldns_dnssec_name *,ldns_rr *,
    #retvals: 
    #_LDNS_DNSSEC_NAME_METHODS#

ldns_dnssec_name_swigregister = _ldns.ldns_dnssec_name_swigregister
ldns_dnssec_name_swigregister(ldns_dnssec_name)

class ldns_dnssec_rrs(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_dnssec_rrs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_dnssec_rrs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr


    def __init__(self):
        """Creates a new entry for 1 pointer to an rr and 1 pointer to the next rrs.

           :returns: (ldns_dnssec_rrs) the allocated data
        """
        self.this = _ldns.ldns_dnssec_rrs_new()
        if not self.this:
            raise Exception("Can't create rrs instance")

    __swig_destroy__ = _ldns.ldns_dnssec_rrs_free

    #LDNS_DNSSEC_RRS_METHODS_#
    def add_rr(self,rr):
        """Adds an RR to the list of RRs.

           The list will remain ordered

           :param rr:
               the RR to add
           :returns: (ldns_status) LDNS_STATUS_OK on success
        """
        return _ldns.ldns_dnssec_rrs_add_rr(self,rr)
    #parameters: ldns_dnssec_rrs *,ldns_rr *,
    #retvals: ldns_status
    #_LDNS_DNSSEC_RRS_METHODS#

ldns_dnssec_rrs_swigregister = _ldns.ldns_dnssec_rrs_swigregister
ldns_dnssec_rrs_swigregister(ldns_dnssec_rrs)

class ldns_dnssec_rrsets(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_dnssec_rrsets, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_dnssec_rrsets, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __init__(self):
        """Creates a new list (entry) of RRsets.

           :returns: (ldns_dnssec_rrsets \*) instance
        """
        self.this = _ldns.ldns_dnssec_rrsets_new()
        if not self.this:
            raise Exception("Can't create rrsets instance")

    __swig_destroy__ = _ldns.ldns_dnssec_rrsets_free

    def print_to_file(self, file, follow):
        """Print the given list of rrsets to the given file descriptor.

           :param file: file pointer
           :param follow: if set to false, only print the first RRset
        """
        _ldns.ldns_dnssec_rrsets_print(file,self,follow)
    #parameters: FILE *,ldns_dnssec_rrsets *,bool,
    #retvals: 

    #LDNS_DNSSEC_RRSETS_METHODS_#
    def add_rr(self,rr):
        """Add an ldns_rr to the corresponding RRset in the given list of RRsets.

           If it is not present, add it as a new RRset with 1 record.

           :param rr:
               the rr to add to the list of rrsets
           :returns: (ldns_status) LDNS_STATUS_OK on success
        """
        return _ldns.ldns_dnssec_rrsets_add_rr(self,rr)
    #parameters: ldns_dnssec_rrsets *,ldns_rr *,
    #retvals: ldns_status

    def set_type(self,atype):
        """Sets the RR type of the rrset (that is head of the given list).

           :param atype:
           :returns: (ldns_status) LDNS_STATUS_OK on success
        """
        return _ldns.ldns_dnssec_rrsets_set_type(self,atype)
    #parameters: ldns_dnssec_rrsets *,ldns_rr_type,
    #retvals: ldns_status

    def type(self):
        """Returns the rr type of the rrset (that is head of the given list).

           :returns: (ldns_rr_type) the rr type
        """
        return _ldns.ldns_dnssec_rrsets_type(self)
    #parameters: ldns_dnssec_rrsets *,
    #retvals: ldns_rr_type
    #_LDNS_DNSSEC_RRSETS_METHODS#

ldns_dnssec_rrsets_swigregister = _ldns.ldns_dnssec_rrsets_swigregister
ldns_dnssec_rrsets_swigregister(ldns_dnssec_rrsets)

class ldns_dnssec_zone(_object):
    """LDNS buffer."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ldns_dnssec_zone, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ldns_dnssec_zone, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr


    def __init__(self):
        """Creates a new dnssec_zone instance"""
        self.this = _ldns.ldns_dnssec_zone_new()
        if not self.this:
           raise Exception("Can't create dnssec zone instance")

    __swig_destroy__ = _ldns.ldns_dnssec_zone_free

    def print_to_file(self,file):
        """Prints the complete zone to the given file descriptor.

           :param file: file pointer
        """
        _ldns.ldns_dnssec_zone_print(file, self)
    #parameters: FILE *, ldns_dnssec_zone *,
    #retvals: 

    def create_nsec3s(self,new_rrs,algorithm,flags,iterations,salt_length,salt):
        """Adds NSEC3 records to the zone.

           :param new_rrs:
           :param algorithm:
           :param flags:
           :param iterations:
           :param salt_length:
           :param salt:
           :returns: (ldns_status) 
        """
        return _ldns.ldns_dnssec_zone_create_nsec3s(self,new_rrs,algorithm,flags,iterations,salt_length,salt)
    #parameters: ldns_dnssec_zone *,ldns_rr_list *,uint8_t,uint8_t,uint16_t,uint8_t,uint8_t *,
    #retvals: ldns_status

    def create_nsecs(self,new_rrs):
        """Adds NSEC records to the given dnssec_zone.

           :param new_rrs:
               ldns_rr's created by this function are added to this rr list, so the caller can free them later
           :returns: (ldns_status) LDNS_STATUS_OK on success, an error code otherwise
        """
        return _ldns.ldns_dnssec_zone_create_nsecs(self,new_rrs)
    #parameters: ldns_dnssec_zone *,ldns_rr_list *,
    #retvals: ldns_status

    def create_rrsigs(self,new_rrs,key_list,func,arg):
        """Adds signatures to the zone.

           :param new_rrs:
               the RRSIG RRs that are created are also added to this list, so the caller can free them later
           :param key_list:
               list of keys to sign with.
           :param func:
               Callback function to decide what keys to use and what to do with old signatures
           :param arg:
               Optional argument for the callback function
           :returns: (ldns_status) LDNS_STATUS_OK on success, error otherwise
        """
        return _ldns.ldns_dnssec_zone_create_rrsigs(self,new_rrs,key_list,func,arg)
    #parameters: ldns_dnssec_zone *,ldns_rr_list *,ldns_key_list *,int(*)(ldns_rr *, void *),void *,
    #retvals: ldns_status

    def sign_cb(self,new_rrs,key_list,func,arg):
        """signs the given zone with the given keys (with callback function)

           :param new_rrs:
               newly created resource records are added to this list, to free them later
           :param key_list:
               the list of keys to sign the zone with
           :param func:
               callback function that decides what to do with old signatures.
               This function takes an ldns_rr and an optional arg argument, and returns one of four values: 

                 * LDNS_SIGNATURE_LEAVE_ADD_NEW - leave the signature and add a new one for the corresponding key 

                 * LDNS_SIGNATURE_REMOVE_ADD_NEW - remove the signature and replace is with a new one from the same key 

                 * LDNS_SIGNATURE_LEAVE_NO_ADD - leave the signature and do not add a new one with the corresponding key 

                 * LDNS_SIGNATURE_REMOVE_NO_ADD - remove the signature and do not replace

           :param arg:
               optional argument for the callback function
           :returns: (ldns_status) LDNS_STATUS_OK on success, an error code otherwise
        """
        return _ldns.ldns_dnssec_zone_sign(self,new_rrs,key_list,func,arg)
    #parameters: ldns_dnssec_zone *,ldns_rr_list *,ldns_key_list *,int(*)(ldns_rr *, void *),void *,
    #retvals: ldns_status

    def sign(self,new_rrs,key_list, cbtype=3):
        """signs the given zone with the given keys

           :param new_rrs:
               newly created resource records are added to this list, to free them later
           :param key_list:
               the list of keys to sign the zone with
           :param cb_type: 
               specifies how to deal with old signatures, possible values:

                 *  0 - ldns_dnssec_default_add_to_signatures, 

                 *  1 - ldns_dnssec_default_leave_signatures,

                 *  2 - ldns_dnssec_default_delete_signatures,

                 *  3 - ldns_dnssec_default_replace_signatures 

           :returns: (ldns_status) LDNS_STATUS_OK on success, an error code otherwise
        """
        return _ldns.ldns_dnssec_zone_sign_defcb(self,new_rrs,key_list, cbtype)
    #parameters: ldns_dnssec_zone *,ldns_rr_list *,ldns_key_list *,
    #retvals: ldns_status

    def sign_nsec3(self,new_rrs,key_list,func,arg,algorithm,flags,iterations,salt_length,salt):
        """signs the given zone with the given new zone, with NSEC3

           :param new_rrs:
               newly created resource records are added to this list, to free them later
           :param key_list:
               the list of keys to sign the zone with
           :param func:
               callback function that decides what to do with old signatures
           :param arg:
               optional argument for the callback function
           :param algorithm:
               the NSEC3 hashing algorithm to use
           :param flags:
               NSEC3 flags
           :param iterations:
               the number of NSEC3 hash iterations to use
           :param salt_length:
               the length (in octets) of the NSEC3 salt
           :param salt:
               the NSEC3 salt data
           :returns: (ldns_status) LDNS_STATUS_OK on success, an error code otherwise
        """
        return _ldns.ldns_dnssec_zone_sign_nsec3(self,new_rrs,key_list,func,arg,algorithm,flags,iterations,salt_length,salt)
    #parameters: ldns_dnssec_zone *,ldns_rr_list *,ldns_key_list *,int(*)(ldns_rr *, void *),void *,uint8_t,uint8_t,uint16_t,uint8_t,uint8_t *,
    #retvals: ldns_status

    #LDNS_DNSSEC_ZONE_METHODS_#
    def add_empty_nonterminals(self):
        """Adds explicit dnssec_name structures for the empty nonterminals in this zone.

           (this is needed for NSEC3 generation)

           :returns: (ldns_status) 
        """
        return _ldns.ldns_dnssec_zone_add_empty_nonterminals(self)
    #parameters: ldns_dnssec_zone *,
    #retvals: ldns_status

    def add_rr(self,rr):
        """Adds the given RR to the zone.

           It find whether there is a dnssec_name with that name present. 
           If so, add it to that, if not create a new one.  
           Special handling of NSEC and RRSIG provided.

           :param rr:
               The RR to add
           :returns: (ldns_status) LDNS_STATUS_OK on success, an error code otherwise
        """
        return _ldns.ldns_dnssec_zone_add_rr_(self,rr)
    #parameters: ldns_dnssec_zone *,ldns_rr *,
    #retvals: ldns_status

    def find_rrset(self,dname,atype):
        """Find the RRset with the given name and type in the zone.

           :param dname:
               the domain name of the RRset to find
           :param atype:
           :returns: (ldns_dnssec_rrsets \*) the RRset, or NULL if not present
        """
        return _ldns.ldns_dnssec_zone_find_rrset(self,dname,atype)
    #parameters: ldns_dnssec_zone *,ldns_rdf *,ldns_rr_type,
    #retvals: ldns_dnssec_rrsets *

    #_LDNS_DNSSEC_ZONE_METHODS#

ldns_dnssec_zone_swigregister = _ldns.ldns_dnssec_zone_swigregister
ldns_dnssec_zone_swigregister(ldns_dnssec_zone)


class ldns_dname(ldns_rdf):
    """
       Domain name.

       This class contains methods to read and manipulate domain name drfs.
       Domain names are stored in :class:`ldns_rdf` structures,
       with the type LDNS_RDF_TYPE_DNAME. This class encapsulates such
       rdfs.

       **Usage** 

           >>> import ldns
           >>> dn1 = ldns.ldns_dname("test.nic.cz")
           >>> print dn1
           test.nic.cz.
           >>> dn2 = ldns.ldns_dname("nic.cz")
           >>> if dn2.is_subdomain(dn1): print dn2, "is sub-domain of", dn1
           >>> if dn1.is_subdomain(dn2): print dn1, "is sub-domain of", dn2
           test.nic.cz. is sub-domain of nic.cz.

       The following two examples show the creation of :class:`ldns_dname`
       from :class:`ldns_rdf`. The first shows the creation of
       :class:`ldns_dname` instance which is independent of the original
       `rdf`.


           >>> import ldns
           >>> rdf = ldns.ldns_rdf.new_frm_str("a.ns.nic.cz", ldns.LDNS_RDF_TYPE_DNAME)
           >>> dn = ldns.ldns_dname(rdf)
           >>> print dn
           a.ns.nic.cz.

       The latter shows the wrapping of a :class:`ldns_rdf` onto
       a :class:`ldns_dname` without the creation of a copy.

           >>> import ldns
           >>> dn = ldns.ldns_dname(ldns.ldns_rdf.new_frm_str("a.ns.nic.cz", ldns.LDNS_RDF_TYPE_DNAME), clone=False)
           >>> print dn
           a.ns.nic.cz.
    """
    def __init__(self, initialiser, clone=True):
        """
           Creates a new dname rdf from a string or :class:`ldns_rdf`.

           :param initialiser: string or :class:`ldns_rdf`
           :type initialiser: string or :class:`ldns_rdf` containing
               a dname
           :param clone: Whether to clone or directly grab the parameter.
           :type clone: bool
           :throws TypeError: When `initialiser` of invalid type.
        """
        if isinstance(initialiser, ldns_rdf) and \
           (initialiser.get_type() == _ldns.LDNS_RDF_TYPE_DNAME):
            if clone == True:
                self.this = _ldns.ldns_rdf_clone(initialiser)
            else:
                self.this = initialiser
        else:
            self.this = _ldns.ldns_dname_new_frm_str(initialiser)

#
# LDNS_DNAME_CONSTRUCTORS_
#

    @staticmethod
    def new_frm_str(string):
        """
           Creates a new dname rdf instance from a string.

           This static method is equivalent to using default
           :class:`ldns_dname` constructor.

           :param string: String to use.
           :type string: string
           :throws TypeError: When `string` not a string.
           :return: (:class:`ldns_dname`) dname rdf.
        """
        return ldns_dname(string)

    @staticmethod
    def new_frm_rdf(rdf, clone=True):
        """
           Creates a new dname rdf instance from a dname :class:`ldns_rdf`.

           This static method is equivalent to using the default
           :class:`ldns_dname` constructor.

           :param rdf: A dname :class:`ldns_rdf`.
           :type rdf: :class:`ldns_rdf`
           :throws TypeError: When `rdf` of inappropriate type.
           :param clone: Whether to create a clone or to wrap present
               instance.
           :type clone: bool
           :return: (:class:`ldns_dname`) dname rdf.
        """
        return ldns_dname(rdf, clone=clone)

#
# _LDNS_DNAME_CONSTRUCTORS
#

    def write_to_buffer(self, buffer):
        """
           Copies the dname data to the buffer in wire format.

           :param buffer: Buffer to append the result to.
           :type param: :class:`ldns_buffer`
           :throws TypeError: When `buffer` of non-:class:`ldns_buffer`
               type.
           :return: (ldns_status) ldns_status
        """
        return _ldns.ldns_dname2buffer_wire(buffer, self)
#parameters: ldns_buffer *, const ldns_rdf *,
#retvals: ldns_status


#
# LDNS_DNAME_METHODS_
#

    def absolute(self):
        """
           Checks whether the given dname string is absolute (i.e.,
           ends with a '.').

           :return: (bool) True or False
        """
        string = self.__str__()
        return _ldns.ldns_dname_str_absolute(string) != 0

    def make_canonical(self):
        """
           Put a dname into canonical format (i.e., convert to lower case).
        """
        _ldns.ldns_dname2canonical(self)

    def __cmp__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (int) -1, 0 or 1 if self comes before other,
               self is equal or self comes after other respectively.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__cmp__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other)

    def __lt__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (bool) True when `self` is less than 'other'.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__lt__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other) == -1

    def __le__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (bool) True when `self` is less than or equal to
               'other'.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__le__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other) != 1

    def __eq__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (bool) True when `self` is equal to 'other'.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__eq__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other) == 0

    def __ne__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (bool) True when `self` is not equal to 'other'.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__ne__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other) != 0

    def __gt__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (bool) True when `self` is greater than 'other'.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__gt__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other) == 1

    def __ge__(self, other):
        """
           Compares two dname rdf according to the algorithm for
           ordering in RFC4034 Section 6.

           :param other: The second dname rdf to compare.
           :type other: :class:`ldns_dname`
           :throws TypeError: When `other` of invalid type.
           :return: (bool) True when `self` is greater than or equal to
               'other'.

           .. note::
               The type checking of parameter `other` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.                   
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(other, ldns_dname)) and \
           isinstance(other, ldns_rdf) and \
           other.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.__ge__() method will" +
                " drop the possibility to compare ldns_rdf." +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        if not isinstance(other, ldns_rdf):
            raise TypeError("Parameter must be derived from ldns_rdf.")
        if (other.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("Operands must be ldns_dname.")
        return _ldns.ldns_dname_compare(self, other) != -1

    def cat(self, rd2):
        """
           Concatenates rd2 after this dname (`rd2` is copied,
           `this` dname is modified).

           :param rd2: The right-hand side.
           :type rd2: :class:`ldns_dname`
           :throws TypeError: When `rd2` of invalid type.
           :return: (ldns_status) LDNS_STATUS_OK on success

           .. note::
               The type checking of parameter `rd2` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(rd2, ldns_dname)) and \
           isinstance(rd2, ldns_rdf) and \
           rd2.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.cat() method will" +
                " drop the support of ldns_rdf."  +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_cat(self, rd2)
#parameters: ldns_rdf *, ldns_rdf *,
#retvals: ldns_status

    def cat_clone(self, rd2):
        """
           Concatenates two dnames together.

           :param rd2: The right-hand side.
           :type rd2: :class:`ldns_dname`
           :throws TypeError: When `rd2` of invalid type.
           :return: (:class:`ldns_dname`) A new rdf with
               left-hand side + right-hand side content None when
               error.

           .. note::
               The type checking of parameter `rd2` is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(rd2, ldns_dname)) and \
           isinstance(rd2, ldns_rdf) and \
           rd2.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.cat_clone() method will" +
                " drop the support of ldns_rdf."  +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        ret = _ldns.ldns_dname_cat_clone(self, rd2)
        if ret != None:
            ret = ldns_dname(ret, clone=False)
        return ret
#parameters: const ldns_rdf *, const ldns_rdf *,
#retvals: ldns_rdf *

    def interval(self, middle, next):
        """
           Check whether `middle` lays in the interval defined by
           `this` and `next` (`this` <= `middle` < `next`).

           This method is useful for nsec checking.

           :param middle: The dname to check.
           :type middle: :class:`ldns_dname`
           :param next: The boundary.
           :type next: :class:`ldns_dname`
           :throws TypeError: When `middle` or `next` of
               non-:class:`ldns_rdf` type.
           :throws Exception: When non-dname rdfs compared.
           :return: (int) 0 on error or unknown,
               -1 when middle is in the interval, 1 when not.

           .. note::
               The type checking of parameters is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
#
# The wrapped function generates asserts instead of setting
# error status. They cannot be caught from Python so a check
# is necessary. 
#
        if (not isinstance(middle, ldns_rdf)) or \
           (not isinstance(next, ldns_rdf)):
            raise TypeError("Parameters must be derived from ldns_dname.")
        if (self.get_type() != _ldns.LDNS_RDF_TYPE_DNAME) or \
           (middle.get_type() != _ldns.LDNS_RDF_TYPE_DNAME) or \
           (next.get_type() != _ldns.LDNS_RDF_TYPE_DNAME):
            raise Exception("All operands must be dname rdfs.")
        if (not isinstance(middle, ldns_dname)) or \
           (not isinstance(next, ldns_dname)):
            warnings.warn("The ldns_dname.interval() method will" +
                " drop the possibility to compare ldns_rdf."  +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_interval(self, middle, next)
#parameters: const ldns_rdf *, const ldns_rdf *, const ldns_rdf *,
#retvals: int

    def is_subdomain(self, parent):
        """
           Tests whether the name of the instance falls under
           `parent` (i.e., is a sub-domain of `parent`). 

           This function will return false if the given dnames are equal.

           :param parent: The parent's name.
           :type parent: :class:`ldns_dname`
           :throws TypeError: When `parent` of non-:class:`ldns_rdf`
               or derived type.
           :return: (bool) True if `this` falls under `parent`, otherwise
               False.

           .. note::
               The type checking of parameters is benevolent.
               It allows also to pass a dname :class:`ldns_rdf` object.
               This will probably change in future.
        """
        if (not isinstance(parent, ldns_dname)) and \
           isinstance(parent, ldns_rdf) and \
           parent.get_type() == _ldns.LDNS_RDF_TYPE_DNAME:
            warnings.warn("The ldns_dname.is_subdomain() method will" +
                " drop the support of ldns_rdf."  +
                " Convert arguments to ldns_dname.",
                PendingDeprecationWarning, stacklevel=2)
        return _ldns.ldns_dname_is_subdomain(self, parent)
#parameters: const ldns_rdf *, const ldns_rdf *,
#retvals: bool

    def label(self, labelpos):
        """
           Look inside the rdf and retrieve a specific label.

           The labels are numbered starting from 0 (left most).

           :param labelpos: Index of the label. (Labels are numbered
               0, which is the left most.)
           :type labelpos: integer
           :throws TypeError: When `labelpos` of non-integer type.
           :return: (:class:`ldns_dname`) A new rdf with the label
               as name or None on error.
        """
        ret = _ldns.ldns_dname_label(self, labelpos)
        if ret != None:
            ret = ldns_dname(ret, clone=False)
        return ret
#parameters: const ldns_rdf *, uint8_t,
#retvals: ldns_rdf *

    def label_count(self):
        """
           Counts the number of labels.

           :return: (uint8_t) the number of labels. Will return 0
               if not a dname.
        """
        return _ldns.ldns_dname_label_count(self)
#parameters: const ldns_rdf *,
#retvals: uint8_t

    def left_chop(self):
        """
           Chop one label off the left side of a dname.

           (e.g., wwww.nlnetlabs.nl, becomes nlnetlabs.nl)

           :return: (:class:`ldns_dname`) The remaining dname or None
               when error.
        """
        return ldns_dname(_ldns.ldns_dname_left_chop(self), clone=False)
#parameters: const ldns_rdf *,
#retvals: ldns_rdf *

    def reverse(self):
        """
           Returns a clone of the given dname with the labels reversed.

           :return: (:class:`ldns_dname`) A clone of the dname with
               the labels reversed.
        """
        return ldns_dname(_ldns.ldns_dname_reverse(self), clone=False)
#parameters: const ldns_rdf *,
#retvals: ldns_rdf *

#
# _LDNS_DNAME_METHODS
#


def ldns_rr_new_frm_str_(str, default_ttl, origin, prev):
    """LDNS buffer."""
    return _ldns.ldns_rr_new_frm_str_(str, default_ttl, origin, prev)

def ldns_rr_new_frm_fp_(fp, default_ttl, origin, prev):
    """LDNS buffer."""
    return _ldns.ldns_rr_new_frm_fp_(fp, default_ttl, origin, prev)

def ldns_rr_new_frm_fp_l_(fp, default_ttl, origin, prev):
    """LDNS buffer."""
    return _ldns.ldns_rr_new_frm_fp_l_(fp, default_ttl, origin, prev)

def ldns_rr_new_question_frm_str_(str, origin, prev):
    """LDNS buffer."""
    return _ldns.ldns_rr_new_question_frm_str_(str, origin, prev)

def ldns_fetch_valid_domain_keys_(res, domain, keys):
    """LDNS buffer."""
    return _ldns.ldns_fetch_valid_domain_keys_(res, domain, keys)

def ldns_wire2pkt_(str):
    """LDNS buffer."""
    return _ldns.ldns_wire2pkt_(str)

def ldns_fetch_valid_domain_keys(res, domain, keys):
    return _ldns.ldns_fetch_valid_domain_keys_(res, domain, keys)

def ldns_wire2pkt(data):
    return _ldns.ldns_wire2pkt_(data)

def ldns_rr_iter_frm_fp_l(input_file):
    """Creates an iterator (generator) that returns individual parsed
    RRs from an open zone file."""
# variables that preserve the parsers state
    my_ttl = 0;
    my_origin = None
    my_prev = None
# additional state variables
    last_pos = 0
    line_nr = 0

    while True:
        ret = _ldns.ldns_rr_new_frm_fp_l_(input_file, my_ttl, my_origin, my_prev)
        s, rr, line_inc, new_ttl, new_origin, new_prev = ret  # unpack the result
        line_nr += line_inc # increase number of parsed lines
        my_prev = new_prev  # update ref to previous owner

        if s == _ldns.LDNS_STATUS_SYNTAX_TTL:
            my_ttl = new_ttl  # update default TTL
        elif s == _ldns.LDNS_STATUS_SYNTAX_ORIGIN:
            my_origin = new_origin  # update reference to origin
        elif s == _ldns.LDNS_STATUS_SYNTAX_EMPTY:
            if last_pos == input_file.tell():
                break  # no advance since last read - EOF
            last_pos = input_file.tell()
        elif s != _ldns.LDNS_STATUS_OK:
            raise ValueError("Parse error in line %d" % line_nr)
        else:
# we are sure to have LDNS_STATUS_OK
            yield rr


# This file is compatible with both classic and new-style classes.


