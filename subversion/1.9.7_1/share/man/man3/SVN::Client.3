.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "native::Client 3"
.TH native::Client 3 "2015-01-01" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SVN::Client \- Subversion client functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use SVN::Client;
\&    my $client = new SVN::Client();
\&
\&    # setup to handle authentication the same as the command line client
\&    my $config_dir = undef; # use default location
\&    my $config = SVN:Core::config_get_config($config_dir);
\&    my $config_category = $cfg\->{SVN::Core::CONFIG_CATEGORY_CONFIG};
\&    $client\->auth(
\&      SVN::Core::cmdline_create_auth_baton(0,           #non_interactive
\&                                           undef,       #username
\&                                           undef,       #password
\&                                           $config_dir,
\&                                           0,           #no_auth_cache
\&                                           0,           #trust_server_cert
\&                                           $config_category,
\&                                           undef)       #cancel_callback
\&    );
\&
\&    # Use first argument as target and canonicalize it before using
\&    my $target;
\&    if (SVN::Core::path_is_url($ARGV[0])) {
\&      $target = SVN::Core::uri_canonicalize($ARGV[0]);
\&    } else {
\&      $target = SVN::Core::dirent_canonicalize($ARGV[0]);
\&    }
\&
\&    # fetch the head revision of the target
\&    $client\->cat(\e*STDOUT, $target, \*(AqHEAD\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SVN::Client wraps the highest level of functions provided by
subversion to accomplish specific tasks in an object oriented \s-1API.\s0
Methods are similar to the functions provided by the C \s-1API\s0 and
as such the documentation for it may be helpful in understanding
this interface.
.PP
There are a few notable differences from the C \s-1API.\s0  Most C function
calls take a svn_client_ctx_t pointer as the next to last parameter.
The Perl method calls take a SVN::Client object as the first parameter.
This allows method call invocation of the methods to be possible.  For
example, the following are equivalent:
.PP
.Vb 2
\&  SVN::Client::add($client,$path, $recursive, $pool);
\&  $client\->add($path, $recursive, $pool);
.Ve
.PP
Many of the C \s-1API\s0 calls also take a apr_pool_t pointer as their last
argument.  The Perl bindings generally deal with this for you and
you do not need to pass a pool parameter.  However, you may still
pass a pool parameter as the last parameter to override the automatic
handling of this for you.
.PP
Users of this interface should not directly manipulate the underlying hash
values but should use the respective attribute methods.  Many of these
attribute methods do other things, especially when setting an attribute,
besides simply manipulating the value in the hash.
.SH "PARAMETER NOTES"
.IX Header "PARAMETER NOTES"
The client methods described below take a variety of parameters.  Many of
them are similar.  Methods accepting parameters named below will follow
the rules below or will be noted otherwise in the method description.
.ie n .IP "$client" 4
.el .IP "\f(CW$client\fR" 4
.IX Item "$client"
An SVN::Client object that you get from the constructor.
.ie n .IP "$url" 4
.el .IP "\f(CW$url\fR" 4
.IX Item "$url"
This is a \s-1URL\s0 to a subversion repository.
.ie n .IP "$path" 4
.el .IP "\f(CW$path\fR" 4
.IX Item "$path"
This is a path to a file or directory on the local file system.  Paths need
to be canonicalized before being passed into the Subversion APIs.  Paths on
the local file system are called dirents and can be canonicalized by calling
\&\f(CW\*(C`SVN::Core::dirent_canonicalize\*(C'\fR.
.ie n .IP "$paths" 4
.el .IP "\f(CW$paths\fR" 4
.IX Item "$paths"
This argument can either be a single \f(CW$path\fR (as defined above) or a reference
to an array of them.
.ie n .IP "$target" 4
.el .IP "\f(CW$target\fR" 4
.IX Item "$target"
This is a path to a file or directory in a working copy or a \s-1URL\s0 to a file or
directory in a subversion repository.  Both paths and URLs need to be
canonicalized before being passed into the Subversion APIs.  Paths on the local
file system are called dirents and can be canonicalized by calling 
\&\f(CW\*(C`SVN::Core::dirent_canonicalize\*(C'\fR.  URLs can be canonicalized by calling
\&\f(CW\*(C`SVN::Core::uri_canonicalize\*(C'\fR.
.ie n .IP "$targets" 4
.el .IP "\f(CW$targets\fR" 4
.IX Item "$targets"
This argument can either be a single \f(CW$target\fR (as defined above) or a reference
to an array of them.
.ie n .IP "$revision" 4
.el .IP "\f(CW$revision\fR" 4
.IX Item "$revision"
This specifies a revision in the Subversion repository.  You can specify a
revision in several ways.  The easiest and most obvious is to directly
provide the revision number.  You may also use the strings (aka revision
keywords) '\s-1HEAD\s0', '\s-1BASE\s0', '\s-1COMMITTED\s0', and '\s-1PREV\s0' which have the same
meanings as in the command line client.  When referencing a working copy
you can use the string '\s-1WORKING"\s0 to reference the \s-1BASE\s0 plus any local
modifications.  \f(CW\*(C`undef\*(C'\fR may be used to specify an unspecified revision.
You may also pass a date by specifying the date inside curly braces
\&'{}'.  The date formats accepted are the same as the command line client
accepts. Finally a \f(CW\*(C`_p_svn_opt_revision_t\*(C'\fR object is accepted
(which may have been returned by some Subversion function).
.ie n .IP "$recursive $nonrecursive." 4
.el .IP "\f(CW$recursive\fR \f(CW$nonrecursive\fR." 4
.IX Item "$recursive $nonrecursive."
A boolean parameter that specifies if the action should follow directories.  It
should only be 1 or 0.  \f(CW$recursive\fR means, 1 means to descend into directories,
0 means not to.  \f(CW$nonrecursive\fR has the inverse meaning.
.ie n .IP "$pool" 4
.el .IP "\f(CW$pool\fR" 4
.IX Item "$pool"
Pool is always an option parameter.  If you wish to pass a pool parameter it
should be a SVN::Pool or an apr_pool_t object.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.ie n .IP "$client = SVN::Client\->new( %options );" 4
.el .IP "\f(CW$client\fR = SVN::Client\->new( \f(CW%options\fR );" 4
.IX Item "$client = SVN::Client->new( %options );"
This class method constructs a new \f(CW\*(C`SVN::Client\*(C'\fR object and returns
a reference to it.
.Sp
Key/value pair arguments may be provided to set up the initial state
of the user agent.  The following methods correspond to attribute
methods described below:
.Sp
.Vb 5
\&    KEY                    DEFAULT
\&    \-\-\-\-\-\-\-\-\-\-             \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    auth                   auth_baton initiated with providers that
\&                           read cached authentication options from
\&                           the subversion config only.
\&
\&    cancel                 undef
\&
\&    config                 Hash containing the config from the
\&                           default subversion config file location.
\&
\&    log_msg                undef
\&
\&    notify                 undef
\&
\&    pool                   A new pool is created for the context.
.Ve
.ie n .IP "$client\->add($path, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->add($path, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->add($path, $recursive, $pool);"
Similar to \f(CW$client\fR\->\fIadd2()\fR, but with \f(CW$force\fR always set to \s-1FALSE.\s0
.ie n .IP "$client\->add2($path, $recursive, $force, $pool);" 4
.el .IP "\f(CW$client\fR\->add2($path, \f(CW$recursive\fR, \f(CW$force\fR, \f(CW$pool\fR);" 4
.IX Item "$client->add2($path, $recursive, $force, $pool);"
Similar to \f(CW$client\fR\->\fIadd3()\fR, but with \f(CW$no_ignore\fR always set to \s-1FALSE.\s0
.ie n .IP "$client\->add3($path, $recursive, $force, $no_ignore, $pool);" 4
.el .IP "\f(CW$client\fR\->add3($path, \f(CW$recursive\fR, \f(CW$force\fR, \f(CW$no_ignore\fR, \f(CW$pool\fR);" 4
.IX Item "$client->add3($path, $recursive, $force, $no_ignore, $pool);"
Similar to \f(CW$client\fR\->\fIadd4()\fR, but with \f(CW$add_parents\fR always set to \s-1FALSE\s0 and
\&\f(CW$depth\fR set according to \f(CW$recursive\fR; if \s-1TRUE,\s0 then depth is
\&\f(CW$SVN::Depth::infinity\fR, if \s-1FALSE,\s0 then \f(CW$SVN::Depth::empty\fR.
.ie n .IP "$client\->add4($path, $depth, $force, $no_ignore, $add_parents, $pool);" 4
.el .IP "\f(CW$client\fR\->add4($path, \f(CW$depth\fR, \f(CW$force\fR, \f(CW$no_ignore\fR, \f(CW$add_parents\fR, \f(CW$pool\fR);" 4
.IX Item "$client->add4($path, $depth, $force, $no_ignore, $add_parents, $pool);"
Schedule a working copy \f(CW$path\fR for addition to the repository.
.Sp
If \f(CW$depth\fR is \f(CW$SVN::Depth::empty\fR, add just \f(CW$path\fR and nothing below it.  If
\&\f(CW$SVN::Depth::files\fR, add \f(CW$path\fR and any file children of \f(CW$path\fR.  If 
\&\f(CW$SVN::Depth::immediates\fR, add \f(CW$path\fR, any file children, and any immediate
subdirectories (but nothing underneath those subdirectories).  If 
\&\f(CW$SVN::Depth::infinity\fR, add \f(CW$path\fR and everything under it fully recursively.
.Sp
\&\f(CW$path\fR's parent must be under revision control already (unless \f(CW$add_parents\fR is
\&\s-1TRUE\s0), but \f(CW$path\fR is not.
.Sp
Unless \f(CW$force\fR is \s-1TRUE\s0 and \f(CW$path\fR is already under version control, returns an
\&\f(CW$SVN::Error::ENTRY_EXISTS\fR object.  If \f(CW$force\fR is set, do not error on
already-versioned items.  When used with \f(CW$depth\fR set to \f(CW$SVN::Depth::infinity\fR
it will enter versioned directories; scheduling unversioned children.
.Sp
Calls the notify callback for each added item.
.Sp
If \f(CW$no_ignore\fR is \s-1FALSE,\s0 don't add any file or directory (or recurse into any
directory) that is unversioned and found by recursion (as opposed to being the
explicit target \f(CW$path\fR) and whose name matches the svn:ignore property on its
parent directory or the global-ignores list in \f(CW$client\fR\->config.  If \f(CW$no_ignore\fR is
\&\s-1TRUE,\s0 do include such files and directories.  (Note that an svn:ignore property
can influence this behaviour only when recursing into an already versioned
directory with \f(CW$force\fR).
.Sp
If \f(CW$add_parents\fR is \s-1TRUE,\s0 recurse up \f(CW$path\fR's directory and look for a versioned
directory.  If found, add all intermediate paths between it and \f(CW$path\fR.  If not
found return \f(CW$SVN::Error::NO_VERSIONED_PARENT\fR.
.Sp
Important: this is a \fBscheduling\fR operation.  No changes will happen
to the repository until a commit occurs.  This scheduling can be
removed with \f(CW$client\fR\->\fIrevert()\fR.
.Sp
No return.
.ie n .IP "$client\->blame($target, $start, $end, \e&receiver, $pool);" 4
.el .IP "\f(CW$client\fR\->blame($target, \f(CW$start\fR, \f(CW$end\fR, \e&receiver, \f(CW$pool\fR);" 4
.IX Item "$client->blame($target, $start, $end, &receiver, $pool);"
Invoke \e&receiver subroutine on each line-blame item associated with revision
\&\f(CW$end\fR of \f(CW$target\fR, using \f(CW$start\fR as the default source of all blame.
.Sp
An Error will be raised if either \f(CW$start\fR or \f(CW$end\fR is undef.
.Sp
No return.
.Sp
The blame receiver subroutine receives the following arguments:
\&\f(CW$line_no\fR, \f(CW$revision\fR, \f(CW$author\fR, \f(CW$date\fR, \f(CW$line\fR, \f(CW$pool\fR
.Sp
\&\f(CW$line_no\fR is the line number of the file (starting with 0).
The line was last changed in revision number \f(CW$revision\fR
by \f(CW$author\fR on \f(CW$date\fR and the contents were \f(CW$line\fR.
.Sp
The blame receiver subroutine can return an svn_error_t object
to return an error.  All other returns will be ignored.
You can create an svn_error_t object with \fISVN::Error::create()\fR.
.ie n .IP "$client\->cat(\e*FILEHANDLE, $target, $revision, $pool);" 4
.el .IP "\f(CW$client\fR\->cat(\e*FILEHANDLE, \f(CW$target\fR, \f(CW$revision\fR, \f(CW$pool\fR);" 4
.IX Item "$client->cat(*FILEHANDLE, $target, $revision, $pool);"
Outputs the content of the file identified by \f(CW$target\fR and \f(CW$revision\fR to the
\&\s-1FILEHANDLE.\s0  \s-1FILEHANDLE\s0 is a reference to a filehandle.
.Sp
If \f(CW$target\fR is not a local path and if \f(CW$revision\fR is '\s-1PREV\s0' (or some
other kind that requires a local path), then an error will be raised,
because the desired revision can not be determined.
.ie n .IP "$client\->checkout($url, $path, $revision, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->checkout($url, \f(CW$path\fR, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->checkout($url, $path, $revision, $recursive, $pool);"
Similar to \f(CW$client\fR\->\fIcheckout2()\fR, but with \f(CW$peg_revision\fR always set to undef (unspecified) and \f(CW$ignore_externals\fR always set to \s-1FALSE.\s0
.ie n .IP "$client\->checkout2($url, $path, $peg_revision, $revision, $recursive, $ignore_externals, $pool);" 4
.el .IP "\f(CW$client\fR\->checkout2($url, \f(CW$path\fR, \f(CW$peg_revision\fR, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$ignore_externals\fR, \f(CW$pool\fR);" 4
.IX Item "$client->checkout2($url, $path, $peg_revision, $revision, $recursive, $ignore_externals, $pool);"
Similar to \f(CW$client\fR\->\fIcheckout3()\fR, but with \f(CW$allow_unver_obstructions\fR always set
to \s-1FALSE,\s0 and \f(CW$depth\fR set according to \f(CW$recurse:\fR if \f(CW$recurse\fR is \s-1TRUE,\s0 \f(CW$depth\fR is
\&\f(CW$SVN::Depth::infinity\fR, if \f(CW$recurse\fR is \s-1FALSE,\s0 set \f(CW$depth\fR to \f(CW$SVN::Depth::files\fR.
.ie n .IP "$client\->checkout3($url, $path, $preg_revision, $revision, $depth, $ignore_externals, $allow_unver_obstructions, $pool);" 4
.el .IP "\f(CW$client\fR\->checkout3($url, \f(CW$path\fR, \f(CW$preg_revision\fR, \f(CW$revision\fR, \f(CW$depth\fR, \f(CW$ignore_externals\fR, \f(CW$allow_unver_obstructions\fR, \f(CW$pool\fR);" 4
.IX Item "$client->checkout3($url, $path, $preg_revision, $revision, $depth, $ignore_externals, $allow_unver_obstructions, $pool);"
Checkout a working copy of \f(CW$url\fR at \f(CW$revision\fR using \f(CW$path\fR as the root directory
of the newly checked out working copy.
.Sp
The \f(CW$peg_revision\fR sets the revision at which the path in the \f(CW$url\fR is treated as representing.
.Sp
\&\f(CW$revision\fR must be a number, '\s-1HEAD\s0', or a date.  If \f(CW$revision\fR does not
meet these requirements the \f(CW$SVN::Error::CLIENT_BAD_REVISION\fR is raised.
.Sp
\&\f(CW$depth\fR is one of the constants in SVN::Depth and specifies the depth of the
operation.  If set to \f(CW$SVN::Depth::unknown\fR, then behave as if for
\&\f(CW$SVN::Depth::infinity\fR, except in the case of resuming a previous checkout of
\&\f(CW$path\fR (i.e. updating) in which case use the depth of the existing working copy.
.Sp
\&\f(CW$ignore_exteranls\fR if set to \s-1TRUE\s0 the operation will ignore external definitions.
.Sp
\&\f(CW$allow_unver_obstructions\fR if set to \s-1TRUE\s0 the operation will tolerate existing
unversioned items that obstruct incoming paths.  Only obstructions of the same
type (file or dir) as the added item are tolerated.  The text of obstructing
files is left as-is, effectively treating it as a user modification after the
checkout.  Working properties of obstructing items are set equal to the base
properties.  If set to \s-1FALSE,\s0 then abort if there are any unversioned
obstructing items.
.Sp
Returns the value of the revision actually checked out of the repository.
.ie n .IP "$client\->cleanup($dir, $pool);" 4
.el .IP "\f(CW$client\fR\->cleanup($dir, \f(CW$pool\fR);" 4
.IX Item "$client->cleanup($dir, $pool);"
Recursively cleanup a working copy directory, \f(CW$dir\fR, finishing any incomplete
operations, removing lockfiles, etc.
.ie n .IP "$client\->commit($targets, $nonrecursive, $pool);" 4
.el .IP "\f(CW$client\fR\->commit($targets, \f(CW$nonrecursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->commit($targets, $nonrecursive, $pool);"
Commit files or directories referenced by target.  Will use the log_msg
callback to obtain the log message for the commit.
.Sp
If \f(CW$targets\fR contains no paths (zero elements), then does nothing and
immediately returns without error.
.Sp
Calls the notify callback as the commit progresses with any of the following
actions: \f(CW$SVN::Wc::Notify::Action::commit_modified\fR,
\&\f(CW$SVN::Wc::Notify::Action::commit_added\fR,
\&\f(CW$SVN::Wc::Notify::Action::commit_deleted\fR,
\&\f(CW$SVN::Wc::Notify::Action::commit_replaced\fR,
\&\f(CW$SVN::Wc::Notify::Action::commit_postfix_txdelta\fR.
.Sp
Use \f(CW$nonrecursive\fR to indicate that subdirectories of directory targets
should be ignored.
.Sp
Returns a svn_client_commit_info_t object.  If the revision member of the
commit information object is \f(CW$SVN::Core::INVALID_REVNUM\fR and no error was
raised, then the commit was a no-op; nothing needed to be committed.
.ie n .IP "$client\->copy($src_target, $src_revision, $dst_target, $pool);" 4
.el .IP "\f(CW$client\fR\->copy($src_target, \f(CW$src_revision\fR, \f(CW$dst_target\fR, \f(CW$pool\fR);" 4
.IX Item "$client->copy($src_target, $src_revision, $dst_target, $pool);"
Copies \f(CW$src_target\fR to \f(CW$dst_target\fR.
.Sp
\&\f(CW$src_target\fR must be a file or directory under version control, or the \s-1URL\s0
of a versioned item in the repository.  If \f(CW$src_target\fR is a \s-1URL,\s0
\&\f(CW$src_revision\fR is used to choose the revision from which to copy the
\&\f(CW$src_target\fR.  \f(CW$dst_path\fR must be a file or directory under version control,
or a repository \s-1URL,\s0 existing or not.
.Sp
If \f(CW$dst_target\fR is a \s-1URL,\s0 immediately attempt to commit the copy action
to the repository.  The log_msg callback will be called to query for a commit
log message.  If the commit succeeds, return a svn_client_commit_info_t
object.
.Sp
If \f(CW$dst_target\fR is not a \s-1URL,\s0 then this is just a variant of \f(CW$client\fR\->\fIadd()\fR,
where the \f(CW$dst_path\fR items are scheduled for addition as copies.  No changes
will happen to the repository until a commit occurs.  This scheduling can be
removed with \f(CW$client\fR\->\fIrevert()\fR.  undef will be returned in this case.
.Sp
Calls the notify callback for each item added at the new location, passing
the new, relative path of the added item.
.ie n .IP "$client\->delete($targets, $force, $pool);" 4
.el .IP "\f(CW$client\fR\->delete($targets, \f(CW$force\fR, \f(CW$pool\fR);" 4
.IX Item "$client->delete($targets, $force, $pool);"
Delete items from a repository or working copy.
.Sp
If the paths in \f(CW$targets\fR are URLs, immediately attempt to commit a deletion
of the URLs from the repository.  The log_msg callback will be called to
query for a commit log message.  If the commit succeeds, return a
svn_client_commit_info_t object.  Every path must belong to the same
repository.
.Sp
Else, schedule the working copy paths in \f(CW$targets\fR for removal from the
repository.  Each path's parent must be under revision control.  This is
just a \fBscheduling\fR operation.  No changes will happen to the repository
until a commit occurs.  This scheduling can be removed with \f(CW$client\fR\->\fIrevert()\fR.
If a path is a file it is immediately removed from the working copy.  If
the path is a directory it will remain in the working copy but all the files,
and all unversioned items it contains will be removed.  If \f(CW$force\fR is not set
then this operation will fail if any path contains locally modified and/or
unversioned items.  If \f(CW$force\fR is set such items will be deleted.
.Sp
The notify callback is called for each item deleted with the path of
the deleted item.
.Sp
Has no return.
.ie n .IP "$client\->diff($diff_options, $target1, $revision1, $target2, $revision2, $recursive, $ignore_ancestry, $no_diff_deleted, $outfile, $errfile, $pool);" 4
.el .IP "\f(CW$client\fR\->diff($diff_options, \f(CW$target1\fR, \f(CW$revision1\fR, \f(CW$target2\fR, \f(CW$revision2\fR, \f(CW$recursive\fR, \f(CW$ignore_ancestry\fR, \f(CW$no_diff_deleted\fR, \f(CW$outfile\fR, \f(CW$errfile\fR, \f(CW$pool\fR);" 4
.IX Item "$client->diff($diff_options, $target1, $revision1, $target2, $revision2, $recursive, $ignore_ancestry, $no_diff_deleted, $outfile, $errfile, $pool);"
Produces diff output which describes the delta between \f(CW$target1\fR at
\&\f(CW$revision1\fR and \f(CW$target2\fR at \f(CW$revision2\fR.  They both must represent the same
node type (i.e. they most both be directories or files).  The revisions
must not be undef.
.Sp
Prints the output of the diff to the filename or filehandle passed as
\&\f(CW$outfile\fR, and any errors to the filename or filehandle passed as \f(CW$errfile\fR.
.Sp
Use \f(CW$ignore_ancestry\fR to control whether or not items being diffed will be
checked for relatedness first.  Unrelated items are typically transmitted to
the editor as a deletion of one thing and the addition of another, but if this
flag is true, unrelated items will be diffed as if they were related.
.Sp
If \f(CW$no_diff_deleted\fR is true, then no diff output will be generated on deleted
files.
.Sp
\&\f(CW$diff_options\fR is a reference to an array of additional arguments to pass to
diff process invoked to compare files.  You'll usually just want to use [] to
pass an empty array to return a unified context diff (like `diff \-u`).
.Sp
Has no return.
.ie n .IP "$client\->diff_summarize($target1, $revision1, $target2, $revision2, $recursive, $ignore_ancestry, \e&summarize_func, $pool);" 4
.el .IP "\f(CW$client\fR\->diff_summarize($target1, \f(CW$revision1\fR, \f(CW$target2\fR, \f(CW$revision2\fR, \f(CW$recursive\fR, \f(CW$ignore_ancestry\fR, \e&summarize_func, \f(CW$pool\fR);" 4
.IX Item "$client->diff_summarize($target1, $revision1, $target2, $revision2, $recursive, $ignore_ancestry, &summarize_func, $pool);"
Produce a diff summary which lists the changed items between \f(CW$target1\fR
at \f(CW$revision1\fR and \f(CW$target2\fR at \f(CW$revision2\fR without creating text deltas.
\&\f(CW$target1\fR and \f(CW$target2\fR can be either working-copy paths or URLs.
.Sp
The function may report false positives if \f(CW$ignore_ancestry\fR is false,
since a file might have been modified between two revisions, but still
have the same contents.
.Sp
Calls \e&summarize_func with with a svn_client_diff_summarize_t structure
describing the difference.
.Sp
See \fIdiff()\fR for a description of the other parameters.
.Sp
Has no return.
.ie n .IP "$client\->export($from, $to, $revision, $force, $pool);" 4
.el .IP "\f(CW$client\fR\->export($from, \f(CW$to\fR, \f(CW$revision\fR, \f(CW$force\fR, \f(CW$pool\fR);" 4
.IX Item "$client->export($from, $to, $revision, $force, $pool);"
Export the contents of either a subversion repository or a subversion
working copy into a 'clean' directory (meaning a directory with no
administrative directories).
.Sp
\&\f(CW$from\fR is either the path to the working copy on disk, or a \s-1URL\s0
to the repository you wish to export.
.Sp
\&\f(CW$to\fR is the path to the directory where you wish to create the exported
tree.
.Sp
\&\f(CW$revision\fR is the revision that should be exported, which is only used
when exporting from a repository.  It may be undef otherwise.
.Sp
The notify callback will be called for the items exported.
.Sp
Returns the value of the revision actually exported or
\&\f(CW$SVN::Core::INVALID_REVNUM\fR for local exports.
.ie n .IP "$client\->import($path, $url, $nonrecursive, $pool);" 4
.el .IP "\f(CW$client\fR\->import($path, \f(CW$url\fR, \f(CW$nonrecursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->import($path, $url, $nonrecursive, $pool);"
Import file or directory \f(CW$path\fR into repository directory \f(CW$url\fR at head.
.Sp
If some components of \f(CW$url\fR do not exist then create parent directories
as necessary.
.Sp
If \f(CW$path\fR is a directory, the contents of that directory are imported
directly into the directory identified by \f(CW$url\fR.  Note that the directory
\&\f(CW$path\fR itself is not imported; that is, the basename of \f(CW$path\fR is not part
of the import.
.Sp
If \f(CW$path\fR is a file, then the dirname of \f(CW$url\fR is the directory receiving the
import.  The basename of \f(CW$url\fR is the filename in the repository.  In this case
if \f(CW$url\fR already exists, raise an error.
.Sp
The notify callback (if defined) will be called as the import progresses, with
any of the following actions: \f(CW$SVN::Wc::Notify::Action::commit_added\fR,
\&\f(CW$SVN::Wc::Notify::Action::commit_postfix_txdelta\fR.
.Sp
Use \f(CW$nonrecursive\fR to indicate that imported directories should not recurse
into any subdirectories they may have.
.Sp
Uses the log_msg callback to determine the log message for the commit when
one is needed.
.Sp
Returns a svn_client_commit_info_t object.
.ie n .IP "$client\->info($path_or_url, $peg_revision, $revision, \e&receiver, $recurse);" 4
.el .IP "\f(CW$client\fR\->info($path_or_url, \f(CW$peg_revision\fR, \f(CW$revision\fR, \e&receiver, \f(CW$recurse\fR);" 4
.IX Item "$client->info($path_or_url, $peg_revision, $revision, &receiver, $recurse);"
Invokes \e&receiver passing it information about \f(CW$path_or_url\fR for \f(CW$revision\fR.
The information returned is system-generated metadata, not the sort of
\&\*(L"property\*(R" metadata created by users.  For methods available on the object
passed to \e&receiver, \fBsee svn_info_t\fR.
.Sp
If both revision arguments are either svn_opt_revision_unspecified or \s-1NULL,\s0
then information will be pulled solely from the working copy; no network
connections will be made.
.Sp
Otherwise, information will be pulled from a repository.  The actual node
revision selected is determined by the \f(CW$path_or_url\fR as it exists in
\&\f(CW$peg_revision\fR.  If \f(CW$peg_revision\fR is undef, then it defaults to \s-1HEAD\s0 for URLs
or \s-1WORKING\s0 for \s-1WC\s0 targets.
.Sp
If \f(CW$path_or_url\fR is not a local path, then if \f(CW$revision\fR is \s-1PREV\s0 (or some other
kind that requires a local path), an error will be returned, because the
desired revision cannot be determined.
.Sp
Uses the authentication baton cached in ctx to authenticate against the
repository.
.Sp
If \f(CW$recurse\fR is true (and \f(CW$path_or_url\fR is a directory) this will be a recursive
operation, invoking \f(CW$receiver\fR on each child.
.Sp
.Vb 5
\& my $receiver = sub {
\&     my( $path, $info, $pool ) = @_;
\&     print "Current revision of $path is ", $info\->rev, "\en";
\& };
\& $client\->info( \*(Aqfoo/bar.c\*(Aq, undef, \*(AqWORKING\*(Aq, $receiver, 0 );
.Ve
.ie n .IP "$client\->log5($targets, $peg_revision, $revision_ranges, $limit, $discover_changed_paths, $strict_node_history, $include_merged_revisions, $revprops, \e&log_entry_receiver, $pool);" 4
.el .IP "\f(CW$client\fR\->log5($targets, \f(CW$peg_revision\fR, \f(CW$revision_ranges\fR, \f(CW$limit\fR, \f(CW$discover_changed_paths\fR, \f(CW$strict_node_history\fR, \f(CW$include_merged_revisions\fR, \f(CW$revprops\fR, \e&log_entry_receiver, \f(CW$pool\fR);" 4
.IX Item "$client->log5($targets, $peg_revision, $revision_ranges, $limit, $discover_changed_paths, $strict_node_history, $include_merged_revisions, $revprops, &log_entry_receiver, $pool);"
Invoke \f(CW\*(C`log_entry_receiver\*(C'\fR on each log message from
each revision range in \f(CW$revision_ranges\fR in turn,
inclusive (but never invoke \f(CW\*(C`log_entry_receiver\*(C'\fR on a given log message more
than once).
.Sp
\&\f(CW$targets\fR is a reference to an array of either a \s-1URL\s0 followed by zero 
or more relative paths, or 1 working copy path, for which log
messages are desired. If the array contains only a single element
you may set \f(CW$targets\fR to this element instead.
\&\f(CW\*(C`log_entry_receiver\*(C'\fR is invoked only on messages whose
revisions involved a change to some path in \f(CW$targets\fR.
.Sp
\&\f(CW$peg_revision\fR indicates in which revision \f(CW$targets\fR are valid. 
If \f(CW$peg_revision\fR is \f(CW\*(C`undef\*(C'\fR, it defaults to '\s-1HEAD\s0'
for URLs or '\s-1WORKING\s0' for \s-1WC\s0 paths.
.Sp
\&\f(CW$revision_ranges\fR is either a single \fIrevision range\fR or a reference
to an array of them. A \fIrevision range\fR may be specified
as a reference to a two-element array \f(CW\*(C`[$start, $end]\*(C'\fR
of \f(CW$revision\fRs or a 
SVN::Core::svn_opt_revision_range_t 
object. Examples:
.Sp
.Vb 2
\&  $revision_ranges = [\*(AqHEAD\*(Aq, 1];
\&  $revision_ranges = [[2, 3], [5, 8], [13, 21]];
.Ve
.Sp
If \f(CW$limit\fR is non-zero only invoke \f(CW\*(C`log_entry_receiver\*(C'\fR 
on the first \f(CW$limit\fR logs.
.Sp
If \f(CW$discover_changed_paths\fR is true, then the \fIchanged_paths2\fR field 
in the \f(CW$log_entry\fR argument to \f(CW\*(C`log_entry_receiver\*(C'\fR will be
populated on each invocation.  \fINote:\fR The \fItext_modified\fR and
\&\fIprops_modified\fR fields of the \fIchanged_paths2\fR structure may have the value
\&\f(CW$SVN::Tristate::unknown\fR if the repository does not report that information.
.Sp
If \f(CW$strict_node_history\fR is true, copy history (if any exists) will
not be traversed while harvesting revision logs for each target.
.Sp
If \f(CW$include_merged_revisions\fR is true, log information for revisions
which have been merged to \f(CW$targets\fR will also be returned.
.Sp
If \f(CW$revprops\fR is \f(CW\*(C`undef\*(C'\fR, retrieve all revision properties.
Otherwise \f(CW$revpros\fR should be a reference to an array of
property names and only these properties will be retrieved
(i.e. none if the array is empty).
.Sp
Use \f(CW$pool\fR for any temporary allocation.
.Sp
Calls the notify subroutine with a \f(CW$SVN::Wc::Notify::Action::skip\fR 
signal on any unversioned \f(CW$targets\fR.
.Sp
The \f(CW\*(C`log_entry_receiver\*(C'\fR takes the following arguments:
\&\f(CW\*(C`$log_entry, $pool\*(C'\fR.  \f(CW$log_entry\fR is a 
SVN::Core::svn_log_entry_t object.
.ie n .IP "$client\->log4($targets, $peg_revision, $start, $end, $limit, $discover_changed_paths, $strict_node_history, $include_merged_revisions, $revprops, \e&log_entry_receiver, $pool);" 4
.el .IP "\f(CW$client\fR\->log4($targets, \f(CW$peg_revision\fR, \f(CW$start\fR, \f(CW$end\fR, \f(CW$limit\fR, \f(CW$discover_changed_paths\fR, \f(CW$strict_node_history\fR, \f(CW$include_merged_revisions\fR, \f(CW$revprops\fR, \e&log_entry_receiver, \f(CW$pool\fR);" 4
.IX Item "$client->log4($targets, $peg_revision, $start, $end, $limit, $discover_changed_paths, $strict_node_history, $include_merged_revisions, $revprops, &log_entry_receiver, $pool);"
Similar to \f(CW\*(C`$client\->log5()\*(C'\fR, 
but takes explicit \f(CW$start\fR and \f(CW$end\fR parameters
instead of \f(CW$revision_ranges\fR.
.Sp
Deprecated.
.ie n .IP "$client\->log3($targets, $peg_revision, $start, $end, $limit, $discover_changed_paths, $strict_node_history, \e&log_message_receiver, $pool);" 4
.el .IP "\f(CW$client\fR\->log3($targets, \f(CW$peg_revision\fR, \f(CW$start\fR, \f(CW$end\fR, \f(CW$limit\fR, \f(CW$discover_changed_paths\fR, \f(CW$strict_node_history\fR, \e&log_message_receiver, \f(CW$pool\fR);" 4
.IX Item "$client->log3($targets, $peg_revision, $start, $end, $limit, $discover_changed_paths, $strict_node_history, &log_message_receiver, $pool);"
Similar to \f(CW\*(C`$client\->log4()\*(C'\fR, but using \f(CW\*(C`log_message_receiver\*(C'\fR
instead of \f(CW\*(C`log_entry_receiver\*(C'\fR.  Also, \f(CW$include_merged_revisions\fR 
is false and \f(CW$revprops\fR is [qw( svn:author svn:date and svn:log )].
.Sp
The \f(CW\*(C`log_message_receiver\*(C'\fR takes the following arguments:
\&\f(CW\*(C`$changed_paths, $revision, $author, $date, $message, $pool\*(C'\fR.
It is called once for each log \f(CW$message\fR from the \f(CW$revision\fR
on \f(CW$date\fR by \f(CW$author\fR.  \f(CW$author\fR, \f(CW$date\fR or \f(CW$message\fR 
may be \f(CW\*(C`undef\*(C'\fR.
.Sp
If \f(CW$changed_paths\fR is defined it references a hash with the keys
every path committed in \f(CW$revision\fR; the values are 
SVN::Core::svn_log_changed_path_t
objects.
.Sp
Deprecated.
.ie n .IP "$client\->log2($targets, $start, $end, $limit, $discover_changed_paths, $strict_node_history, \e&log_message_receiver, $pool);" 4
.el .IP "\f(CW$client\fR\->log2($targets, \f(CW$start\fR, \f(CW$end\fR, \f(CW$limit\fR, \f(CW$discover_changed_paths\fR, \f(CW$strict_node_history\fR, \e&log_message_receiver, \f(CW$pool\fR);" 4
.IX Item "$client->log2($targets, $start, $end, $limit, $discover_changed_paths, $strict_node_history, &log_message_receiver, $pool);"
Similar to \f(CW\*(C`$client\->log3()\*(C'\fR, but with \f(CW$peg_revision\fR set to \f(CW\*(C`undef\*(C'\fR.
.Sp
Deprecated.
.ie n .IP "$client\->log($targets, $start, $end, $discover_changed_paths, $strict_node_history, \e&log_message_receiver, $pool);" 4
.el .IP "\f(CW$client\fR\->log($targets, \f(CW$start\fR, \f(CW$end\fR, \f(CW$discover_changed_paths\fR, \f(CW$strict_node_history\fR, \e&log_message_receiver, \f(CW$pool\fR);" 4
.IX Item "$client->log($targets, $start, $end, $discover_changed_paths, $strict_node_history, &log_message_receiver, $pool);"
Similar to \f(CW\*(C`$client\->log2()\*(C'\fR, but with \f(CW$limit\fR set to 0.
.Sp
\&\fISpecial case for repositories at revision 0:\fR
If \f(CW$start\fR is '\s-1HEAD\s0' and \f(CW$end\fR is 1, then handle an empty (no revisions)
repository specially: instead of erroring because requested revision 1
when the highest revision is 0, just invoke 
\&\f(CW\*(C`log_message_receiver\*(C'\fR on revision 0,
passing \f(CW\*(C`undef\*(C'\fR to \f(CW$changed_paths\fR and empty strings for the author and date.
This is because that particular combination of \f(CW$start\fR 
and \f(CW$end\fR usually indicates
the common case of log invocation; the user wants to see all log messages from
youngest to oldest, where the oldest commit is revision 1.  That works fine,
except there are no commits in the repository, hence this special case.
.Sp
Deprecated.
.ie n .IP "$client\->ls($target, $revision, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->ls($target, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->ls($target, $revision, $recursive, $pool);"
Returns a hash of svn_dirent_t objects for \f(CW$target\fR at \f(CW$revision\fR.
.Sp
If \f(CW$target\fR is a directory, returns entries for all of the directories'
contents.  If \f(CW$recursive\fR is true, it will recurse subdirectories in \f(CW$target\fR.
.Sp
If \f(CW$target\fR is a file only return an entry for the file.
.Sp
If \f(CW$target\fR is non-existent, raises the \f(CW$SVN::Error::FS_NOT_FOUND\fR
error.
.ie n .IP "$client\->merge($src1, $rev1, $src2, $rev2, $target_wcpath, $recursive, $ignore_ancestry, $force, $dry_run, $pool);" 4
.el .IP "\f(CW$client\fR\->merge($src1, \f(CW$rev1\fR, \f(CW$src2\fR, \f(CW$rev2\fR, \f(CW$target_wcpath\fR, \f(CW$recursive\fR, \f(CW$ignore_ancestry\fR, \f(CW$force\fR, \f(CW$dry_run\fR, \f(CW$pool\fR);" 4
.IX Item "$client->merge($src1, $rev1, $src2, $rev2, $target_wcpath, $recursive, $ignore_ancestry, $force, $dry_run, $pool);"
Merge changes from \f(CW$src1\fR/$rev1 to \f(CW$src2\fR/$rev2 into the working-copy path
\&\f(CW$target_wcpath\fR.
.Sp
\&\f(CW$src1\fR and \f(CW$src2\fR are either URLs that refer to entries in the repository, or
paths to entries in the working copy.
.Sp
By 'merging', we mean: apply file differences and schedule additions &
deletions when appropriate.
.Sp
\&\f(CW$src1\fR and \f(CW$src2\fR must both represent the same node kind; that is, if \f(CW$src1\fR
is a directory, \f(CW$src2\fR must also be, and if \f(CW$src1\fR is a file, \f(CW$src2\fR must also be.
.Sp
If either \f(CW$rev1\fR or \f(CW$rev2\fR is undef raises the \f(CW$SVN::Error::CLIENT_BAD_REVISION\fR
error.
.Sp
If \f(CW$recursive\fR is true (and the URLs are directories), apply changes recursively;
otherwise, only apply changes in the current directory.
.Sp
Use \f(CW$ignore_ancestry\fR to control whether or not items being diffed will be
checked for relatedness first.  Unrelated items are typically transmitted
to the editor as a deletion of one thing and the addition of another, but
if this flag is true, unrelated items will be diffed as if they were related.
.Sp
If \f(CW$force\fR is not set and the merge involves deleting locally modified or
unversioned items the operation will raise an error.  If \f(CW$force\fR is set such
items will be deleted.
.Sp
Calls the notify callback once for each merged target, passing the targets
local path.
.Sp
If \f(CW$dry_run\fR is true the merge is carried out, and the full notification
feedback is provided, but the working copy is not modified.
.Sp
Has no return.
.ie n .IP "$client\->mkdir($targets, $pool);" 4
.el .IP "\f(CW$client\fR\->mkdir($targets, \f(CW$pool\fR);" 4
.IX Item "$client->mkdir($targets, $pool);"
Similar to \f(CW$client\fR\->\fImkdir2()\fR except it returns an svn_client_commit_info_t
object instead of a svn_commit_info_t object.
.ie n .IP "$client\->mkdir2($targets, $pool);" 4
.el .IP "\f(CW$client\fR\->mkdir2($targets, \f(CW$pool\fR);" 4
.IX Item "$client->mkdir2($targets, $pool);"
Similar to \f(CW$client\fR\->\fImkdir3()\fR, but with \f(CW$make_parents\fR always \s-1FALSE,\s0 and
\&\f(CW$revprop_hash\fR always undef.
.ie n .IP "$client\->mkdir3($targets, $make_parents, $revprop_hash, $pool);" 4
.el .IP "\f(CW$client\fR\->mkdir3($targets, \f(CW$make_parents\fR, \f(CW$revprop_hash\fR, \f(CW$pool\fR);" 4
.IX Item "$client->mkdir3($targets, $make_parents, $revprop_hash, $pool);"
Similar to \f(CW$client\fR\->\fImkdir4()\fR, but returns a svn_commit_info_t object rather
than through a callback function.
.ie n .IP "$client\->mkdir4($targets, $make_parents, $revprop_hash, \e&commit_callback, $pool);" 4
.el .IP "\f(CW$client\fR\->mkdir4($targets, \f(CW$make_parents\fR, \f(CW$revprop_hash\fR, \e&commit_callback, \f(CW$pool\fR);" 4
.IX Item "$client->mkdir4($targets, $make_parents, $revprop_hash, &commit_callback, $pool);"
Create a directory, either in a repository or a working copy.
.Sp
If \f(CW$targets\fR contains URLs, immediately attempts to commit the creation of the
directories in \f(CW$targets\fR in the repository.  Returns a svn_client_commit_info_t
object.
.Sp
Else, create the directories on disk, and attempt to schedule them for addition.
In this case returns undef.
.Sp
If \f(CW$make_parents\fR is \s-1TRUE,\s0 create any non-existent parent directories also.
.Sp
If not undef, \f(CW$revprop_hash\fR is a reference to a hash table holding additional
custom revision properites (property names mapped to strings) to be set on the
new revision in the event that this is a committing operation.  This hash
cannot contain any standard Subversion properties.
.Sp
Calls the log message callback to query for a commit log message when one is
needed.
.Sp
Calls the notify callback when the directory has been created (successfully)
in the working copy, with the path of the new directory.  Note this is only
called for items added to the working copy.
.Sp
If \e&commit_callback is not undef, then for each successful commit, call
\&\e&commit_callback with the svn_commit_info_t object for the commit.
.ie n .IP "$client\->move($src_path, $src_revision, $dst_path, $force, $pool);" 4
.el .IP "\f(CW$client\fR\->move($src_path, \f(CW$src_revision\fR, \f(CW$dst_path\fR, \f(CW$force\fR, \f(CW$pool\fR);" 4
.IX Item "$client->move($src_path, $src_revision, $dst_path, $force, $pool);"
Move \f(CW$src_path\fR to \f(CW$dst_path\fR.
.Sp
\&\f(CW$src_path\fR must be a file or directory under version control, or the \s-1URL\s0
of a versioned item in the repository.
.Sp
If \f(CW$src_path\fR is a repository \s-1URL:\s0
.Sp
* \f(CW$dst_path\fR must also be a repository \s-1URL\s0 (existent or not).
.Sp
* \f(CW$src_revision\fR is used to choose the revision from which to copy the
\&\f(CW$src_path\fR.
.Sp
* The log_msg callback will be called for the commit log message.
.Sp
* The move operation will be immediately committed.  If the commit succeeds,
returns a svn_client_commit_info_t object.
.Sp
If \f(CW$src_path\fR is a working copy path
.Sp
* \f(CW$dst_path\fR must also be a working copy path (existent or not).
.Sp
* \f(CW$src_revision\fR is ignored and may be undef.  The log_msg callback will
not be called.
.Sp
* This is a scheduling operation.  No changes will happen to the repository
until a commit occurs.  This scheduling can be removed with \f(CW$client\fR\->\fIrevert()\fR.
If \f(CW$src_path\fR is a file it is removed from the working copy immediately.
If \f(CW$src_path\fR is a directory it will remain in the working copy but all
files, and unversioned items, it contains will be removed.
.Sp
* If \f(CW$src_path\fR contains locally modified and/or unversioned items and \f(CW$force\fR is
not set, the copy will raise an error.  If \f(CW$force\fR is set such items will be
removed.
.Sp
The notify callback will be called twice for each item moved, once to
indicate the deletion of the moved node, and once to indicate the addition
of the new location of the node.
.ie n .IP "$client\->propget($propname, $target, $revision, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->propget($propname, \f(CW$target\fR, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->propget($propname, $target, $revision, $recursive, $pool);"
Returns a reference to a hash containing paths or URLs, prefixed by \f(CW$target\fR (a
working copy or \s-1URL\s0), of items for which the property \f(CW$propname\fR is set, and
whose values represent the property value for \f(CW$propname\fR at that path.
.ie n .IP "$client\->proplist($target, $revision, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->proplist($target, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->proplist($target, $revision, $recursive, $pool);"
Returns a reference to an array of svn_client_proplist_item_t objects.
.Sp
For each item the node_name member of the proplist_item object contains
the name relative to the same base as \f(CW$target\fR.
.Sp
If \f(CW$revision\fR is undef, then get properties from the working copy, if
\&\f(CW$target\fR is a working copy, or from the repository head if \f(CW$target\fR is a \s-1URL.\s0
Else get the properties as of \f(CW$revision\fR.
.Sp
If \f(CW$recursive\fR is false, or \f(CW$target\fR is a file, the returned array will only
contain a single element.  Otherwise, it will contain one entry for each
versioned entry below (and including) \f(CW$target\fR.
.Sp
If \f(CW$target\fR is not found, raises the \f(CW$SVN::Error::ENTRY_NOT_FOUND\fR error.
.ie n .IP "$client\->propset($propname, $propval, $target, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->propset($propname, \f(CW$propval\fR, \f(CW$target\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->propset($propname, $propval, $target, $recursive, $pool);"
Set \f(CW$propname\fR to \f(CW$propval\fR on \f(CW$target\fR (a working copy or \s-1URL\s0 path).
.Sp
If \f(CW$recursive\fR is true, then \f(CW$propname\fR will be set recursively on \f(CW$target\fR
and all children.  If \f(CW$recursive\fR is false, and \f(CW$target\fR is a directory,
\&\f(CW$propname\fR will be set on \fBonly\fR \f(CW$target\fR.
.Sp
A \f(CW$propval\fR of undef will delete the property.
.Sp
If \f(CW$propname\fR is an svn-controlled property (i.e. prefixed with svn:),
then the caller is responsible for ensuring that \f(CW$propval\fR is UTF8\-encoded
and uses \s-1LF\s0 line-endings.
.ie n .IP "$client\->relocate($dir, $from, $to, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->relocate($dir, \f(CW$from\fR, \f(CW$to\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->relocate($dir, $from, $to, $recursive, $pool);"
Modify a working copy directory \f(CW$dir\fR, changing any repository URLs that
begin with \f(CW$from\fR to begin with \f(CW$to\fR instead, recursing into subdirectories if
\&\f(CW$recursive\fR is true.
.Sp
Has no return.
.ie n .IP "$client\->resolved($path, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->resolved($path, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->resolved($path, $recursive, $pool);"
Removed the 'conflicted' state on a working copy path.
.Sp
This will not semantically resolve conflicts; it just allows \f(CW$path\fR to be
committed in the future.  The implementation details are opaque.  If
\&\f(CW$recursive\fR is set, recurse below \f(CW$path\fR, looking for conflicts to
resolve.
.Sp
If \f(CW$path\fR is not in a state of conflict to begin with, do nothing.
.Sp
If \f(CW$path\fR's conflict state is removed, call the notify callback with the
\&\f(CW$path\fR.
.ie n .IP "$client\->revert($paths, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->revert($paths, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->revert($paths, $recursive, $pool);"
Restore the pristine version of a working copy \f(CW$paths\fR, effectively undoing
any local mods.
.Sp
For each path in \f(CW$paths\fR, if it is a directory and \f(CW$recursive\fR
is true, this will be a recursive operation.
.ie n .IP "$client\->revprop_get($propname, $url, $revision, $pool);" 4
.el .IP "\f(CW$client\fR\->revprop_get($propname, \f(CW$url\fR, \f(CW$revision\fR, \f(CW$pool\fR);" 4
.IX Item "$client->revprop_get($propname, $url, $revision, $pool);"
Returns two values, the first of which is the value of \f(CW$propname\fR on revision
\&\f(CW$revision\fR in the repository represented by \f(CW$url\fR.  The second value is the
actual revision queried.
.Sp
Note that unlike its cousin \f(CW$client\fR\->\fIpropget()\fR, this routine doesn't affect
working copy at all; it's a pure network operation that queries an
\&\fBunversioned\fR property attached to a revision.  This can be used to query
log messages, dates, authors, and the like.
.ie n .IP "$client\->revprop_list($url, $revision, $pool);" 4
.el .IP "\f(CW$client\fR\->revprop_list($url, \f(CW$revision\fR, \f(CW$pool\fR);" 4
.IX Item "$client->revprop_list($url, $revision, $pool);"
Returns two values, the first of which is a reference to a hash containing
the properties attached to \f(CW$revision\fR in the repository represented by \f(CW$url\fR.
The second value is the actual revision queried.
.Sp
Note that unlike its cousin \f(CW$client\fR\->\fIproplist()\fR, this routine doesn't read a
working copy at all; it's a pure network operation that reads \fBunversioned\fR
properties attached to a revision.
.ie n .IP "$client\->revprop_set($propname, $propval, $url, $revision, $force, $pool);" 4
.el .IP "\f(CW$client\fR\->revprop_set($propname, \f(CW$propval\fR, \f(CW$url\fR, \f(CW$revision\fR, \f(CW$force\fR, \f(CW$pool\fR);" 4
.IX Item "$client->revprop_set($propname, $propval, $url, $revision, $force, $pool);"
Set \f(CW$propname\fR to \f(CW$propval\fR on revision \f(CW$revision\fR in the repository represented
by \f(CW$url\fR.
.Sp
Returns the actual revision affected.  A \f(CW$propval\fR of undef will delete the
property.
.Sp
If \f(CW$force\fR is true, allow newlines in the author property.
.Sp
If \f(CW$propname\fR is an svn-controlled property (i.e. prefixed with svn:), then
the caller is responsible for ensuring that the value is UTF8\-encoded and
uses \s-1LF\s0 line-endings.
.Sp
Note that unlike its cousin \f(CW$client\fR\->\fIpropset()\fR, this routine doesn't affect
the working copy at all; it's a pure network operation that changes an
\&\fBunversioned\fR property attached to a revision.  This can be used to tweak
log messages, dates, authors, and the like.  Be careful: it's a lossy
operation, meaning that any existing value is replaced with the new value,
with no way to retrieve the prior value.
.Sp
Also note that unless the administrator creates a pre-revprop-change hook
in the repository, this feature will fail.
.ie n .IP "$client\->status($path, $revision, \e&status_func, $recursive, $get_all, $update, $no_ignore, $pool);" 4
.el .IP "\f(CW$client\fR\->status($path, \f(CW$revision\fR, \e&status_func, \f(CW$recursive\fR, \f(CW$get_all\fR, \f(CW$update\fR, \f(CW$no_ignore\fR, \f(CW$pool\fR);" 4
.IX Item "$client->status($path, $revision, &status_func, $recursive, $get_all, $update, $no_ignore, $pool);"
Similar to \f(CW$client\fR\->\fIstatus2()\fR, but with ignore_externals always set to \s-1FALSE,\s0 and with the status_func receiving a svn_wc_status2_t instead of a svn_wc_status_t object.
.ie n .IP "$client\->status2($path, $revision, \e&status_func, $recursive, $get_all, $update, $no_ignore, $ignore_externals, $pool);" 4
.el .IP "\f(CW$client\fR\->status2($path, \f(CW$revision\fR, \e&status_func, \f(CW$recursive\fR, \f(CW$get_all\fR, \f(CW$update\fR, \f(CW$no_ignore\fR, \f(CW$ignore_externals\fR, \f(CW$pool\fR);" 4
.IX Item "$client->status2($path, $revision, &status_func, $recursive, $get_all, $update, $no_ignore, $ignore_externals, $pool);"
Similar to \f(CW$client\fR\->\fIstatus3()\fR, but with the changelists passed as undef, and with recursive instead of depth.
.ie n .IP "$client\->status3($path, $revision, \e&status_func, $depth, $get_all, $update, $no_ignore, $ignore_externals, $changelists, $pool);" 4
.el .IP "\f(CW$client\fR\->status3($path, \f(CW$revision\fR, \e&status_func, \f(CW$depth\fR, \f(CW$get_all\fR, \f(CW$update\fR, \f(CW$no_ignore\fR, \f(CW$ignore_externals\fR, \f(CW$changelists\fR, \f(CW$pool\fR);" 4
.IX Item "$client->status3($path, $revision, &status_func, $depth, $get_all, $update, $no_ignore, $ignore_externals, $changelists, $pool);"
Similar to \f(CW$client\fR\->\fIstatus4()\fR, without the pool parameter to the callback and the return of the callback is ignored.
.ie n .IP "$client\->status4($path, $revision, \e&status_func, $depth, $get_all, $update, $no_ignore, $ignore_externals, $changelists, $pool);" 4
.el .IP "\f(CW$client\fR\->status4($path, \f(CW$revision\fR, \e&status_func, \f(CW$depth\fR, \f(CW$get_all\fR, \f(CW$update\fR, \f(CW$no_ignore\fR, \f(CW$ignore_externals\fR, \f(CW$changelists\fR, \f(CW$pool\fR);" 4
.IX Item "$client->status4($path, $revision, &status_func, $depth, $get_all, $update, $no_ignore, $ignore_externals, $changelists, $pool);"
Given \f(CW$path\fR to a working copy directory (or single file), call \fIstatus_func()\fR
with a set of svn_wc_status2_t objects which describe the status of \f(CW$path\fR and
its children.
.Sp
If \f(CW$recursive\fR is true, recurse fully, else do only immediate children.
.Sp
If \f(CW$get_all\fR is set, retrieve all entries; otherwise, retrieve only 'interesting'
entries (local mods and/or out-of-date).
.Sp
If \f(CW$update\fR is set, contact the repository and augment the status objects with
information about out-of-dateness (with respect to \f(CW$revision\fR).  Also, will
return the value of the actual revision against with the working copy was
compared.  (The return will be undef if \f(CW$update\fR is not set).
.Sp
Unless ignore_externals is set, the function recurses into externals definitions
('svn:externals') after handling the main target, if any exist.  The function
calls the notify callback with \f(CW$SVN::Wc::Notify::Action::status_external\fR action
before handling each externals definition, and with 
\&\f(CW$SVN::Wc::Notify::Action::status_completed\fR after each.
.Sp
\&\f(CW$changelists\fR is a reference to an array of changelist names, used as a restrictive filter on items whose statuses are reported; that is don't report status about any item unless it's a member of those changelists.  If changelists is empty (or altogether undef), no changelist filtering occurs.
.Sp
The status_func subroutine takes the following parameters:
\&\f(CW$path\fR, \f(CW$status\fR, \f(CW$pool\fR
.Sp
\&\f(CW$path\fR is the pathname of the file or directory which status is being
reported.  \f(CW$status\fR is a svn_wc_status2_t object.  \f(CW$pool\fR is an apr_pool_t
object which is cleaned between invocations to the callback.
.Sp
The return of the status_func subroutine can be a svn_error_t object created by
SVN::Error::create in order to propagate an error up.
.ie n .IP "$client\->switch($path, $url, $revision, $recursive, $pool);" 4
.el .IP "\f(CW$client\fR\->switch($path, \f(CW$url\fR, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$pool\fR);" 4
.IX Item "$client->switch($path, $url, $revision, $recursive, $pool);"
Switch working tree \f(CW$path\fR to \f(CW$url\fR at \f(CW$revision\fR.
.Sp
\&\f(CW$revision\fR must be a number, '\s-1HEAD\s0', or a date, otherwise it raises the
\&\f(CW$SVN::Error::CLIENT_BAD_REVISION\fR error.
.Sp
Calls the notify callback on paths affected by the switch.  Also invokes
the callback for files that may be restored from the text-base because they
were removed from the working copy.
.Sp
Summary of purpose: This is normally used to switch a working directory
over to another line of development, such as a branch or a tag.  Switching
an existing working directory is more efficient than checking out \f(CW$url\fR from
scratch.
.Sp
Returns the value of the revision to which the working copy was actually
switched.
.ie n .IP "$client\->update($path, $revision, $recursive, $pool)" 4
.el .IP "\f(CW$client\fR\->update($path, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$pool\fR)" 4
.IX Item "$client->update($path, $revision, $recursive, $pool)"
Similar to \f(CW$client\fR\->\fIupdate2()\fR except that it accepts only a single target in
\&\f(CW$path\fR, returns a single revision, and \f(CW$ignore_externals\fR is always set to \s-1FALSE.\s0
.ie n .IP "$client\->update2($paths, $revision, $recursive, $ignore_externals, $pool)" 4
.el .IP "\f(CW$client\fR\->update2($paths, \f(CW$revision\fR, \f(CW$recursive\fR, \f(CW$ignore_externals\fR, \f(CW$pool\fR)" 4
.IX Item "$client->update2($paths, $revision, $recursive, $ignore_externals, $pool)"
Similar to \f(CW$client\fR\->\fIupdate3()\fR but with \f(CW$allow_unver_obstructions\fR always set to
\&\s-1FALSE,\s0 \f(CW$depth_is_sticky\fR to \s-1FALSE,\s0 and \f(CW$depth\fR set according to \f(CW$recursive:\fR if
\&\f(CW$recursive\fR is \s-1TRUE,\s0 set \f(CW$depth\fR to \f(CW$SVN::Depth::infinity\fR, if \f(CW$recursive\fR is
\&\s-1FALSE,\s0 set \f(CW$depth\fR to \f(CW$SVN::Depth::files\fR.
.ie n .IP "$client\->update3($paths, $revision, $depth, $depth_is_sticky, $ignore_externals, $allow_unver_obstructions, $pool)" 4
.el .IP "\f(CW$client\fR\->update3($paths, \f(CW$revision\fR, \f(CW$depth\fR, \f(CW$depth_is_sticky\fR, \f(CW$ignore_externals\fR, \f(CW$allow_unver_obstructions\fR, \f(CW$pool\fR)" 4
.IX Item "$client->update3($paths, $revision, $depth, $depth_is_sticky, $ignore_externals, $allow_unver_obstructions, $pool)"
Similar to \f(CW$client\fR\->\fIupdate4()\fR but with \f(CW$make_parents\fR always set to \s-1FALSE\s0 and
\&\f(CW$adds_as_modification\fR set to \s-1TRUE.\s0
.ie n .IP "$client\->update4($paths, $revision, $depth, $depth_is_sticky, $ignore_externals, $allow_unver_obstructions, $adds_as_modification, $make_parents)" 4
.el .IP "\f(CW$client\fR\->update4($paths, \f(CW$revision\fR, \f(CW$depth\fR, \f(CW$depth_is_sticky\fR, \f(CW$ignore_externals\fR, \f(CW$allow_unver_obstructions\fR, \f(CW$adds_as_modification\fR, \f(CW$make_parents\fR)" 4
.IX Item "$client->update4($paths, $revision, $depth, $depth_is_sticky, $ignore_externals, $allow_unver_obstructions, $adds_as_modification, $make_parents)"
Update working trees \f(CW$paths\fR to \f(CW$revision\fR.
.Sp
\&\f(CW$paths\fR is a array reference of paths to be updated.  Unversioned paths that are
the direct children of a versioned path will cause an update that attempts to
add that path; other unversioned paths are skipped.
.Sp
\&\f(CW$revision\fR must be a revision number, '\s-1HEAD\s0', or a date or this method will
raise the \f(CW$SVN::Error::CLIENT_BAD_REVISION\fR error.
.Sp
The paths in \f(CW$paths\fR can be from multiple working copies from multiple
repositories, but even if they all come from the same repository there is no
guarantee that revision represented by '\s-1HEAD\s0' will remain the same as each path
is updated.
.Sp
If \f(CW$ignore_externals\fR is set, don't process externals definitions as part of
this operation.
.Sp
If \f(CW$depth\fR is \f(CW$SVN::Depth::infinity\fR, update fully recursivelly.  Else if it is
\&\f(CW$SVN::Depth::immediates\fR or \f(CW$SVN::Depth::files\fR, update each target and its file
entries, but not its subdirectories.  Else if \f(CW$SVN::Depth::empty\fR, update
exactly each target, nonrecursively (essentially, update the target's
properties).
.Sp
If \f(CW$depth\fR is \f(CW$SVN::Depth::unknown\fR, take the working depth from \f(CW$paths\fR and then
describe as behaved above.
.Sp
If \f(CW$depth_is_sticky\fR is set and \f(CW$depth\fR is not \f(CW$SVN::Depth::unknown\fR, then in
addition to update paths, also set their sticky ambient depth value to \f(CW$depth\fR.
.Sp
If \f(CW$allow_unver_obstructions\fR is \s-1TRUE\s0 then the update tolerates existing 
unversioned items that obstruct added paths.  Only obstructions of the same
type (file or dir) as the added item are tolerated.  The text of obstructing
files is left as-is, effectively treating it as a user modification after the
update.  Working properties of obstructing items are set equal to the base
properties.  If \f(CW$allow_unver_obstructions\fR is \s-1FALSE\s0 then the update will abort
if there are any unversioned obstructing items.
.Sp
If \f(CW$adds_as_modification\fR is \s-1TRUE,\s0 a local addition at the same path as an 
incoming addition of the same node kind results in a normal node with a
possible local modification, instead of a tree conflict.
.Sp
If \f(CW$make_parents\fR is \s-1TRUE,\s0 create any non-existent parent directories also by
checking them out at depth=empty.
.Sp
Calls the notify callback for each item handled by the update, and
also for files restored from the text-base.
.Sp
Returns an array reference to an array of revision numbers with each element
set to the revision to which \f(CW$revision\fR was resolved for the corresponding
element of \f(CW$paths\fR.
.ie n .IP "$client\->url_from_path($target, $pool); or SVN::Client::url_from_path($target, $pool);" 4
.el .IP "\f(CW$client\fR\->url_from_path($target, \f(CW$pool\fR); or SVN::Client::url_from_path($target, \f(CW$pool\fR);" 4
.IX Item "$client->url_from_path($target, $pool); or SVN::Client::url_from_path($target, $pool);"
Returns the \s-1URL\s0 for \f(CW$target\fR.
.Sp
If \f(CW$target\fR is already a \s-1URL\s0 it returns \f(CW$target\fR.
.Sp
If \f(CW$target\fR is a versioned item, it returns \f(CW$target\fR's entry \s-1URL.\s0
.Sp
If \f(CW$target\fR is unversioned (has no entry), returns undef.
.ie n .IP "$client\->uuid_from_path($path, $adm_access, $pool);" 4
.el .IP "\f(CW$client\fR\->uuid_from_path($path, \f(CW$adm_access\fR, \f(CW$pool\fR);" 4
.IX Item "$client->uuid_from_path($path, $adm_access, $pool);"
Return the repository uuid for working-copy \f(CW$path\fR, allocated in \f(CW$pool\fR.
.Sp
Use \f(CW$adm_access\fR to retrieve the uuid from \f(CW$path\fR's entry; if not present in the
entry, then call \f(CW$client\fR\->\fIuuid_from_url()\fR to retrieve, using the entry's \s-1URL.\s0
.Sp
Note: The only reason this function falls back on \f(CW$client\fR\->uuid_from_url is for
compatibility purposes.  Old working copies may not have uuids in the entries
files.
.Sp
Note: This method probably doesn't work right now without a lot of pain,
because SVN::Wc is incomplete and it requires an adm_access object from it.
.ie n .IP "$client\->uuid_from_url($url, $pool);" 4
.el .IP "\f(CW$client\fR\->uuid_from_url($url, \f(CW$pool\fR);" 4
.IX Item "$client->uuid_from_url($url, $pool);"
Return repository uuid for url.
.SH "ATTRIBUTE METHODS"
.IX Header "ATTRIBUTE METHODS"
The following attribute methods are provided that allow you to set various
configuration or retrieve it.  They all take value(s) to set the attribute and
return the new value of the attribute or no parameters which returns the
current value.
.ie n .IP "$client\->auth(\fISVN::Client::get_username_provider()\fR);" 4
.el .IP "\f(CW$client\fR\->auth(\fISVN::Client::get_username_provider()\fR);" 4
.IX Item "$client->auth(SVN::Client::get_username_provider());"
Provides access to the auth_baton in the svn_client_ctx_t attached to the
SVN::Client object.
.Sp
This method will accept an array or array ref of values returned from the
authentication provider functions see \*(L"\s-1AUTHENTICATION PROVIDERS\*(R"\s0, which
it will convert to an auth_baton for you.  This is the preferred method of
setting the auth_baton.
.Sp
It will also accept a scalar that references a _p_svn_auth_baton_t such as
those returned from SVN::Core::auth_open and SVN::Core::auth_open_helper.
.ie n .IP "$client\->notify(\e&notify);" 4
.el .IP "\f(CW$client\fR\->notify(\e&notify);" 4
.IX Item "$client->notify(&notify);"
Sets the notify callback for the client context to a code reference that
you pass.  It always returns the current codereference set.
.Sp
The subroutine pointed to by this reference will be called when a change
is made to the working copy.  The return value of this function is ignored.
It's only purpose is to notify you of the change.
.Sp
The subroutine will receive 6 parameters.  The first parameter will be the path
of the changed file (absolute or relative to the cwd).  The second is an
integer specifying the type of action taken.  See SVN::Wc for a list of the
possible actions values and what they mean.  The 3rd is an integer specifying
the kind of node the path is, which can be: \f(CW$SVN::Node::none\fR, \f(CW$SVN::Node::file\fR,
\&\f(CW$SVN::Node::dir\fR, \f(CW$SVN::Node::unknown\fR.  The fourth parameter is the mime-type of
the file or undef if the mime-type is unknown (it will always be undef for
directories).  The 5th parameter is the state of the file, again see SVN::Wc
for a list of the possible states.  The 6th and final parameter is the numeric
revision number of the changed file.  The revision number will be \-1 except
when the action is \f(CW$SVN::Wc::Notify::Action::update_completed\fR.
.ie n .IP "$client\->log_msg(\e&log_msg)" 4
.el .IP "\f(CW$client\fR\->log_msg(\e&log_msg)" 4
.IX Item "$client->log_msg(&log_msg)"
Sets the log_msg callback for the client context to a code reference that you
pass.  It always returns the current codereference set.
.Sp
The subroutine pointed to by this coderef will be called to get the log
message for any operation that will commit a revision to the repo.
.Sp
It receives 4 parameters.  The first parameter is a reference to a scalar
value in which the callback should place the log_msg.  If you wish to cancel
the commit you can set this scalar to undef.  The 2nd value is a path to any
temporary file which might be holding that log message, or undef if no such
file exists (though, if log_msg is undef, this value is undefined).  The
log message \fB\s-1MUST\s0\fR be a \s-1UTF8\s0 string with \s-1LF\s0 line separators.  The 3rd parameter
is a reference to an array of svn_client_commit_item3_t objects, which may
be fully or only partially filled-in, depending on the type of commit
operation.  The 4th and last parameter will be a pool.
.Sp
If the function wishes to return an error it should return a svn_error_t
object made with SVN::Error::create.  Any other return value will be
interpreted as \s-1SVN_NO_ERROR.\s0
.ie n .IP "$client\->cancel(\e&cancel)" 4
.el .IP "\f(CW$client\fR\->cancel(\e&cancel)" 4
.IX Item "$client->cancel(&cancel)"
Sets the cancellation callback for the client context to a code reference that you
pass. See \*(L"\s-1CANCELLATION CALLBACK\*(R"\s0 below for details.
It always returns the current codereference set.
.ie n .IP "$client\->pool(new SVN::Pool);" 4
.el .IP "\f(CW$client\fR\->pool(new SVN::Pool);" 4
.IX Item "$client->pool(new SVN::Pool);"
Method that sets or gets the default pool that is passed to method calls
requiring a pool, but which were not explicitly passed one.
.Sp
See SVN::Core for more information about how pools are managed
in this interface.
.ie n .IP "$client\->config(SVN::Core::config_get_config(undef));" 4
.el .IP "\f(CW$client\fR\->config(SVN::Core::config_get_config(undef));" 4
.IX Item "$client->config(SVN::Core::config_get_config(undef));"
Method that allows access to the config member of the svn_client_ctx_t.
Accepts a Perl hash to set, which is what functions like
\&\fISVN::Core:config_get_config()\fR will return.
.Sp
It will return a _p_arp_hash_t scalar.  This is a temporary
situation.  The return value is not particular useful.  In
the future, this value will be tied to the actual hash used
by the C \s-1API.\s0
.SH "AUTHENTICATION PROVIDERS"
.IX Header "AUTHENTICATION PROVIDERS"
The following functions get authentication providers for you.
They come in two forms.  Standard or File versions, which look
for authentication information in the subversion configuration
directory that was previously cached, or Prompt versions which
call a subroutine to allow you to prompt the user for the
information.
.PP
The functions that return the svn_auth_provider_object_t for prompt style
providers take a reference to a Perl subroutine to use for the callback.  The
first parameter each of these subroutines receive is a credential object.  The
subroutines return the response by setting members of that object.  Members may
be set like so: \f(CW$cred\fR\->username(\*(L"breser\*(R");  These functions and credential
objects always have a may_save member which specifies if the authentication
data will be cached.
.PP
The providers are as follows:
.PP
.Vb 3
\&        NAME                WHAT IT HANDLES
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        simple              username and password pairs
\&
\&        username            username only
\&
\&        ssl_server_trust    server certificates and failures
\&                            authenticating them
\&
\&        ssl_client_cert     client side certificate files
\&
\&        ssl_client_cert_pw  password for a client side certificate file.
.Ve
.IP "SVN::Client::get_simple_provider" 4
.IX Item "SVN::Client::get_simple_provider"
Returns a simple provider that returns information from previously cached
sessions.  Takes no parameters or one pool parameter.
.IP "SVN::Client::get_simple_prompt_provider" 4
.IX Item "SVN::Client::get_simple_prompt_provider"
Returns a simple provider that prompts the user via a callback.  Takes two or
three parameters, the first is the callback subroutine, the 2nd is the number
of retries to allow, the 3rd is optionally a pool.  The subroutine gets called
with the following parameters: a svn_auth_cred_simple_t object, a realm string,
a default username, may_save, and a pool.  The svn_auth_cred_simple has the
following members: username, password, and may_save.
.IP "SVN::Client::get_username_provider" 4
.IX Item "SVN::Client::get_username_provider"
Returns a username provider that returns information from a previously cached
sessions.  Takes no parameters or one pool parameter.
.IP "SVN::Client::get_username_prompt_provider" 4
.IX Item "SVN::Client::get_username_prompt_provider"
Returns a username provider that prompts the user via a callback.  Takes two or
three parameters, the first is the callback subroutine, the 2nd is the number
of retries to allow, the 3rd is optionally a pool.  The subroutine gets called
with the following parameters: a svn_auth_cred_username_t object, a realm
string, a default username, may_save, and a pool.  The svn_auth_cred_username
has the following members: username and may_save.
.IP "SVN::Client::get_ssl_server_trust_file_provider" 4
.IX Item "SVN::Client::get_ssl_server_trust_file_provider"
Returns a server trust provider that returns information from previously
cached sessions.  Takes no parameters or optionally a pool parameter.
.IP "SVN::Client::get_ssl_server_trust_prompt_provider" 4
.IX Item "SVN::Client::get_ssl_server_trust_prompt_provider"
Returns a server trust  provider that prompts the user via a callback. Takes
one or two parameters the callback subroutine and optionally a pool parameter.
The subroutine gets called with the following parameters.  A
svn_auth_cred_ssl_server_trust_t object, a realm string, an integer specifying
how the certificate failed authentication, a svn_auth_ssl_server_cert_info_t
object, may_save, and a pool.  The svn_auth_cred_ssl_server_trust_t object has
the following members: may_save and accepted_failures.  The
svn_auth_ssl_server_cert_info_t object has the following members (and behaves
just like cred objects though you can't modify it): hostname, fingerprint,
valid_from, valid_until, issuer_dname, ascii_cert.
.Sp
The masks used for determining the failures are in SVN::Auth::SSL and are named:
.Sp
\&\f(CW$SVN::Auth::SSL::NOTYETVALID\fR
\&\f(CW$SVN::Auth::SSL::EXPIRED\fR
\&\f(CW$SVN::Auth::SSL::CNMISMATCH\fR
\&\f(CW$SVN::Auth::SSL::UNKNOWNCA\fR
\&\f(CW$SVN::Auth::SSL::OTHER\fR
.Sp
You reply by setting the accepted_failures of the cred object with an integer
of the values for what you want to accept bitwise \s-1AND\s0'd together.
.IP "SVN::Client::get_ssl_client_cert_file_provider" 4
.IX Item "SVN::Client::get_ssl_client_cert_file_provider"
Returns a client certificate provider that returns information from previously
cached sessions.  Takes no parameters or optionally a pool parameter.
.IP "SVN::Client::get_ssl_client_cert_prompt_provider" 4
.IX Item "SVN::Client::get_ssl_client_cert_prompt_provider"
Returns a client certificate provider that prompts the user via a callback.
Takes two or three parameters: the first is the callback subroutine, the 2nd is
the number of retries to allow, the 3rd is optionally a pool parameter.  The
subroutine gets called with the following parameters.  A
svn_auth_cred_ssl_client_cert object, a realm string, may_save, and a pool.
The svn_auth_cred_ssl_client_cert the following members: cert_file and
may_save.
.IP "SVN::Client::get_ssl_client_cert_pw_file_provider" 4
.IX Item "SVN::Client::get_ssl_client_cert_pw_file_provider"
Returns a client certificate password provider that returns information from
previously cached sessions.  Takes no parameters or optionally a pool
parameter.
.IP "SVN::Client::get_ssl_client_cert_pw_prompt_provider" 4
.IX Item "SVN::Client::get_ssl_client_cert_pw_prompt_provider"
Returns a client certificate password provider that prompts the user via a
callback. Takes two or three parameters, the first is the callback subroutine,
the 2nd is the number of retries to allow, the 3rd is optionally a pool
parameter.  The subroutine gets called with the following parameters.  A
svn_auth_cred_ssl_client_cert_pw object, a realm string, may_save, and a pool.
The svn_auth_cred_ssl_client_cert_pw has the following members: password and
may_save.
.SH "CANCELLATION CALLBACK"
.IX Header "CANCELLATION CALLBACK"
This callback will be called periodically to see if the operation
should be canceled.  If the operation should be canceled, the function may
return one of the following values:
.PP
An svn_error_t object made with SVN::Error::create.
.PP
Any true value, in which case the bindings will generate an svn_error_t object
for you with the error code of \s-1SVN_ERR_CANCELLED\s0 and the string set to \*(L"By
cancel callback\*(R".
.PP
A string, in which case the bindings will generate an svn_error_t object for you
with the error code of \s-1SVN_ERR_CANCELLED\s0 and the string set to the string you
returned.
.PP
Any other value will be interpreted as wanting to continue the operation.
Generally, it's best to return 0 to continue the operation.
.SH "OBJECTS"
.IX Header "OBJECTS"
These are some of the object types that are returned from the methods
and functions.  Others are documented in SVN::Core and SVN::Wc.
If an object is not documented, it is more than likely opaque and
not something you can do anything with, except pass to other functions
that require such objects.
.SS "svn_info_t"
.IX Subsection "svn_info_t"
.ie n .IP "$info\->\s-1\fIURL\s0()\fR" 8
.el .IP "\f(CW$info\fR\->\s-1\fIURL\s0()\fR" 8
.IX Item "$info->URL()"
Where the item lives in the repository.
.ie n .IP "$info\->\fIrev()\fR" 8
.el .IP "\f(CW$info\fR\->\fIrev()\fR" 8
.IX Item "$info->rev()"
The revision of the object.  If path_or_url is a working-copy
path, then this is its current working revnum.  If path_or_url
is a \s-1URL,\s0 then this is the repos revision that path_or_url lives in.
.ie n .IP "$info\->\fIkind()\fR" 8
.el .IP "\f(CW$info\fR\->\fIkind()\fR" 8
.IX Item "$info->kind()"
The node's kind.
.ie n .IP "$info\->\fIrepos_root_URL()\fR" 8
.el .IP "\f(CW$info\fR\->\fIrepos_root_URL()\fR" 8
.IX Item "$info->repos_root_URL()"
The root \s-1URL\s0 of the repository.
.ie n .IP "$info\->\fIrepos_UUID()\fR" 8
.el .IP "\f(CW$info\fR\->\fIrepos_UUID()\fR" 8
.IX Item "$info->repos_UUID()"
The repository's \s-1UUID.\s0
.ie n .IP "$info\->\fIlast_changed_rev()\fR" 8
.el .IP "\f(CW$info\fR\->\fIlast_changed_rev()\fR" 8
.IX Item "$info->last_changed_rev()"
The last revision in which this object changed.
.ie n .IP "$info\->\fIlast_changed_date()\fR" 8
.el .IP "\f(CW$info\fR\->\fIlast_changed_date()\fR" 8
.IX Item "$info->last_changed_date()"
The date of the last_changed_rev.
.ie n .IP "$info\->\fIlast_changed_author()\fR" 8
.el .IP "\f(CW$info\fR\->\fIlast_changed_author()\fR" 8
.IX Item "$info->last_changed_author()"
The author of the last_changed_rev.
.ie n .IP "$info\->\fIlock()\fR" 8
.el .IP "\f(CW$info\fR\->\fIlock()\fR" 8
.IX Item "$info->lock()"
An exclusive lock, if present.  Could be either local or remote.
.PP
See SVN::Wc::svn_wc_entry_t for the rest of these.   svn_client.h indicates
that these were copied from that struct and mean the same things.   They are
also only useful when working with a \s-1WC.\s0
.ie n .IP "$info\->\fIhas_wc_info()\fR" 8
.el .IP "\f(CW$info\fR\->\fIhas_wc_info()\fR" 8
.IX Item "$info->has_wc_info()"
.PD 0
.ie n .IP "$info\->\fIschedule()\fR" 8
.el .IP "\f(CW$info\fR\->\fIschedule()\fR" 8
.IX Item "$info->schedule()"
.ie n .IP "$info\->\fIcopyfrom_url()\fR" 8
.el .IP "\f(CW$info\fR\->\fIcopyfrom_url()\fR" 8
.IX Item "$info->copyfrom_url()"
.ie n .IP "$info\->\fIcopyfrom_rev()\fR" 8
.el .IP "\f(CW$info\fR\->\fIcopyfrom_rev()\fR" 8
.IX Item "$info->copyfrom_rev()"
.ie n .IP "$info\->\fItext_time()\fR" 8
.el .IP "\f(CW$info\fR\->\fItext_time()\fR" 8
.IX Item "$info->text_time()"
.ie n .IP "$info\->\fIprop_time()\fR" 8
.el .IP "\f(CW$info\fR\->\fIprop_time()\fR" 8
.IX Item "$info->prop_time()"
.ie n .IP "$info\->\fIchecksum()\fR" 8
.el .IP "\f(CW$info\fR\->\fIchecksum()\fR" 8
.IX Item "$info->checksum()"
.ie n .IP "$info\->\fIconflict_old()\fR" 8
.el .IP "\f(CW$info\fR\->\fIconflict_old()\fR" 8
.IX Item "$info->conflict_old()"
.ie n .IP "$info\->\fIconflict_new()\fR" 8
.el .IP "\f(CW$info\fR\->\fIconflict_new()\fR" 8
.IX Item "$info->conflict_new()"
.ie n .IP "$info\->\fIconflict_wrk()\fR" 8
.el .IP "\f(CW$info\fR\->\fIconflict_wrk()\fR" 8
.IX Item "$info->conflict_wrk()"
.ie n .IP "$info\->\fIprejfile()\fR" 8
.el .IP "\f(CW$info\fR\->\fIprejfile()\fR" 8
.IX Item "$info->prejfile()"
.PD
.SS "svn_client_commit_item3_t"
.IX Subsection "svn_client_commit_item3_t"
.ie n .IP "$commit_item\->\fIpath()\fR" 8
.el .IP "\f(CW$commit_item\fR\->\fIpath()\fR" 8
.IX Item "$commit_item->path()"
Absolute working-copy path of item.
.ie n .IP "$commit_item\->\fIkind()\fR" 8
.el .IP "\f(CW$commit_item\fR\->\fIkind()\fR" 8
.IX Item "$commit_item->kind()"
An integer representing the type of node it is (file/dir).
Can be one of the following constants:
\&\f(CW$SVN::Node::none\fR
\&\f(CW$SVN::Node::file\fR
\&\f(CW$SVN::Node::dir\fR
\&\f(CW$SVN::Node::unknown\fR
.ie n .IP "$commit_item\->\fIurl()\fR" 8
.el .IP "\f(CW$commit_item\fR\->\fIurl()\fR" 8
.IX Item "$commit_item->url()"
Commit \s-1URL\s0 for this item.
.ie n .IP "$commit_item\->\fIrevision()\fR" 8
.el .IP "\f(CW$commit_item\fR\->\fIrevision()\fR" 8
.IX Item "$commit_item->revision()"
Revision (copyfrom_rev if state_flags has \s-1IS_COPY\s0 set).
.ie n .IP "$commit_item\->\fIcopyform_url()\fR;" 8
.el .IP "\f(CW$commit_item\fR\->\fIcopyform_url()\fR;" 8
.IX Item "$commit_item->copyform_url();"
CopyFrom \s-1URL\s0
.ie n .IP "$commit_item\->\fIstate_flags()\fR;" 8
.el .IP "\f(CW$commit_item\fR\->\fIstate_flags()\fR;" 8
.IX Item "$commit_item->state_flags();"
One of several state flags:
\&\f(CW$SVN::Client::COMMIT_ITEM_ADD\fR
\&\f(CW$SVN::Client::COMMIT_ITEM_DELETE\fR
\&\f(CW$SVN::Client::COMMIT_ITEM_TEXT_MODS\fR
\&\f(CW$SVN::Client::COMMIT_ITEM_PROP_MODS\fR
\&\f(CW$SVN::Client::COMMIT_ITEM_IS_COPY\fR
.ie n .IP "$commit_item\->\fIincoming_prop_changes()\fR" 8
.el .IP "\f(CW$commit_item\fR\->\fIincoming_prop_changes()\fR" 8
.IX Item "$commit_item->incoming_prop_changes()"
A reference to an array of svn_prop_t objects representing changes to
\&\s-1WC\s0 properties.
.ie n .IP "$commit_item\->\fIoutgoing_prop_changes()\fR" 8
.el .IP "\f(CW$commit_item\fR\->\fIoutgoing_prop_changes()\fR" 8
.IX Item "$commit_item->outgoing_prop_changes()"
A reference to an array of svn_prop_t objects representing extra
changes to properties in the repository (which are not necessarily
reflected by the \s-1WC\s0).
.SS "svn_client_commit_info_t"
.IX Subsection "svn_client_commit_info_t"
.ie n .IP "$commit_info\->\fIrevision()\fR" 4
.el .IP "\f(CW$commit_info\fR\->\fIrevision()\fR" 4
.IX Item "$commit_info->revision()"
Just committed revision.
.ie n .IP "$commit_info\->\fIdate()\fR" 4
.el .IP "\f(CW$commit_info\fR\->\fIdate()\fR" 4
.IX Item "$commit_info->date()"
Server-Side date of the commit as a string.
.ie n .IP "$commit_info\->\fIauthor()\fR" 4
.el .IP "\f(CW$commit_info\fR\->\fIauthor()\fR" 4
.IX Item "$commit_info->author()"
Author of the commit.
.SS "svn_client_proplist_item_t"
.IX Subsection "svn_client_proplist_item_t"
.ie n .IP "$proplist\->\fInode_name()\fR" 8
.el .IP "\f(CW$proplist\fR\->\fInode_name()\fR" 8
.IX Item "$proplist->node_name()"
The name of the node on which these properties are set.
.ie n .IP "$proplist\->\fIprop_hash()\fR" 8
.el .IP "\f(CW$proplist\fR\->\fIprop_hash()\fR" 8
.IX Item "$proplist->prop_hash()"
A reference to a hash of property names and values.
.SS "svn_client_diff_summarize_kind_t \- SVN::Summarize"
.IX Subsection "svn_client_diff_summarize_kind_t - SVN::Summarize"
An enum of the following constants:
.PP
\&\f(CW$SVN::Client::Summarize::normal\fR, \f(CW$SVN::Client::Summarize::added\fR,
\&\f(CW$SVN::Client::Summarize::modified\fR, \f(CW$SVN::Client::Summarize::deleted\fR.
.SS "svn_client_diff_summarize_t"
.IX Subsection "svn_client_diff_summarize_t"
.ie n .IP "$diff_summarize\->\fIpath()\fR" 8
.el .IP "\f(CW$diff_summarize\fR\->\fIpath()\fR" 8
.IX Item "$diff_summarize->path()"
Path relative to the target.  If the target is a file, path is the
empty string.
.ie n .IP "$diff_summarize\->\fIsummarize_kind()\fR" 8
.el .IP "\f(CW$diff_summarize\fR\->\fIsummarize_kind()\fR" 8
.IX Item "$diff_summarize->summarize_kind()"
Change kind.
.ie n .IP "$diff_summarize\->\fIprop_changed()\fR" 8
.el .IP "\f(CW$diff_summarize\fR\->\fIprop_changed()\fR" 8
.IX Item "$diff_summarize->prop_changed()"
Properties changed?
.ie n .IP "$diff_summarize\->\fInode_kind()\fR" 8
.el .IP "\f(CW$diff_summarize\fR\->\fInode_kind()\fR" 8
.IX Item "$diff_summarize->node_kind()"
File or dir?
.SS "\s-1ADDITIONAL METHODS\s0"
.IX Subsection "ADDITIONAL METHODS"
The following methods work, but are not currently documented in this
file.  Please consult the svn_client.h section in the Subversion \s-1API\s0
for more details.
.ie n .IP "$client\->add_to_changelist(...)" 4
.el .IP "\f(CW$client\fR\->add_to_changelist(...)" 4
.IX Item "$client->add_to_changelist(...)"
.PD 0
.ie n .IP "$client\->blame2(...)" 4
.el .IP "\f(CW$client\fR\->blame2(...)" 4
.IX Item "$client->blame2(...)"
.ie n .IP "$client\->blame3(...)" 4
.el .IP "\f(CW$client\fR\->blame3(...)" 4
.IX Item "$client->blame3(...)"
.ie n .IP "$client\->blame4(...)" 4
.el .IP "\f(CW$client\fR\->blame4(...)" 4
.IX Item "$client->blame4(...)"
.ie n .IP "$client\->cat2(...)" 4
.el .IP "\f(CW$client\fR\->cat2(...)" 4
.IX Item "$client->cat2(...)"
.ie n .IP "$client\->commit2(...)" 4
.el .IP "\f(CW$client\fR\->commit2(...)" 4
.IX Item "$client->commit2(...)"
.ie n .IP "$client\->commit3(...)" 4
.el .IP "\f(CW$client\fR\->commit3(...)" 4
.IX Item "$client->commit3(...)"
.ie n .IP "$client\->commit4(...)" 4
.el .IP "\f(CW$client\fR\->commit4(...)" 4
.IX Item "$client->commit4(...)"
.ie n .IP "$client\->copy2(...)" 4
.el .IP "\f(CW$client\fR\->copy2(...)" 4
.IX Item "$client->copy2(...)"
.ie n .IP "$client\->copy3(...)" 4
.el .IP "\f(CW$client\fR\->copy3(...)" 4
.IX Item "$client->copy3(...)"
.ie n .IP "$client\->copy4(...)" 4
.el .IP "\f(CW$client\fR\->copy4(...)" 4
.IX Item "$client->copy4(...)"
.ie n .IP "$client\->create_context(...)" 4
.el .IP "\f(CW$client\fR\->create_context(...)" 4
.IX Item "$client->create_context(...)"
.ie n .IP "$client\->delete2(...)" 4
.el .IP "\f(CW$client\fR\->delete2(...)" 4
.IX Item "$client->delete2(...)"
.ie n .IP "$client\->delete3(...)" 4
.el .IP "\f(CW$client\fR\->delete3(...)" 4
.IX Item "$client->delete3(...)"
.ie n .IP "$client\->diff2(...)" 4
.el .IP "\f(CW$client\fR\->diff2(...)" 4
.IX Item "$client->diff2(...)"
.ie n .IP "$client\->diff3(...)" 4
.el .IP "\f(CW$client\fR\->diff3(...)" 4
.IX Item "$client->diff3(...)"
.ie n .IP "$client\->diff4(...)" 4
.el .IP "\f(CW$client\fR\->diff4(...)" 4
.IX Item "$client->diff4(...)"
.ie n .IP "$client\->diff_peg(...)" 4
.el .IP "\f(CW$client\fR\->diff_peg(...)" 4
.IX Item "$client->diff_peg(...)"
.ie n .IP "$client\->diff_peg2(...)" 4
.el .IP "\f(CW$client\fR\->diff_peg2(...)" 4
.IX Item "$client->diff_peg2(...)"
.ie n .IP "$client\->diff_peg3(...)" 4
.el .IP "\f(CW$client\fR\->diff_peg3(...)" 4
.IX Item "$client->diff_peg3(...)"
.ie n .IP "$client\->diff_peg4(...)" 4
.el .IP "\f(CW$client\fR\->diff_peg4(...)" 4
.IX Item "$client->diff_peg4(...)"
.ie n .IP "$client\->diff_summarize2(...)" 4
.el .IP "\f(CW$client\fR\->diff_summarize2(...)" 4
.IX Item "$client->diff_summarize2(...)"
.ie n .IP "$client\->diff_summarize_dup(...)" 4
.el .IP "\f(CW$client\fR\->diff_summarize_dup(...)" 4
.IX Item "$client->diff_summarize_dup(...)"
.ie n .IP "$client\->diff_summarize_peg(...)" 4
.el .IP "\f(CW$client\fR\->diff_summarize_peg(...)" 4
.IX Item "$client->diff_summarize_peg(...)"
.ie n .IP "$client\->diff_summarize_peg2(...)" 4
.el .IP "\f(CW$client\fR\->diff_summarize_peg2(...)" 4
.IX Item "$client->diff_summarize_peg2(...)"
.ie n .IP "$client\->export2(...)" 4
.el .IP "\f(CW$client\fR\->export2(...)" 4
.IX Item "$client->export2(...)"
.ie n .IP "$client\->export3(...)" 4
.el .IP "\f(CW$client\fR\->export3(...)" 4
.IX Item "$client->export3(...)"
.ie n .IP "$client\->export4(...)" 4
.el .IP "\f(CW$client\fR\->export4(...)" 4
.IX Item "$client->export4(...)"
.ie n .IP "$client\->import2(...)" 4
.el .IP "\f(CW$client\fR\->import2(...)" 4
.IX Item "$client->import2(...)"
.ie n .IP "$client\->import3(...)" 4
.el .IP "\f(CW$client\fR\->import3(...)" 4
.IX Item "$client->import3(...)"
.ie n .IP "$client\->info2(...)" 4
.el .IP "\f(CW$client\fR\->info2(...)" 4
.IX Item "$client->info2(...)"
.ie n .IP "$client\->invoke_blame_receiver(...)" 4
.el .IP "\f(CW$client\fR\->invoke_blame_receiver(...)" 4
.IX Item "$client->invoke_blame_receiver(...)"
.ie n .IP "$client\->invoke_blame_receiver2(...)" 4
.el .IP "\f(CW$client\fR\->invoke_blame_receiver2(...)" 4
.IX Item "$client->invoke_blame_receiver2(...)"
.ie n .IP "$client\->invoke_diff_summarize_func(...)" 4
.el .IP "\f(CW$client\fR\->invoke_diff_summarize_func(...)" 4
.IX Item "$client->invoke_diff_summarize_func(...)"
.ie n .IP "$client\->list(...)" 4
.el .IP "\f(CW$client\fR\->list(...)" 4
.IX Item "$client->list(...)"
.ie n .IP "$client\->list2(...)" 4
.el .IP "\f(CW$client\fR\->list2(...)" 4
.IX Item "$client->list2(...)"
.ie n .IP "$client\->ls2(...)" 4
.el .IP "\f(CW$client\fR\->ls2(...)" 4
.IX Item "$client->ls2(...)"
.ie n .IP "$client\->ls3(...)" 4
.el .IP "\f(CW$client\fR\->ls3(...)" 4
.IX Item "$client->ls3(...)"
.ie n .IP "$client\->merge2(...)" 4
.el .IP "\f(CW$client\fR\->merge2(...)" 4
.IX Item "$client->merge2(...)"
.ie n .IP "$client\->merge3(...)" 4
.el .IP "\f(CW$client\fR\->merge3(...)" 4
.IX Item "$client->merge3(...)"
.ie n .IP "$client\->merge_peg(...)" 4
.el .IP "\f(CW$client\fR\->merge_peg(...)" 4
.IX Item "$client->merge_peg(...)"
.ie n .IP "$client\->merge_peg2(...)" 4
.el .IP "\f(CW$client\fR\->merge_peg2(...)" 4
.IX Item "$client->merge_peg2(...)"
.ie n .IP "$client\->merge_peg3(...)" 4
.el .IP "\f(CW$client\fR\->merge_peg3(...)" 4
.IX Item "$client->merge_peg3(...)"
.ie n .IP "$client\->move2(...)" 4
.el .IP "\f(CW$client\fR\->move2(...)" 4
.IX Item "$client->move2(...)"
.ie n .IP "$client\->move3(...)" 4
.el .IP "\f(CW$client\fR\->move3(...)" 4
.IX Item "$client->move3(...)"
.ie n .IP "$client\->move4(...)" 4
.el .IP "\f(CW$client\fR\->move4(...)" 4
.IX Item "$client->move4(...)"
.ie n .IP "$client\->move5(...)" 4
.el .IP "\f(CW$client\fR\->move5(...)" 4
.IX Item "$client->move5(...)"
.ie n .IP "$client\->open_ra_session(...)" 4
.el .IP "\f(CW$client\fR\->open_ra_session(...)" 4
.IX Item "$client->open_ra_session(...)"
.ie n .IP "$client\->propget2(...)" 4
.el .IP "\f(CW$client\fR\->propget2(...)" 4
.IX Item "$client->propget2(...)"
.ie n .IP "$client\->propget3(...)" 4
.el .IP "\f(CW$client\fR\->propget3(...)" 4
.IX Item "$client->propget3(...)"
.ie n .IP "$client\->proplist2(...)" 4
.el .IP "\f(CW$client\fR\->proplist2(...)" 4
.IX Item "$client->proplist2(...)"
.ie n .IP "$client\->proplist3(...)" 4
.el .IP "\f(CW$client\fR\->proplist3(...)" 4
.IX Item "$client->proplist3(...)"
.ie n .IP "$client\->propset2(...)" 4
.el .IP "\f(CW$client\fR\->propset2(...)" 4
.IX Item "$client->propset2(...)"
.ie n .IP "$client\->propset3(...)" 4
.el .IP "\f(CW$client\fR\->propset3(...)" 4
.IX Item "$client->propset3(...)"
.ie n .IP "$client\->remove_from_changelist(...)" 4
.el .IP "\f(CW$client\fR\->remove_from_changelist(...)" 4
.IX Item "$client->remove_from_changelist(...)"
.ie n .IP "$client\->resolve(...)" 4
.el .IP "\f(CW$client\fR\->resolve(...)" 4
.IX Item "$client->resolve(...)"
.ie n .IP "$client\->revert2(...)" 4
.el .IP "\f(CW$client\fR\->revert2(...)" 4
.IX Item "$client->revert2(...)"
.ie n .IP "$client\->switch2(...)" 4
.el .IP "\f(CW$client\fR\->switch2(...)" 4
.IX Item "$client->switch2(...)"
.ie n .IP "$client\->unlock(...)" 4
.el .IP "\f(CW$client\fR\->unlock(...)" 4
.IX Item "$client->unlock(...)"
.ie n .IP "$client\->version(...)" 4
.el .IP "\f(CW$client\fR\->version(...)" 4
.IX Item "$client->version(...)"
.PD
.SH "TODO"
.IX Header "TODO"
* Better support for the config.
.PP
* Unit tests for cleanup, diff, export, merge, move, relocate, resolved
and switch.  This may reveal problems for using these methods as I haven't
tested them yet that require deeper fixes.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chia-liang Kao <clkao@clkao.org>
.PP
Ben Reser <ben@reser.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 7
\&    Licensed to the Apache Software Foundation (ASF) under one
\&    or more contributor license agreements.  See the NOTICE file
\&    distributed with this work for additional information
\&    regarding copyright ownership.  The ASF licenses this file
\&    to you under the Apache License, Version 2.0 (the
\&    "License"); you may not use this file except in compliance
\&    with the License.  You may obtain a copy of the License at
\&
\&      http://www.apache.org/licenses/LICENSE\-2.0
\&
\&    Unless required by applicable law or agreed to in writing,
\&    software distributed under the License is distributed on an
\&    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
\&    KIND, either express or implied.  See the License for the
\&    specific language governing permissions and limitations
\&    under the License.
.Ve
